<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `memory` crate."><meta name="keywords" content="rust, rustlang, rust-lang, memory"><title>memory - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark.css"><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="shortcut icon" href="../favicon.ico"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../memory/index.html'><div class='logo-container'><img src='../rust-logo.png' alt='logo'></div></a><p class='location'>Crate memory</p><div class="sidebar-elems"><a id='all-types' href='all.html'><p>See all memory's items</p></a><div class="block items"><ul><li><a href="#structs">Structs</a></li><li><a href="#statics">Statics</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Definitions</a></li></ul></div><p class='location'></p><script>window.sidebarCurrent = {name: 'memory', ty: 'mod', relpath: '../'};</script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/memory/lib.rs.html#1-294' title='goto source code'>[src]</a></span><span class='in-band'>Crate <a class="mod" href=''>memory</a></span></h1><div class='docblock'><p>This crate implements the virtual memory subsystem for Theseus,
which is fairly robust and provides a unification between 
arbitrarily mapped sections of memory and Rust's lifetime system. 
Originally based on Phil Opp's blog_os. </p>
</div><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table><tr class='module-item'><td><a class="struct" href="struct.AggregatedSectionMemoryBounds.html" title='memory::AggregatedSectionMemoryBounds struct'>AggregatedSectionMemoryBounds</a></td><td class='docblock-short'><p>The address bounds and flags of the initial kernel sections that need mapping. </p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.AllocatedPages.html" title='memory::AllocatedPages struct'>AllocatedPages</a></td><td class='docblock-short'><p>Represents an allocated range of virtual addresses, specified in pages. 
These pages are not initially mapped to any physical memory frames, you must do that separately.
This object represents ownership of those pages; if this object falls out of scope,
it will be dropped, and the pages will be de-allocated. 
See <code>MappedPages</code> struct for a similar object that unmaps pages when dropped.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.AreaFrameAllocator.html" title='memory::AreaFrameAllocator struct'>AreaFrameAllocator</a></td><td class='docblock-short'><p>A frame allocator that uses the memory areas from the multiboot information structure as
source. The {kernel, multiboot}_{start, end} fields are used to avoid returning memory that is
already in use.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Entry.html" title='memory::Entry struct'>Entry</a></td><td class='docblock-short'><p>A page table entry, which is a <code>u64</code> value under the hood.
It contains a physical frame address and entry flag access bits.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.EntryFlags.html" title='memory::EntryFlags struct'>EntryFlags</a></td><td class='docblock-short'><p>Page table entry flags.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Frame.html" title='memory::Frame struct'>Frame</a></td><td class='docblock-short'><p>A <code>Frame</code> is a chunk of <strong>physical</strong> memory,
similar to how a <code>Page</code> is a chunk of <strong>virtual</strong> memory.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.FrameRange.html" title='memory::FrameRange struct'>FrameRange</a></td><td class='docblock-short'><p>A range of <code>Frame</code>s that are contiguous in physical memory.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.MappedPages.html" title='memory::MappedPages struct'>MappedPages</a></td><td class='docblock-short'><p>Represents a contiguous range of virtual memory pages that are currently mapped. 
A <code>MappedPages</code> object can only have a single range of contiguous pages, not multiple disjoint ranges.
This does not guarantee that its pages are mapped to frames that are contiguous in physical memory.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Mapper.html" title='memory::Mapper struct'>Mapper</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="struct" href="struct.MemoryManagementInfo.html" title='memory::MemoryManagementInfo struct'>MemoryManagementInfo</a></td><td class='docblock-short'><p>This holds all the information for a <code>Task</code>'s memory mappings and address space
(this is basically the equivalent of Linux's mm_struct)</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Page.html" title='memory::Page struct'>Page</a></td><td class='docblock-short'><p>A virtual memory page, which contains the index of the page</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.PageRange.html" title='memory::PageRange struct'>PageRange</a></td><td class='docblock-short'><p>A range of <code>Page</code>s that are contiguous in virtual memory.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.PageTable.html" title='memory::PageTable struct'>PageTable</a></td><td class='docblock-short'><p>A root (P4) page table.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.PhysicalAddress.html" title='memory::PhysicalAddress struct'>PhysicalAddress</a></td><td class='docblock-short'><p>A physical memory address, which is a <code>usize</code> under the hood.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.PhysicalMemoryArea.html" title='memory::PhysicalMemoryArea struct'>PhysicalMemoryArea</a></td><td class='docblock-short'><p>An area of physical memory.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.SectionMemoryBounds.html" title='memory::SectionMemoryBounds struct'>SectionMemoryBounds</a></td><td class='docblock-short'><p>The address bounds and mapping flags of a section's memory region.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Stack.html" title='memory::Stack struct'>Stack</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="struct" href="struct.StackAllocator.html" title='memory::StackAllocator struct'>StackAllocator</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="struct" href="struct.TemporaryPage.html" title='memory::TemporaryPage struct'>TemporaryPage</a></td><td class='docblock-short'><p>A Page that can be temporarily mapped to the recursive page table frame,
used for purposes of editing the page tables themselves. </p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.VirtualAddress.html" title='memory::VirtualAddress struct'>VirtualAddress</a></td><td class='docblock-short'><p>A virtual memory address, which is a <code>usize</code> under the hood.</p>
</td></tr></table><h2 id='statics' class='section-header'><a href="#statics">Statics</a></h2>
<table><tr class='module-item'><td><a class="static" href="static.BROADCAST_TLB_SHOOTDOWN_FUNC.html" title='memory::BROADCAST_TLB_SHOOTDOWN_FUNC static'>BROADCAST_TLB_SHOOTDOWN_FUNC</a></td><td class='docblock-short'></td></tr></table><h2 id='traits' class='section-header'><a href="#traits">Traits</a></h2>
<table><tr class='module-item'><td><a class="trait" href="trait.FrameAllocator.html" title='memory::FrameAllocator trait'>FrameAllocator</a></td><td class='docblock-short'></td></tr></table><h2 id='functions' class='section-header'><a href="#functions">Functions</a></h2>
<table><tr class='module-item'><td><a class="fn" href="fn.allocate_frame.html" title='memory::allocate_frame fn'>allocate_frame</a></td><td class='docblock-short'><p>Convenience method for allocating a new Frame.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.allocate_frames.html" title='memory::allocate_frames fn'>allocate_frames</a></td><td class='docblock-short'><p>Convenience method for allocating several contiguous Frames.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.allocate_pages.html" title='memory::allocate_pages fn'>allocate_pages</a></td><td class='docblock-short'><p>Allocates the given number of pages, but simply reserves the virtual addresses; 
it does not allocate actual physical memory frames nor do any mapping. 
Thus these pages aren't directly usable until they are mapped to physical frames. 
Allocation is quick, technically O(n) but generally will allocate immediately
because the largest free chunks are stored at the front of the list.
Fragmentation isn't cleaned up until we're out of address space, but not really a big deal.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.allocate_pages_by_bytes.html" title='memory::allocate_pages_by_bytes fn'>allocate_pages_by_bytes</a></td><td class='docblock-short'><p>Convenience function for allocating pages by giving the number of bytes
rather than the number of pages. It will still allocate whole pages
by rounding up the number of bytes. 
See <a href="fn.allocate_pages.html"><code>allocate_pages()</code></a></p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.create_contiguous_mapping.html" title='memory::create_contiguous_mapping fn'>create_contiguous_mapping</a></td><td class='docblock-short'><p>A convenience function that creates a new memory mapping by allocating frames that are contiguous in physical memory.
If contiguous frames are not required, then see <a href="fn.create_mapping.html"><code>create_mapping()</code></a>.
Returns a tuple containing the new <code>MappedPages</code> and the starting PhysicalAddress of the first frame,
which is a convenient way to get the physical address without walking the page tables.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.create_mapping.html" title='memory::create_mapping fn'>create_mapping</a></td><td class='docblock-short'><p>A convenience function that creates a new memory mapping. The pages allocated are contiguous in memory but there's
no guarantee that the frames they are mapped to are also contiguous in memory. If contiguous frames are required
then see <a href="fn.create_contiguous_mapping.html"><code>create_contiguous_mapping()</code></a>.
Returns the new <code>MappedPages.</code> </p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.get_current_p4.html" title='memory::get_current_p4 fn'>get_current_p4</a></td><td class='docblock-short'><p>Returns the current top-level page table frame</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.get_frame_allocator_ref.html" title='memory::get_frame_allocator_ref fn'>get_frame_allocator_ref</a></td><td class='docblock-short'><p>Returns a reference to the system-wide <code>FrameAllocator</code>, if initialized.
If not, it returns <code>None</code>.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.get_kernel_mmi_ref.html" title='memory::get_kernel_mmi_ref fn'>get_kernel_mmi_ref</a></td><td class='docblock-short'><p>Returns a cloned reference to the kernel's <code>MemoryManagementInfo</code>, if initialized.
If not, it returns None.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.init.html" title='memory::init fn'>init</a></td><td class='docblock-short'><p>Initializes the virtual memory management system.
Consumes the given BootInformation, because after the memory system is initialized,
the original BootInformation will be unmapped and inaccessible.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.init_post_heap.html" title='memory::init_post_heap fn'>init_post_heap</a></td><td class='docblock-short'><p>Finishes Initializing the virtual memory management system after the heap is initialized and returns a MemoryManagementInfo instance,
which represents Task zero's (the kernel's) address space. </p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.set_broadcast_tlb_shootdown_cb.html" title='memory::set_broadcast_tlb_shootdown_cb fn'>set_broadcast_tlb_shootdown_cb</a></td><td class='docblock-short'><p>Set the function callback that will be invoked every time a TLB shootdown is necessary,
i.e., during page table remapping and unmapping operations.</p>
</td></tr></table><h2 id='types' class='section-header'><a href="#types">Type Definitions</a></h2>
<table><tr class='module-item'><td><a class="type" href="type.FrameAllocatorRef.html" title='memory::FrameAllocatorRef type'>FrameAllocatorRef</a></td><td class='docblock-short'><p>A shareable reference to a <code>FrameAllocator</code> struct wrapper in a lock.</p>
</td></tr><tr class='module-item'><td><a class="type" href="type.MmiRef.html" title='memory::MmiRef type'>MmiRef</a></td><td class='docblock-short'><p>A shareable reference to a <code>MemoryManagementInfo</code> struct wrapper in a lock.</p>
</td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd><dt><kbd>↹</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g., <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g., <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g., <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><script>window.rootPath = "../";window.currentCrate = "memory";</script><script src="../aliases.js"></script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>