initSidebarItems({"fn":[["allocate_frame","Convenience method for allocating a new Frame."],["allocate_frames","Convenience method for allocating several contiguous Frames."],["allocate_pages","Allocates the given number of pages, but simply reserves the virtual addresses;  it does not allocate actual physical memory frames nor do any mapping.  Thus these pages aren't directly usable until they are mapped to physical frames.  Allocation is quick, technically O(n) but generally will allocate immediately because the largest free chunks are stored at the front of the list. Fragmentation isn't cleaned up until we're out of address space, but not really a big deal."],["allocate_pages_by_bytes","Convenience function for allocating pages by giving the number of bytes rather than the number of pages. It will still allocate whole pages by rounding up the number of bytes.  See `allocate_pages()`"],["create_contiguous_mapping","A convenience function that creates a new memory mapping by allocating frames that are contiguous in physical memory. If contiguous frames are not required, then see `create_mapping()`. Returns a tuple containing the new `MappedPages` and the starting PhysicalAddress of the first frame, which is a convenient way to get the physical address without walking the page tables."],["create_mapping","A convenience function that creates a new memory mapping. The pages allocated are contiguous in memory but there's no guarantee that the frames they are mapped to are also contiguous in memory. If contiguous frames are required then see `create_contiguous_mapping()`. Returns the new `MappedPages.` "],["get_current_p4","Returns the current top-level page table frame"],["get_frame_allocator_ref","Returns a reference to the system-wide `FrameAllocator`, if initialized. If not, it returns `None`."],["get_kernel_mmi_ref","Returns a cloned reference to the kernel's `MemoryManagementInfo`, if initialized. If not, it returns None."],["init","Initializes the virtual memory management system. Consumes the given BootInformation, because after the memory system is initialized, the original BootInformation will be unmapped and inaccessible."],["init_post_heap","Finishes Initializing the virtual memory management system after the heap is initialized and returns a MemoryManagementInfo instance, which represents Task zero's (the kernel's) address space. "],["set_broadcast_tlb_shootdown_cb","Set the function callback that will be invoked every time a TLB shootdown is necessary, i.e., during page table remapping and unmapping operations."]],"static":[["BROADCAST_TLB_SHOOTDOWN_FUNC",""]],"struct":[["AggregatedSectionMemoryBounds","The address bounds and flags of the initial kernel sections that need mapping. "],["AllocatedPages","Represents an allocated range of virtual addresses, specified in pages.  These pages are not initially mapped to any physical memory frames, you must do that separately. This object represents ownership of those pages; if this object falls out of scope, it will be dropped, and the pages will be de-allocated.  See `MappedPages` struct for a similar object that unmaps pages when dropped."],["AreaFrameAllocator","A frame allocator that uses the memory areas from the multiboot information structure as source. The {kernel, multiboot}_{start, end} fields are used to avoid returning memory that is already in use."],["Entry","A page table entry, which is a `u64` value under the hood. It contains a physical frame address and entry flag access bits."],["EntryFlags","Page table entry flags."],["Frame","A `Frame` is a chunk of physical memory, similar to how a `Page` is a chunk of virtual memory."],["FrameRange","A range of `Frame`s that are contiguous in physical memory."],["MappedPages","Represents a contiguous range of virtual memory pages that are currently mapped.  A `MappedPages` object can only have a single range of contiguous pages, not multiple disjoint ranges. This does not guarantee that its pages are mapped to frames that are contiguous in physical memory."],["Mapper",""],["MemoryManagementInfo","This holds all the information for a `Task`'s memory mappings and address space (this is basically the equivalent of Linux's mm_struct)"],["Page","A virtual memory page, which contains the index of the page"],["PageRange","A range of `Page`s that are contiguous in virtual memory."],["PageTable","A root (P4) page table."],["PhysicalAddress","A physical memory address, which is a `usize` under the hood."],["PhysicalMemoryArea","An area of physical memory."],["SectionMemoryBounds","The address bounds and mapping flags of a section's memory region."],["Stack",""],["StackAllocator",""],["TemporaryPage","A Page that can be temporarily mapped to the recursive page table frame, used for purposes of editing the page tables themselves. "],["VirtualAddress","A virtual memory address, which is a `usize` under the hood."]],"trait":[["FrameAllocator",""]],"type":[["FrameAllocatorRef","A shareable reference to a `FrameAllocator` struct wrapper in a lock."],["MmiRef","A shareable reference to a `MemoryManagementInfo` struct wrapper in a lock."]]});