<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `pmu_x86` crate."><meta name="keywords" content="rust, rustlang, rust-lang, pmu_x86"><title>pmu_x86 - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark.css"><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="shortcut icon" href="../favicon.ico"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../pmu_x86/index.html'><div class='logo-container'><img src='../rust-logo.png' alt='logo'></div></a><p class='location'>Crate pmu_x86</p><div class="sidebar-elems"><a id='all-types' href='all.html'><p>See all pmu_x86's items</p></a><div class="block items"><ul><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#functions">Functions</a></li></ul></div><p class='location'></p><script>window.sidebarCurrent = {name: 'pmu_x86', ty: 'mod', relpath: '../'};</script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/pmu_x86/lib.rs.html#1-821' title='goto source code'>[src]</a></span><span class='in-band'>Crate <a class="mod" href=''>pmu_x86</a></span></h1><div class='docblock'><p>Support for the Performance Monitoring Unit </p>
<p>We have support for PMU version 2. Each succesive PMU version includes the features provided by the previous versions.</p>
<p>Version 1 Support:
To configure an architectural performance monitoring event, we program the performance event select registers (IA32_PERFEVTSELx MSRs).
The result of the performance monitoring event is reported in a general purpose Performance Monitoring Counter (PMC) (IA32_PMCx MSR).
There is one PMC for each performance event select register, and one PMU per logical core. </p>
<p>Version 2 Support:
Three of the architectural events are counted using fixed function MSRs (IA32_FIXED_CTR0 through IA32_FIXED_CTR2), 
each with an associated control register.
Three more MSRS are provided to simplify event programming. They are: </p>
<ul>
<li>IA32_PERF_GLOBAL_CTRL: 
allows software to enable/disable event counting of any combination of fixed-function PMCs or any general-purpose PMCs via a single WRMSR.</li>
<li>IA32_PERF_GLOBAL_STATUS: 
allows software to query counter overflow conditions on any combination of fixed-function PMCs or general-purpose PMCs via a single RDMSR.</li>
<li>IA32_PERF_GLOBAL_OVF_CTRL: 
allows software to clear counter overflow conditions on any combination of fixed-function PMCs or general-purpose PMCs via a single WRMSR.</li>
</ul>
<p>We support 2 ways to use the PMU. One is to measure the number of events that take place over a length of code.
The second is Event Based Sampling, where after a specified number of events occur, an interrupt is called and we store the instruction pointer 
and task id running at that point.</p>
<p>Currently we support a maximum core ID of 255, and up to 8 general purpose counters per core. 
A core ID greater than 255 is not supported in Theseus in general since the ID has to fit within a u8.</p>
<p>If the core ID limit is changed and we need to update the PMU data structures to support more cores then: </p>
<ul>
<li>Increase WORDS_IN_BITMAP and CORES_SUPPORTED_BY_PMU as required. For example, the cores supported is 256 so there are 4 64-bit words in the bitmap, one bit per core. </li>
<li>Add additional AtomicU64 variables to the initialization of the CORES_SAMPLING and RESULTS_READY bitmaps. </li>
</ul>
<p>If the general purpose PMC limit is reached then: </p>
<ul>
<li>Update PMCS_SUPPORTED_BY_PMU to the new PMC limit.</li>
<li>Change the element type in the PMCS_AVAILABLE vector to be larger than AtomicU8 so that there is one bit per counter.</li>
<li>Update INIT_PMCS_AVAILABLE to the new maximum value for the per core bitmap.</li>
</ul>
<p>Monitoring without interrupts is almost free (around 0.3% performance penalty) - source: &quot;These are Not Your Grand Daddy's CPU Performance Counters&quot; Blackhat USA, 2015</p>
<h1 id="example" class="section-header"><a href="#example">Example</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="ident">pmu_x86</span>::<span class="ident">init</span>();
 
<span class="kw">let</span> <span class="ident">counter_freq</span> <span class="op">=</span> <span class="number">0xFFFFF</span>;
<span class="kw">let</span> <span class="ident">num_samples</span> <span class="op">=</span> <span class="number">500</span>;
<span class="kw">let</span> <span class="ident">sampler</span> <span class="op">=</span> <span class="ident">pmu_x86</span>::<span class="ident">start_samples</span>(<span class="ident">pmu_x86</span>::<span class="ident">EventType</span>::<span class="ident">UnhaltedReferenceCycles</span>, <span class="ident">counter_freq</span>, <span class="prelude-val">None</span>, <span class="ident">num_samples</span>);
 
<span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Ok</span>(<span class="ident">my_sampler</span>) <span class="op">=</span> <span class="ident">sampler</span> {
 
	<span class="comment">// wait some time here</span>
 	
	<span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Ok</span>(<span class="kw-2">mut</span> <span class="ident">samples</span>) <span class="op">=</span> <span class="ident">pmu_x86</span>::<span class="ident">retrieve_samples</span>() {
		<span class="ident">pmu_x86</span>::<span class="ident">print_samples</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">samples</span>);
	}
}</pre></div>
<h1 id="note" class="section-header"><a href="#note">Note</a></h1>
<p>Currently, the PMU-based sampler will only capture samples on the same core as it was initialized and started from. 
So, if you run <code>pmu_x86::init()</code> and <code>pmu_x86::start_samples()</code> on CPU core 2, it will only sample events on core 2.</p>
</div><h2 id='modules' class='section-header'><a href="#modules">Modules</a></h2>
<table><tr class='module-item'><td><a class="mod" href="stat/index.html" title='pmu_x86::stat mod'>stat</a></td><td class='docblock-short'><p>This module implements the equivalent of &quot;perf stat&quot;.
Currently only 7 events are recorded.</p>
</td></tr></table><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table><tr class='module-item'><td><a class="struct" href="struct.Counter.html" title='pmu_x86::Counter struct'>Counter</a></td><td class='docblock-short'><p>A logical counter object to correspond to a physical PMC</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.SampleResults.html" title='pmu_x86::SampleResults struct'>SampleResults</a></td><td class='docblock-short'><p>Stores the instruction pointers and corresponding task IDs from the samples</p>
</td></tr></table><h2 id='enums' class='section-header'><a href="#enums">Enums</a></h2>
<table><tr class='module-item'><td><a class="enum" href="enum.EventType.html" title='pmu_x86::EventType enum'>EventType</a></td><td class='docblock-short'><p>Used to select the event type to count. Event types are described in the Intel SDM 18.2.1 for PMU Version 1.
The discriminant value for each event type is the value written to the event select register for a general purpose PMC.</p>
</td></tr></table><h2 id='functions' class='section-header'><a href="#functions">Functions</a></h2>
<table><tr class='module-item'><td><a class="fn" href="fn.find_function_names_from_samples.html" title='pmu_x86::find_function_names_from_samples fn'>find_function_names_from_samples</a></td><td class='docblock-short'><p>Finds the corresponding function for each instruction pointer and calculates the percentage amount each function occured in the samples</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.handle_sample.html" title='pmu_x86::handle_sample fn'>handle_sample</a></td><td class='docblock-short'><p>Function called in the interrupt handler to store the instruction pointer and task ID. 
The counter is then reset to its starting value or turned off.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.init.html" title='pmu_x86::init fn'>init</a></td><td class='docblock-short'><p>Initialization function that enables the PMU if one is available.
We initialize the 3 fixed PMCs and general purpose PMCs. Calling this initialization function again
on a core that has already been initialized will do nothing.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.print_samples.html" title='pmu_x86::print_samples fn'>print_samples</a></td><td class='docblock-short'><p>Simple function to print values from SampleResults in a form that the script &quot;post-mortem pmu analysis.py&quot; can parse. </p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.reset_pmu.html" title='pmu_x86::reset_pmu fn'>reset_pmu</a></td><td class='docblock-short'><p>Frees all counters and make them available to be used.
Essentially sets the PMU to its initial state.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.retrieve_samples.html" title='pmu_x86::retrieve_samples fn'>retrieve_samples</a></td><td class='docblock-short'><p>Returns the samples that were stored during sampling in the form of a SampleResults object. 
If samples are not yet finished, forces them to stop.  </p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.start_samples.html" title='pmu_x86::start_samples fn'>start_samples</a></td><td class='docblock-short'><p>Start interrupt process in order to take samples using the PMU. 
It loads the starting value as such that an overflow will occur at &quot;event_per_sample&quot; events. 
That overflow triggers an interrupt where information about the current running task is sampled.</p>
</td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd><dt><kbd>↹</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g., <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g., <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g., <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><script>window.rootPath = "../";window.currentCrate = "pmu_x86";</script><script src="../aliases.js"></script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>