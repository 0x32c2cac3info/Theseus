var N=null,E="",T="t",U="u",searchIndex={};
var R=["layout","result","FixedSizeBlockAllocator","kernel_config","context_switch_regular","An assembly macro for saving regular x86_64 registers. by…","try_from","try_into","borrow","borrow_mut","ContextRegular","type_id","formatter","GenericAddressStructure","typeid","rectangle","ordering","Rectangle","SSCached","This crate contains structures and routines for context…","The registers saved before a context switch and restored…","context_switch_sse","ContextSSE","context_switch_avx","ContextAVX","allocate","deallocate","nonnull","retrieve_empty_page","objectpage8k","heap_id","option","clear_metadata","set_heap_id","bitfield","bitfield_mut","rawlink","buffer_size","default","zoneallocator","The total size (in bytes) of the page.","METADATA_SIZE","HEAP_ID_OFFSET","first_fit","Tries to find a free block within `data` that satisfies…","Tries to allocate an object within this page.","Checks if we can still allocate more objects of a given…","is_empty","Checks if the page has currently no allocations.","Deallocates a memory object within this page.","ObjectPage8k","ZoneAllocator","SCAllocator","AllocablePage","Receiver","keyboardtype","KeyboardType","entryflags","Gets flags according to the properties of a section from…","intoiterator","EntryFlags","partial_cmp","MousePositionEvent","keyevent","to_owned","clone_into","keyboardinputevent","KeyboardInputEvent","context_switch","Switches context from an SSE Task to another SSE Task.","Creates a new ContextSSE struct that will cause the…","contextsse","arguments","colorcode","screenchar","ColorCode","ScreenChar","setloggererror","LogColor","tscticks","TscTicks","virtualaddress","physicaladdress","new_canonical","Returns the underlying `usize` value for this…","framerange","start_address","containing_address","Returns the 9-bit part of this page's virtual address that…","pagerange","size_in_bytes","into_iter","add_assign","sub_assign","__rhst","bitand_assign","bitor_assign","bitxor_assign","rangeinclusive","deref_mut","steps_between","replace_one","replace_zero","add_usize","physicalmemoryarea","PhysicalMemoryArea","SectionMemoryBounds","AggregatedSectionMemoryBounds","VirtualAddress","PhysicalAddress","FrameRange","PageRange","Page table entry flags.","bootinformation","Returns the union of the two sets of flags.","Disables all flags disabled in the set.","Returns the intersection between the two sets of flags.","Disables all flags enabled in the set.","Returns the set difference of the two sets of flags.","Adds the set of flags.","Returns the complement of this set of flags.","from_iter","Toggles the set of flags.","Returns the left flags, but with all the right flags…","elfsectionstag","memorymaptag","bootloadernametag","commandlinetag","framebuffertag","rsdpv1tag","rsdpv2tag","Returns true if the page the entry points to is a huge page.","into_huge","Copies this new `EntryFlags` object and sets the huge page…","is_writable","Returns true if the page is writable.","into_writable","Copies this new `EntryFlags` object and sets the writable…","is_executable","Returns true if these flags are executable.","from_multiboot2_section_flags","elfsection","from_elf_section_flags","from_elf_program_flags","Gets flags according to the properties of a program. ","USER_ACCESSIBLE","WRITE_THROUGH","HUGE_PAGE","NO_EXECUTE","Returns an empty set of flags","Returns the set containing all flags.","Returns the raw value of the flags currently stored.","from_bits","Convert from underlying bit representation, unless that…","from_bits_truncate","Convert from underlying bit representation, dropping any…","Returns `true` if no flags are currently stored.","Returns `true` if all flags are currently set.","intersects","Returns `true` if there are flags common to both `self`…","Returns `true` all of the flags in `other` are contained…","Inserts the specified flags in-place.","Removes the specified flags in-place.","Toggles the specified flags in-place.","Inserts or removes the specified flags depending on the…","BootInformation","allocatedpages","frameallocatorref","mappedpages","areaframeallocator","pagetable","Reinterprets this `MappedPages`'s underlying memory region…","temporarypage","allocate_frame","allocate_frames","alloc_stack","to_string","deallocate_frame","alloc_ready","size_in_pages","AllocatedPages","StackAllocator","MemoryManagementInfo","AreaFrameAllocator","TemporaryPage","MappedPages","PageTable","FrameAllocator","A virtual memory address, which is a `usize` under the hood.","A physical memory address, which is a `usize` under the…","An area of physical memory.","base_addr","A `Frame` is a chunk of physical memory, similar to how a…","A range of `Frame`s that are contiguous in physical memory.","A virtual memory page, which contains the index of the page","A range of `Page`s that are contiguous in virtual memory.","The address bounds and mapping flags of a section's memory…","The starting virtual address and physical address.","The ending virtual address and physical address.","The page table entry flags that should be used for mapping…","The address bounds and flags of the initial kernel…","Creates a new `VirtualAddress`, checking that the address…","Creates a new `VirtualAddress` that is guaranteed to be…","Creates a VirtualAddress with the value 0.","page_offset","Returns the offset that this VirtualAddress specifies into…","Creates a new `PhysicalAddress`, checking that the bits…","Creates a new `PhysicalAddress` that is guaranteed to be…","Creates a PhysicalAddress with the value 0.","frame_offset","Returns the offset that this PhysicalAddress specifies…","Returns the `Frame` containing the given `PhysicalAddress`.","Returns the `PhysicalAddress` at the start of this `Frame`.","Creates a new range of `Frame`s that spans from `start` to…","Creates a FrameRange that will always yield `None`.","from_phys_addr","A convenience method for creating a new `FrameRange` that…","Returns the `PhysicalAddress` of the starting `Frame` in…","size_in_frames","Returns the number of `Frame`s covered by this iterator.…","contains_phys_addr","Whether this `FrameRange` contains the given…","offset_from_start","Returns the offset of the given `PhysicalAddress` within…","to_extended","Returns a new, separate `FrameRange` that is extended to…","Returns the `Page` that contains the given `VirtualAddress`.","Returns the `VirtualAddress` as the start of this `Page`.","Creates a new range of `Page`s that spans from `start` to…","Creates a PageRange that will always yield `None`.","from_virt_addr","A convenience method for creating a new `PageRange` that…","Returns the `VirtualAddress` of the starting `Page`.","Returns the size in number of `Page`s. Use this instead of…","Returns the size in number of bytes.","contains_virt_addr","Whether this `PageRange` contains the given…","offset_of_address","Returns the offset of the given `VirtualAddress` within…","address_at_offset","Returns the `VirtualAddress` at the given `offset` into…","mul_assign","div_assign","rem_assign","shl_assign","shr_assign","WRITABLE","NO_CACHE","ACCESSED","contains","mutexguard","mappedpages8k","retrieve_mapped_pages","MappedPages8k","Holds allocated data within 2 4-KiB pages.","Rawlink is a type like Option but for holding a raw pointer.","A slab allocator allocates elements of a fixed size.","A zone allocator for arbitrary sized allocations.","Create a new SCAllocator.","scallocator","Returns the maximum supported object size of this allocator.","Refill the SCAllocator","Allocates a block of memory described by `layout`.","Deallocates a previously allocated `ptr` described by…","MAX_ALLOC_SIZE","Maximum size that allocated within 2 pages. (8 KiB -…","MAX_BASE_ALLOC_SIZE","Maximum size which is allocated with ObjectPages8k (8 KiB).","MAX_BASE_SIZE_CLASSES","How many allocators of type SCAllocator we have.","BASE_ALLOC_SIZES","The set of sizes the allocator has lists for.","get_max_size","Return maximum size an object of size `current_size` can…","exchange_pages_within_heap","empty_pages","The total number of empty pages in this zone allocator","Allocate a pointer to a block of memory described by…","Deallocates a pointer to a block of memory, which was…","This trait is used to define a page from which objects are…","clears the metadata section of the page","pcidevice","pcilocation","PciDevice","PciConfigSpaceAccessMechanism","PciLocation","globalalloc","phys_addr","transmitbuffer","TransmitBuffer","ReceiveBuffer","ReceivedFrame","A wrapper type around MappedPages which ensures that the…","BUFFER_SIZE","Creates a MappedPages8k object from MappedPages that have…","Returns a MappedPages8k from the SCAllocator with the…","Refills the SCAllocator for a given Layout with a…","A slab allocator implementation for objects less than…","Returns an empty page from the allocator if available.","is_full","acpisignature","tablelocation","TableLocation","AcpiTables","rwlockirqsafe","localapic","lapicipidestination","interruptchip","ApicRegisters","LocalApic","InterruptChip","LapicIpiDestination","RegisterArray","atomicmap","Starting physcal address of the receive buffer for the…","Write Back mode function for the Advanced Receive…","intel_ethernet","intel_ethernet::descriptors","set_packet_address","reset_status","descriptor_done","end_of_packet","wait_for_packet_tx","LegacyTxDescriptor","LegacyRxDescriptor","AdvancedRxDescriptor","RxDescriptor","TxDescriptor","fileordir","get_absolute_path","get_parent_dir","set_parent_dir","weakdirref","FileOrDir","Directory","IrqStatusRegisters","ChainedPics","fileref","get_name","as_mapping","VFSDirectory","Recursively gets the absolute pathname as a String","RootDirectory","A struct that represents a node in the VFS ","A tuple of: 1. The `MappedPages` that contain sections…","relocation","The details of the relocation action that was performed.","Returns `true` if the given `module_name` indicates a…","strongsectionref","weakcrateref","weakdependent","sectiontype","strongdependency","loadedsection","relocationentry","LoadedCrate","LoadedSectionInner","LoadedSection","StrongDependency","WeakDependent","RelocationEntry","CrateType","SectionType","acpitables","Definitions for the ACPI RSDT and XSDT system tables.","rwlockreadguard","boxrefmut","rwlockwriteguard","hpetacpitable","HpetTimer","HpetAcpiTable","vendor_id","receivedframe","NetworkInterfaceCard","A trait object wrapped in an Arc and Mutex that allows…","blockbounds","BlockBounds","StorageController","StorageDevice","processor","madtiter","MadtLocalApic","MadtIoApic","MadtIntSrcOverride","MadtNonMaskableInterrupt","MadtLocalApicAddressOverride","MadtEntry","volatile","The number of the queue, stored here for our convenience.","The cpu which this queue is mapped to. This in itself…","multipleheaps","MultipleHeaps","environment","Environment","is_absolute","PathComponent","acpi_table_handler","segmentselector","descriptor","AvailableSegmentSelector","Descriptor","as_any_mut","ataerror","atastatus","idecontroller","into_any","idecontrolleriter","ataidentifydata","IdeController","AtaIdentifyData","AtaDeviceType","AtaStatus","IdeControllerIter","AtaSerialNumber","AtaModelNumber","AtaFirmwareVersion","general_configuration","signature","checksum","iterator","read_sectors","write_sectors","sector_size_in_bytes","size_in_sectors","Returns the number of sectors in this drive.","A trait that represents a storage controller, such as an…","Returns an iterator of references to all `StorageDevice`s…","StorageControllerRef","A trait that represents a storage device, such as hard…","Reads content from the storage device into the given…","Writes content from the given `buffer` to the storage…","Returns the size of a single sector in bytes, as defined…","Returns the size of this drive in bytes, rounded up to the…","block_bounds","Calculates block-wise bounds based on a byte-wise offset…","StorageDeviceRef","Block-wise bounds information for a data transfer (read or…","A `Range` from the first block to the last block of the…","first_block_offset","The offset into the first block (beginning bound) where…","last_block_offset","The offset into the last block (ending bound) where the…","initialize","Returns true if the trait object wraps an object of type…","Returns a boxed object from a boxed trait object if the…","storagedevice","downcast_ref","Returns a reference to the object within the trait object…","downcast_mut","Returns a mutable reference to the object within the trait…","block_count","The total number of blocks to be transferred, i.e., `last…","is_first_block_aligned","Returns true if the first block of the transfer is aligned…","is_last_block_aligned","Returns true if the last block of the transfer is aligned…","STORAGE_CONTROLLERS","get_containing_crate_name","Parses the given symbol string to try to find the name of…","replace_containing_crate_name","Replaces the `old_crate_name` substring in the given…","crate_name_from_path","Returns the crate name that is derived from a crate object…","StrongCrateRef","A Strong reference to a `LoadedCrate`.","WeakCrateRef","A Weak reference to a `LoadedCrate`.","StrongSectionRef","A Strong reference (`Arc`) to a `LoadedSection`.","WeakSectionRef","A Weak reference (`Weak`) to a `LoadedSection`.","A Section Header iNDeX (SHNDX), as specified by the ELF…","TEXT_SECTION_FLAGS","`.text` sections are read-only and executable.","RODATA_SECTION_FLAGS","`.rodata` sections are read-only and non-executable.","DATA_BSS_SECTION_FLAGS","`.data` and `.bss` sections are read-write and…","MODULE_PREFIX_DELIMITER","The Theseus Makefile appends prefixes onto bootloader…","CRATE_HASH_DELIMITER","A crate's name and its hash are separated by \"-\", i.e.,…","SECTION_HASH_DELIMITER","A section's demangled name and its hash are separated by…","The type of a crate, based on its object file naming…","Application","Userspace","Represents a single crate whose object file has been…","crate_name","The name of this crate.","object_file","The object file that this crate was loaded from.","debug_symbols_file","The file that contains debug symbols for this crate. Debug…","A map containing all the sections in this crate. In…","text_pages","rodata_pages","data_pages","global_sections","The set of global symbols in this crate, including regular…","data_sections","The set of `.data` and `.bss` sections in this crate. The…","reexported_symbols","The set of symbols that this crate's global symbols are…","The possible types of sections that can be loaded from a…","GccExceptTable","The \".gcc_except_table\" contains landing pads for…","The \".eh_frame\" contains information about stack unwinding…","The parts of a `LoadedSection` that may be mutable, i.e.,…","sections_i_depend_on","The list of sections in foreign crates that this section…","sections_dependent_on_me","The list of sections in foreign crates that depend on this…","Represents a section that has been loaded and is part of a…","The full String name of this section, a fully-qualified…","The type of this section, e.g., `.text`, `.rodata`,…","Whether or not this section's symbol was exported globally…","mapped_pages","The `MappedPages` that cover this section.","mapped_pages_offset","The offset into the `mapped_pages` where this section starts","address_range","The range of `VirtualAddress`es covered by this section,…","parent_crate","The `LoadedCrate` object that contains/owns this section","The inner contents of a section that could possibly change…","A representation that the owner `A` of (a `LoadedSection`…","A strong reference to the `LoadedSection` `B` that the…","A representation that the `section` `A` in this struct…","A weak reference to the `LoadedSection` `A` that depends…","The information necessary to calculate and write a…","The type of relocation calculation that is performed to…","The value that is added to the source section's address…","The offset from the starting virtual address of the target…","write_relocation","Write an actual relocation entry. # Arguments *…","cratenamespace","parse_nano_core","replace_nano_core_crates","mod_mgmt","namespacedir","strongcrateref","Acquires the lock on this `CrateNamespace`'s crate list…","appcrateref","Finds the corresponding `LoadedSection` reference for the…","weaksectionref","cratetype","loadedsectioninner","default_namespace_name","Returns the string suffix for use as the name of the crate…","from_module_name","Returns a tuple of (CrateType, &str, &str) based on the…","is_application","Returns `true` if the given `module_name` indicates an…","is_kernel","is_userspace","get_function_section","Returns the `LoadedSection` of type `SectionType::Text`…","data_sections_iter","A convenience function to iterate over only the data…","global_sections_iter","A convenience function to iterate over only the global…","find_section","Returns the first `LoadedSection` that matches the given…","crate_name_without_hash","Returns the substring of this crate's name that excludes…","crate_name_as_prefix","Returns this crate name as a symbol prefix, including a…","crates_dependent_on_me","Currently may contain duplicates!","crates_i_depend_on","Returns the set of crates that this crate depends on. Only…","loadedcrate","is_data_or_bss","Returns `true` if `Data` or `Bss`, otherwise `false`.","Create a new `LoadedSection`, with an empty `dependencies`…","with_dependencies","Same as [new()`](#method.new), but uses the given…","cowweak","Returns the starting `VirtualAddress` of where this…","Returns the size in bytes of this section.","Returns the type of this section.","name_without_hash","Returns the substring of this section's name that excludes…","section_name_without_hash","Returns the substring of the given section's name that…","find_weak_dependent","Returns the index of the first `WeakDependent` object in…","copy_section_data_to","Copies the actual data contents of this `LoadedSection` to…","from_elf_relocation","Returns true if the relocation type results in a…","IntoCrateObjectFile","NamespaceDir","CrateNamespace","AppCrateRef","exceptionstackframe","taskref","killhandler","exitvalue","set_kill_handler","Registers a function or closure that will be called if…","take_kill_handler","Takes ownership of this `Task`'s `KillHandler`…","take_exit_value","Takes ownership of this `Task`'s exit value and returns…","panicinfoowned","PanicInfoOwned","RestartInfo","KillReason","ExitValue","endianslice","nativeendian","debug_info","debugsections","DebugSymbols","DebugSections","invalidswaprequest","swaprequest","InvalidSwapRequest","SwapRequest","faultentry","faulttype","recoveryaction","FaultEntry","FaultType","RecoveryAction","panicinfo","dfqueueproducer","The main printing macro, which simply pushes an output…","Creates a new directory and passes a pointer to the new…","Returns a string listing all the children in the directory","The name of the directory","sampleresults","performancecounters","pmuresults","eventtype","pmu_x86::stat","SampleResults","EventType","PerformanceCounters","PMUResults","prioritytaskref","PriorityTaskRef","Obtains the lock on the underlying `Task` in a read-only,…","mutexirqsafeguardref","A cloneable reference to a `Taskref` that exposes more…","RunQueue","increment_context_switches","Increment the number of times the task is picked","Creates a new `RunQueue` for the given core, which is an…","get_runqueue","get_least_busy_core","Returns the \"least busy\" core, which is currently very…","add_task_to_any_runqueue","Chooses the \"least busy\" core's runqueue (based on simple…","add_task_to_specific_runqueue","Convenience method that adds the given `Task` reference to…","remove_task","Removes a `TaskRef` from this RunQueue.","remove_task_from_all","Removes a `TaskRef` from all `RunQueue`s that exist on the…","vecdeque","roundrobintaskref","RoundRobinTaskRef","RUNQUEUES","swapranges","SwapRanges","set_priority","get_priority","select_next_task","Changes the priority of the given task with the given…","Create a new empty WaitQueue.","waitqueue","waiterror","WaitError","WaitGuard","WaitQueue","lockedidt","handlerfunc","The lower (least significant) 32 bits of the physical…","The higher (most significant) 32 bits of the physical…","mutexirqsafe","e1000::test_e1000_driver","E1000Registers","RegistersRx","RegistersTx","arp_packet","send_packet","get_received_frame","poll_receive","mac_address","registers","namespace","StackFrame","StackFrameIter","UnwindingContext","satisfiedwaitcondition","WaitCondition","SatisfiedWaitCondition","notify_one","notify_specific","new_channel","try_receive","channelerror","is_disconnected","Returns true if the channel is disconnected.","channelstatus","ChannelStatus","ChannelError","The sender (transmit) side of a channel.","The receiver side of a channel.","try_send","mutexsleepguard","mutexsleep","MutexSleep","MutexSleepGuard","ethernetaddress","NetworkInterface","NETWORK_INTERFACES","killreason","StringSender","StringReceiver","networkinterfaceref","socketset","ipaddress","ethernetnetworkinterface","capabilities","EthernetNetworkInterface","EthernetDevice","ethernet_addr","set_ethernet_addr","has_ip_addr","routes_mut","stack_trace","memorymanagementinfo","bootstraptaskref","taskbuilder","TaskBuilder","BootstrapTaskRef","panic_wrapper","divide_by_zero_handler","exception 0x00","breakpoint_handler","exception 0x03","invalid_opcode_handler","exception 0x06","device_not_available_handler","exception 0x07 see this:…","double_fault_handler","segment_not_present_handler","general_protection_fault_handler","pagefaulterrorcode","httpresponse","connectedtcpsocket","HttpResponse","ConnectedTcpSocket","sockethandle","ipendpoint","Connects to the update server over the given network…","DownloadedFile","physical_address","GraphicInfo","framebuffer","composite_buffer","framebuffer::pixel","weight_blend","AlphaPixel","Framebuffer","Displayable","FramebufferUpdates","Compositor","CompositableRegion","alphapixel","get_size","get_pixel","WindowInner","WindowMovingStatus","overlaps_with","composite","CacheBlock","FRAME_COMPOSITOR","FrameCompositor","textdisplay","TextDisplay","WindowManager","windowinner","Returns an immutable reference to this window's virtual…","framebuffer_mut","Returns a mutable reference to this window's virtual…","is_active","offset_from_end","underlying_char","libterm::cursor","ScrollError"];
searchIndex["___Theseus_Crates___"]={"doc":"Overview of Theseus","i":[],"p":[]};
searchIndex["acpi"]={"doc":"Code to parse the ACPI tables, based off of Redox. ","i":[[5,"get_acpi_tables","acpi","Returns a reference to the singleton instance of all ACPI…",N,[[],["mutex"]]],[5,"init",E,"Parses the system's ACPI tables ",N,[[[R[170]]],[[R[1],["str"]],["str"]]]]],"p":[]};
searchIndex["acpi_table"]={"doc":"Definitions for the ACPI table","i":[[3,R[302],"acpi_table","A record that tracks where an ACPI Table exists in memory,…",N,N],[12,"offset",E,"The offset of the statically-sized part of the table,…",0,N],[12,"slice_offset_and_length",E,"The offset and length of the dynamically-sized part of the…",0,N],[3,R[303],E,"The struct holding all ACPI tables and records of where…",N,N],[6,"AcpiSignature",E,"All ACPI tables are identified by a 4-byte signature,…",N,N],[11,"map_new_table",E,"Map the ACPI table that exists at the given…",1,[[[R[82]],["self"],[R[170]]],[[R[1],["str"]],["str"]]]],[11,"add_table_location",E,"Add the location and size details of a discovered ACPI…",1,[[[R[300]],[R[82]],["self"],[R[31]]],[[R[1],["str"]],["str"]]]],[11,"table_location",E,"Returns the location of the ACPI table based on the given…",1,[[["self"],[R[300]]],[[R[301]],[R[31],[R[301]]]]]],[11,"table",E,"Returns a reference to the table that matches the…",1,[[["self"],[R[300]]],[[T],[R[1],["str"]],["str"]]]],[11,"table_mut",E,"Returns a mutable reference to the table that matches the…",1,[[["self"],[R[300]]],[["str"],[R[1],["str"]],[T]]]],[11,"table_slice",E,"Returns a reference to the dynamically-sized part at the…",1,[[["self"],[R[300]]],[[R[1],["str"]],["str"]]]],[11,"table_slice_mut",E,"Returns a mutable reference to the dynamically-sized part…",1,[[["self"],[R[300]]],[[R[1],["str"]],["str"]]]],[11,"mapping",E,"Returns an immutable reference to the underlying…",1,[[["self"]],[R[168]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[6],E,E,1,[[[U]],[R[1]]]],[11,"into",E,E,1,[[],[U]]],[11,R[7],E,E,1,[[],[R[1]]]],[11,R[8],E,E,1,[[["self"]],[T]]],[11,R[9],E,E,1,[[["self"]],[T]]],[11,R[11],E,E,1,[[["self"]],[R[14]]]],[11,"fmt",E,E,0,[[[R[12]],["self"]],[R[1]]]],[11,R[38],E,E,1,[[],[R[363]]]]],"p":[[3,R[302]],[3,R[303]]]};
searchIndex["acpi_table_handler"]={"doc":"Handles ACPI tables based on signatures.","i":[[5,R[396],R[396],"The single arbiter of ACPI Table types, which contains a…",N,[[[R[300]],["usize"],[R[82]],[R[363]]],[[R[1],["str"]],["str"]]]]],"p":[]};
searchIndex["ap_start"]={"doc":E,"i":[[5,"kstart_ap","ap_start","Entry to rust for an AP. The arguments must match the…",N,[[[R[81]],["u16"],["u8"]]]],[7,"AP_READY_FLAG",E,"An atomic flag used for synchronizing progress between the…",N,N]],"p":[]};
searchIndex["apic"]={"doc":E,"i":[[3,R[308],"apic","A structure that offers access to APIC/xAPIC through its…",N,N],[12,"lapic_id",E,"This Lapic's ID. Some systems allow setting the ID, but it…",0,N],[12,"lapic_version",E,E,0,N],[12,"task_priority",E,E,0,N],[12,"arbitration_priority",E,E,0,N],[12,"processor_priority",E,E,0,N],[12,"eoi",E,E,0,N],[12,"remote_read",E,E,0,N],[12,"logical_destination",E,E,0,N],[12,"destination_format",E,E,0,N],[12,"spurious_interrupt_vector",E,E,0,N],[12,"in_service_registers",E,E,0,N],[12,"trigger_mode_registers",E,E,0,N],[12,"interrupt_request_registers",E,E,0,N],[12,"error_status",E,E,0,N],[12,"lvt_cmci",E,E,0,N],[12,"interrupt_command_low",E,E,0,N],[12,"interrupt_command_high",E,E,0,N],[12,"lvt_timer",E,E,0,N],[12,"lvt_thermal",E,E,0,N],[12,"lvt_perf_monitor",E,E,0,N],[12,"lvt_lint0",E,E,0,N],[12,"lvt_lint1",E,E,0,N],[12,"lvt_error",E,E,0,N],[12,"timer_initial_count",E,E,0,N],[12,"timer_current_count",E,E,0,N],[12,"timer_divide",E,E,0,N],[3,R[312],E,E,N,N],[3,R[309],E,"This structure represents a single APIC in the system,…",N,N],[12,"regs",E,"Only exists for xapic, should be None for x2apic systems.",1,N],[12,R[379],E,"The processor id of this APIC.",1,N],[12,"apic_id",E,"The APIC system id of this APIC.",1,N],[12,"is_bsp",E,"Whether this `LocalApic` is the bootstrap processor (the…",1,N],[4,R[310],E,E,N,N],[13,"APIC",E,E,2,N],[13,"X2APIC",E,E,2,N],[13,"PIC",E,E,2,N],[4,R[311],E,"The possible destination shorthand values for IPI ICR.",N,N],[13,"One",E,"Send IPI to a specific APIC ",3,N],[13,"Me",E,"Send IPI to my own (the current) APIC  ",3,N],[13,"All",E,"Send IPI to all APICs, including myself",3,N],[13,"AllButMe",E,"Send IPI to all APICs except for myself",3,N],[5,"get_bsp_id",E,E,N,[[],[[R[31],["u8"]],["u8"]]]],[5,"is_bsp",E,"Returns true if the currently executing processor core is…",N,[[],["bool"]]],[5,"has_x2apic",E,"Returns true if the machine has support for x2apic",N,[[],["bool"]]],[5,"get_lapics",E,"Returns a reference to the list of LocalApics, one per…",N,[[],[R[313]]]],[5,"core_count",E,"Returns the number of processor core (local APICs) that…",N,[[],["usize"]]],[5,"get_my_apic_id",E,"Returns the APIC ID of the currently executing processor…",N,[[],["u8"]]],[5,"get_my_apic",E,"Returns a reference to the LocalApic for the currently…",N,[[],[[R[304]],[R[31],[R[304]]]]]],[5,"init",E,"Initially maps the base APIC MMIO register frames so that…",N,[[[R[170]]],[[R[1],["str"]],["str"]]]],[7,"INTERRUPT_CHIP",E,"The interrupt chip that is currently configured on this…",N,N],[17,"APIC_SPURIOUS_INTERRUPT_VECTOR",E,E,N,N],[11,"as_icr_value",E,"Convert the enum to a bitmask value to be used in the…",3,[[["self"]],["u64"]]],[11,"new",E,"This MUST be invoked from the AP core itself when it is…",1,[[["u8"],["u16"],[R[170]],["bool"]],[[R[305]],["str"],[R[1],[R[305],"str"]]]]],[11,"id",E,E,1,[[["self"]],["u8"]]],[11,"version",E,E,1,[[["self"]],["u32"]]],[11,"error",E,E,1,[[["self"]],["u32"]]],[11,"clear_error",E,E,1,[[["self"]]]],[11,"icr",E,E,1,[[["self"]],["u64"]]],[11,"set_icr",E,E,1,[[["self"],["u64"]]]],[11,"send_ipi",E,"Send an IPI to the cores specified by the given destination",1,[[[R[306]],["self"],["u8"]]]],[11,"send_nmi_ipi",E,"Send a NMI IPI to the cores specified by the given…",1,[[["self"],[R[306]]]]],[11,"eoi",E,E,1,[[["self"]]]],[11,"set_ldr",E,E,1,[[["self"],["u32"]]]],[11,"set_nmi",E,"Set the NonMaskableInterrupt redirect for this LocalApic.…",1,[[["u16"],["self"],["u8"]],[[R[1],["str"]],["str"]]]],[11,"get_isr",E,"Returns the values of the 8 in-service registers for this…",1,[[["self"]]]],[11,"get_irr",E,"Returns the values of the 8 request registers for this…",1,[[["self"]]]],[11,"clear_pmi_mask",E,"Clears the interrupt mask bit in the apic performance…",1,[[["self"]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,"from",E,E,4,[[[T]],[T]]],[11,R[6],E,E,4,[[[U]],[R[1]]]],[11,"into",E,E,4,[[],[U]]],[11,R[7],E,E,4,[[],[R[1]]]],[11,R[8],E,E,4,[[["self"]],[T]]],[11,R[9],E,E,4,[[["self"]],[T]]],[11,R[11],E,E,4,[[["self"]],[R[14]]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[6],E,E,1,[[[U]],[R[1]]]],[11,"into",E,E,1,[[],[U]]],[11,R[7],E,E,1,[[],[R[1]]]],[11,R[8],E,E,1,[[["self"]],[T]]],[11,R[9],E,E,1,[[["self"]],[T]]],[11,R[11],E,E,1,[[["self"]],[R[14]]]],[11,"from",E,E,2,[[[T]],[T]]],[11,R[6],E,E,2,[[[U]],[R[1]]]],[11,"into",E,E,2,[[],[U]]],[11,R[7],E,E,2,[[],[R[1]]]],[11,R[8],E,E,2,[[["self"]],[T]]],[11,R[9],E,E,2,[[["self"]],[T]]],[11,R[11],E,E,2,[[["self"]],[R[14]]]],[11,R[64],E,E,2,[[["self"]],[T]]],[11,R[65],E,E,2,[[["self"],[T]]]],[11,"from",E,E,3,[[[T]],[T]]],[11,R[6],E,E,3,[[[U]],[R[1]]]],[11,"into",E,E,3,[[],[U]]],[11,R[7],E,E,3,[[],[R[1]]]],[11,R[8],E,E,3,[[["self"]],[T]]],[11,R[9],E,E,3,[[["self"]],[T]]],[11,R[11],E,E,3,[[["self"]],[R[14]]]],[11,"fmt",E,E,2,[[[R[12]],["self"]],[R[1]]]],[11,"fmt",E,E,1,[[["self"],[R[12]]],[R[1]]]],[11,"eq",E,E,2,[[[R[307]],["self"]],["bool"]]],[11,"clone",E,E,2,[[["self"]],[R[307]]]]],"p":[[3,R[308]],[3,R[309]],[4,R[310]],[4,R[311]],[3,R[312]]]};
searchIndex["async_channel"]={"doc":"An asynchronous channel for Inter-Task Communication (ITC)…","i":[[3,"Sender","async_channel",R[710],N,N],[3,R[54],E,R[711],N,N],[4,R[708],E,"Indicates whether channel is Connected or Disconnected",N,N],[13,"Connected",E,"Channel is working. Initially channel is created with…",0,N],[13,"SenderDisconnected",E,"Set to Disconnected when Sender end is dropped.",0,N],[13,"ReceiverDisconnected",E,"Set to Disconnected when Receiver end is dropped.",0,N],[4,R[709],E,"Error type for tracking different type of errors sender…",N,N],[13,"ChannelEmpty",E,"Occurs when `try_receive` is performed on an empty channel",1,N],[13,"ChannelFull",E,"Occurs when `try_send` is performed on a full channel",1,N],[13,"ChannelDisconnected",E,"Occurs when one end of channel is dropped",1,N],[13,R[675],E,"Occurs when an error occur in `WaitQueue`",1,N],[5,R[702],E,"Create a new channel that allows senders and receivers to…",N,[[["usize"]]]],[11,"send",E,"Send a message, blocking until space in the channel's…",2,[[["self"],[T]],[[R[704]],[R[1],[R[704]]]]]],[11,R[712],E,"Tries to send the message, only succeeding if buffer space…",2,[[["self"],[T]],[R[1]]]],[11,R[705],E,R[706],2,[[["self"]],["bool"]]],[11,"receive",E,"Receive a message, blocking until a message is available…",3,[[["self"]],[[R[704]],[R[1],[R[704]]]]]],[11,R[703],E,"Tries to receive a message, only succeeding if a message…",3,[[["self"]],[[R[704]],[R[1],[R[704]]]]]],[11,R[705],E,R[706],3,[[["self"]],["bool"]]],[11,"from",E,E,2,[[[T]],[T]]],[11,R[6],E,E,2,[[[U]],[R[1]]]],[11,"into",E,E,2,[[],[U]]],[11,R[7],E,E,2,[[],[R[1]]]],[11,R[8],E,E,2,[[["self"]],[T]]],[11,R[9],E,E,2,[[["self"]],[T]]],[11,R[11],E,E,2,[[["self"]],[R[14]]]],[11,R[64],E,E,2,[[["self"]],[T]]],[11,R[65],E,E,2,[[["self"],[T]]]],[11,"from",E,E,3,[[[T]],[T]]],[11,R[6],E,E,3,[[[U]],[R[1]]]],[11,"into",E,E,3,[[],[U]]],[11,R[7],E,E,3,[[],[R[1]]]],[11,R[8],E,E,3,[[["self"]],[T]]],[11,R[9],E,E,3,[[["self"]],[T]]],[11,R[11],E,E,3,[[["self"]],[R[14]]]],[11,R[64],E,E,3,[[["self"]],[T]]],[11,R[65],E,E,3,[[["self"],[T]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,R[64],E,E,0,[[["self"]],[T]]],[11,R[65],E,E,0,[[["self"],[T]]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[6],E,E,1,[[[U]],[R[1]]]],[11,"into",E,E,1,[[],[U]]],[11,R[7],E,E,1,[[],[R[1]]]],[11,R[8],E,E,1,[[["self"]],[T]]],[11,R[9],E,E,1,[[["self"]],[T]]],[11,R[11],E,E,1,[[["self"]],[R[14]]]],[11,"fmt",E,E,0,[[[R[12]],["self"]],[R[1]]]],[11,"fmt",E,E,1,[[[R[12]],["self"]],[R[1]]]],[11,"eq",E,E,0,[[["self"],[R[707]]],["bool"]]],[11,"eq",E,E,1,[[[R[704]],["self"]],["bool"]]],[11,"ne",E,E,1,[[[R[704]],["self"]],["bool"]]],[11,"drop",E,E,3,[[["self"]]]],[11,"drop",E,E,2,[[["self"]]]],[11,"clone",E,E,0,[[["self"]],[R[707]]]],[11,"clone",E,E,2,[[["self"]],["sender"]]],[11,"clone",E,E,3,[[["self"]],["receiver"]]]],"p":[[4,R[708]],[4,R[709]],[3,"Sender"],[3,R[54]]]};
searchIndex["ata"]={"doc":"Support for accessing ATA drives (IDE).","i":[[3,"AtaError","ata","The possible error values found in an ATA drive's error…",N,N],[3,R[411],E,"The possible status values found in an ATA drive's status…",N,N],[3,"AtaDrive",E,"A single ATA drive, either a master or a slave, which sits…",N,N],[3,R[408],E,"A single IDE controller has two buses with up to two…",N,N],[12,"primary_master",E,E,0,N],[12,"primary_slave",E,E,0,N],[12,"secondary_master",E,E,0,N],[12,"secondary_slave",E,E,0,N],[3,R[412],E,"Provides an iterator over all `AtaDrive`s in an…",N,N],[3,R[409],E,"Information that describes an ATA drive, obtained from the…",N,N],[12,R[416],E,E,1,N],[12,"num_cylinders",E,E,1,N],[12,"specific_configuration",E,E,1,N],[12,"num_heads",E,E,1,N],[12,"num_sectors_per_track",E,E,1,N],[12,"vendor_unique1",E,E,1,N],[12,"serial_number",E,E,1,N],[12,"firmware_version",E,E,1,N],[12,"model_number",E,E,1,N],[12,"max_blocks_per_transfer",E,"Maximum number of blocks per transfer. Sometimes referred…",1,N],[12,"vendor_unique2",E,E,1,N],[12,"trusted_computing",E,E,1,N],[12,R[727],E,E,1,N],[12,"translation_fields_valid",E,"A bitmask of translation fields valid and free fall…",1,N],[12,"free_fall_control_sensitivity",E,E,1,N],[12,"num_current_cylinders",E,E,1,N],[12,"num_current_heads",E,E,1,N],[12,"current_sectors_per_track",E,E,1,N],[12,"current_sector_capacity",E,E,1,N],[12,"current_multi_sector_setting",E,E,1,N],[12,"ext_command_supported",E,"MultiSectorSettingValid : 1; ReservedByte59 : 3;…",1,N],[12,"user_addressable_sectors",E,"Number of sectors in the drive, if using 28-bit LBA. This…",1,N],[12,"multiword_dma_support",E,E,1,N],[12,"multiword_dma_active",E,E,1,N],[12,"advanced_pio_modes",E,E,1,N],[12,"minimum_mw_transfer_cycle_time",E,E,1,N],[12,"recommended_mw_transfer_cycle_time",E,E,1,N],[12,"minimum_pio_cycle_time",E,E,1,N],[12,"minimum_pio_cycle_time_io_ready",E,E,1,N],[12,"additional_supported",E,E,1,N],[12,"queue_depth",E,"only the first 5 bits are used, others are reserved",1,N],[12,"serial_ata_capabilities",E,E,1,N],[12,"serial_ata_features_supported",E,E,1,N],[12,"serial_ata_features_enabled",E,E,1,N],[12,"major_revision",E,E,1,N],[12,"minor_revision",E,E,1,N],[12,"command_set_support",E,E,1,N],[12,"command_set_active",E,E,1,N],[12,"ultra_dma_support",E,E,1,N],[12,"ultra_dma_active",E,E,1,N],[12,"normal_security_erase_unit",E,E,1,N],[12,"enhanced_security_erase_unit",E,E,1,N],[12,"current_apm_level",E,E,1,N],[12,"master_password_id",E,E,1,N],[12,"hardware_reset_result",E,E,1,N],[12,"current_acoustic_value",E,E,1,N],[12,"recommended_acoustic_value",E,E,1,N],[12,"stream_min_request_size",E,E,1,N],[12,"streaming_transfer_time_dma",E,E,1,N],[12,"streaming_access_latency_dma_pio",E,E,1,N],[12,"streaming_perf_granularity",E,E,1,N],[12,"max_48_bit_lba",E,"Number of sectors in the drive, if using 48-bit LBA. This…",1,N],[12,"streaming_transfer_time",E,E,1,N],[12,"dsm_cap",E,E,1,N],[12,"physical_logical_sector_size",E,"`[0:3]` Physical sector size (in logical sectors)",1,N],[12,"inter_seek_delay",E,E,1,N],[12,"world_wide_name",E,E,1,N],[12,"reserved_for_world_wide_name_128",E,E,1,N],[12,"reserved_for_tlc_technical_report",E,E,1,N],[12,"words_per_logical_sector",E,E,1,N],[12,"command_set_support_ext",E,E,1,N],[12,"command_set_active_ext",E,E,1,N],[12,"reserved_for_expanded_support_and_active",E,E,1,N],[12,"msn_support",E,E,1,N],[12,"security_status",E,E,1,N],[12,"cfa_power_mode1",E,E,1,N],[12,"nominal_form_factor",E,E,1,N],[12,"data_set_management_feature",E,E,1,N],[12,"additional_product_id",E,E,1,N],[12,"current_media_serial_number",E,E,1,N],[12,"sct_command_transport",E,E,1,N],[12,"block_alignment",E,E,1,N],[12,"write_read_verify_sector_count_mode_3_only",E,E,1,N],[12,"write_read_verify_sector_count_mode_2_only",E,E,1,N],[12,"nv_cache_capabilities",E,E,1,N],[12,"nv_cache_size_lsw",E,E,1,N],[12,"nv_cache_size_msw",E,E,1,N],[12,"nominal_media_rotation_rate",E,E,1,N],[12,"nv_cache_time_to_spin_up_in_seconds",E,E,1,N],[12,"write_read_verify_sector_count_mode",E,E,1,N],[12,"transport_major_version",E,E,1,N],[12,"transport_minor_version",E,E,1,N],[12,"extended_num_of_user_addressable_sectors",E,E,1,N],[12,"min_blocks_per_download_microcode",E,E,1,N],[12,"max_blocks_per_download_microcode",E,E,1,N],[12,R[417],E,E,1,N],[12,R[418],E,E,1,N],[3,R[413],E,"An ATA drive's serial number is a 20-byte string.",N,N],[3,R[414],E,"An ATA drive's model number is a 40-byte string.",N,N],[3,R[415],E,"An ATA drive's firmware version is an 8-byte string.",N,N],[4,R[410],E,"The possible types of drive devices that can be attached…",N,N],[13,"Pata",E,"A parallel ATA (PATA) drive, like a hard drive. This is…",2,N],[13,"PataPi",E,"A parallel ATA (PATA) drive that uses the packet…",2,N],[13,"Sata",E,"A serial ATA (SATA) drive that is operating in legacy IDE…",2,N],[13,"SataPi",E,"A serial ATA (SATA) drive that that is operating in legacy…",2,N],[6,"AtaDriveRef",E,E,N,N],[18,"BAD_BLOCK",E,E,3,N],[18,"UNCORRECTABLE_DATA",E,E,3,N],[18,"MEDIA_CHANGED",E,E,3,N],[18,"ID_MARK_NOT_FOUND",E,E,3,N],[18,"MEDIA_CHANGE_REQUEST",E,E,3,N],[18,"COMMAND_ABORTED",E,E,3,N],[18,"TRACK_0_NOT_FOUND",E,E,3,N],[18,"ADDRESS_MARK_NOT_FOUND",E,E,3,N],[11,"empty",E,R[149],3,[[],[R[402]]]],[11,"all",E,R[150],3,[[],[R[402]]]],[11,"bits",E,R[151],3,[[["self"]],["u8"]]],[11,R[152],E,R[153],3,[[["u8"]],[[R[31],[R[402]]],[R[402]]]]],[11,R[154],E,R[155],3,[[["u8"]],[R[402]]]],[11,R[47],E,R[156],3,[[["self"]],["bool"]]],[11,"is_all",E,R[157],3,[[["self"]],["bool"]]],[11,R[158],E,R[159],3,[[[R[402]],["self"]],["bool"]]],[11,R[249],E,R[160],3,[[[R[402]],["self"]],["bool"]]],[11,"insert",E,R[161],3,[[["self"],[R[402]]]]],[11,"remove",E,R[162],3,[[["self"],[R[402]]]]],[11,"toggle",E,R[163],3,[[["self"],[R[402]]]]],[11,"set",E,R[164],3,[[["self"],[R[402]],["bool"]]]],[18,"BUSY",E,"When set, the drive's port values are still changing, so…",4,N],[18,"DRIVE_READY",E,"When set, the drive is on. When cleared, the drive is…",4,N],[18,"DRIVE_WRITE_FAULT",E,E,4,N],[18,"DRIVE_SEEK_COMPLETE",E,E,4,N],[18,"DATA_REQUEST_READY",E,"When cleared, the drive is ready for data to be…",4,N],[18,"CORRECTED_DATA",E,E,4,N],[18,"INDEX",E,E,4,N],[18,"ERROR",E,E,4,N],[11,"empty",E,R[149],4,[[],[R[403]]]],[11,"all",E,R[150],4,[[],[R[403]]]],[11,"bits",E,R[151],4,[[["self"]],["u8"]]],[11,R[152],E,R[153],4,[[["u8"]],[[R[31],[R[403]]],[R[403]]]]],[11,R[154],E,R[155],4,[[["u8"]],[R[403]]]],[11,R[47],E,R[156],4,[[["self"]],["bool"]]],[11,"is_all",E,R[157],4,[[["self"]],["bool"]]],[11,R[158],E,R[159],4,[[["self"],[R[403]]],["bool"]]],[11,R[249],E,R[160],4,[[["self"],[R[403]]],["bool"]]],[11,"insert",E,R[161],4,[[["self"],[R[403]]]]],[11,"remove",E,R[162],4,[[["self"],[R[403]]]]],[11,"toggle",E,R[163],4,[[["self"],[R[403]]]]],[11,"set",E,R[164],4,[[["bool"],["self"],[R[403]]]]],[11,"read_pio",E,"Reads data from this drive starting at the given…",5,[[["self"],["usize"]],[["str"],["usize"],[R[1],["usize","str"]]]]],[11,"write_pio",E,"Writes data from the provided `buffer` to this drive,…",5,[[["self"],["usize"]],[["str"],["usize"],[R[1],["usize","str"]]]]],[11,"is_master",E,"Returns `true` if this drive is the master, or `false` if…",5,[[["self"]],["bool"]]],[11,"new",E,"Creates a new instance of an IDE controller based on the…",0,[[[R[281]]],[["str"],[R[404]],[R[1],[R[404],"str"]]]]],[11,"iter",E,"Returns an `Iterator` over all of the `AtaDrive`s that…",0,[[["self"]],[R[406]]]],[11,"from",E,E,3,[[[T]],[T]]],[11,R[6],E,E,3,[[[U]],[R[1]]]],[11,"into",E,E,3,[[],[U]]],[11,R[7],E,E,3,[[],[R[1]]]],[11,R[8],E,E,3,[[["self"]],[T]]],[11,R[9],E,E,3,[[["self"]],[T]]],[11,R[11],E,E,3,[[["self"]],[R[14]]]],[11,R[64],E,E,3,[[["self"]],[T]]],[11,R[65],E,E,3,[[["self"],[T]]]],[11,R[405],E,E,3,[[["box"]],[["box",["any"]],["any"]]]],[11,"as_any",E,E,3,[[["self"]],["any"]]],[11,R[401],E,E,3,[[["self"]],["any"]]],[11,"from",E,E,4,[[[T]],[T]]],[11,R[6],E,E,4,[[[U]],[R[1]]]],[11,"into",E,E,4,[[],[U]]],[11,R[7],E,E,4,[[],[R[1]]]],[11,R[8],E,E,4,[[["self"]],[T]]],[11,R[9],E,E,4,[[["self"]],[T]]],[11,R[11],E,E,4,[[["self"]],[R[14]]]],[11,R[64],E,E,4,[[["self"]],[T]]],[11,R[65],E,E,4,[[["self"],[T]]]],[11,R[405],E,E,4,[[["box"]],[["box",["any"]],["any"]]]],[11,"as_any",E,E,4,[[["self"]],["any"]]],[11,R[401],E,E,4,[[["self"]],["any"]]],[11,"from",E,E,5,[[[T]],[T]]],[11,R[6],E,E,5,[[[U]],[R[1]]]],[11,"into",E,E,5,[[],[U]]],[11,R[7],E,E,5,[[],[R[1]]]],[11,R[8],E,E,5,[[["self"]],[T]]],[11,R[9],E,E,5,[[["self"]],[T]]],[11,R[11],E,E,5,[[["self"]],[R[14]]]],[11,R[405],E,E,5,[[["box"]],[["box",["any"]],["any"]]]],[11,"as_any",E,E,5,[[["self"]],["any"]]],[11,R[401],E,E,5,[[["self"]],["any"]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,R[405],E,E,0,[[["box"]],[["box",["any"]],["any"]]]],[11,"as_any",E,E,0,[[["self"]],["any"]]],[11,R[401],E,E,0,[[["self"]],["any"]]],[11,"from",E,E,6,[[[T]],[T]]],[11,R[6],E,E,6,[[[U]],[R[1]]]],[11,R[91],E,E,6,[[],["i"]]],[11,"into",E,E,6,[[],[U]]],[11,R[7],E,E,6,[[],[R[1]]]],[11,R[8],E,E,6,[[["self"]],[T]]],[11,R[9],E,E,6,[[["self"]],[T]]],[11,R[11],E,E,6,[[["self"]],[R[14]]]],[11,R[64],E,E,6,[[["self"]],[T]]],[11,R[65],E,E,6,[[["self"],[T]]]],[11,R[405],E,E,6,[[["box"]],[["box",["any"]],["any"]]]],[11,"as_any",E,E,6,[[["self"]],["any"]]],[11,R[401],E,E,6,[[["self"]],["any"]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[6],E,E,1,[[[U]],[R[1]]]],[11,"into",E,E,1,[[],[U]]],[11,R[7],E,E,1,[[],[R[1]]]],[11,R[8],E,E,1,[[["self"]],[T]]],[11,R[9],E,E,1,[[["self"]],[T]]],[11,R[11],E,E,1,[[["self"]],[R[14]]]],[11,R[64],E,E,1,[[["self"]],[T]]],[11,R[65],E,E,1,[[["self"],[T]]]],[11,R[405],E,E,1,[[["box"]],[["box",["any"]],["any"]]]],[11,"as_any",E,E,1,[[["self"]],["any"]]],[11,R[401],E,E,1,[[["self"]],["any"]]],[11,"from",E,E,7,[[[T]],[T]]],[11,R[6],E,E,7,[[[U]],[R[1]]]],[11,"into",E,E,7,[[],[U]]],[11,R[7],E,E,7,[[],[R[1]]]],[11,R[8],E,E,7,[[["self"]],[T]]],[11,R[9],E,E,7,[[["self"]],[T]]],[11,R[11],E,E,7,[[["self"]],[R[14]]]],[11,R[64],E,E,7,[[["self"]],[T]]],[11,R[65],E,E,7,[[["self"],[T]]]],[11,R[176],E,E,7,[[["self"]],["string"]]],[11,R[405],E,E,7,[[["box"]],[["box",["any"]],["any"]]]],[11,"as_any",E,E,7,[[["self"]],["any"]]],[11,R[401],E,E,7,[[["self"]],["any"]]],[11,"from",E,E,8,[[[T]],[T]]],[11,R[6],E,E,8,[[[U]],[R[1]]]],[11,"into",E,E,8,[[],[U]]],[11,R[7],E,E,8,[[],[R[1]]]],[11,R[8],E,E,8,[[["self"]],[T]]],[11,R[9],E,E,8,[[["self"]],[T]]],[11,R[11],E,E,8,[[["self"]],[R[14]]]],[11,R[64],E,E,8,[[["self"]],[T]]],[11,R[65],E,E,8,[[["self"],[T]]]],[11,R[176],E,E,8,[[["self"]],["string"]]],[11,R[405],E,E,8,[[["box"]],[["box",["any"]],["any"]]]],[11,"as_any",E,E,8,[[["self"]],["any"]]],[11,R[401],E,E,8,[[["self"]],["any"]]],[11,"from",E,E,9,[[[T]],[T]]],[11,R[6],E,E,9,[[[U]],[R[1]]]],[11,"into",E,E,9,[[],[U]]],[11,R[7],E,E,9,[[],[R[1]]]],[11,R[8],E,E,9,[[["self"]],[T]]],[11,R[9],E,E,9,[[["self"]],[T]]],[11,R[11],E,E,9,[[["self"]],[R[14]]]],[11,R[64],E,E,9,[[["self"]],[T]]],[11,R[65],E,E,9,[[["self"],[T]]]],[11,R[176],E,E,9,[[["self"]],["string"]]],[11,R[405],E,E,9,[[["box"]],[["box",["any"]],["any"]]]],[11,"as_any",E,E,9,[[["self"]],["any"]]],[11,R[401],E,E,9,[[["self"]],["any"]]],[11,"from",E,E,2,[[[T]],[T]]],[11,R[6],E,E,2,[[[U]],[R[1]]]],[11,"into",E,E,2,[[],[U]]],[11,R[7],E,E,2,[[],[R[1]]]],[11,R[8],E,E,2,[[["self"]],[T]]],[11,R[9],E,E,2,[[["self"]],[T]]],[11,R[11],E,E,2,[[["self"]],[R[14]]]],[11,R[405],E,E,2,[[["box"]],[["box",["any"]],["any"]]]],[11,"as_any",E,E,2,[[["self"]],["any"]]],[11,R[401],E,E,2,[[["self"]],["any"]]],[11,"fmt",E,E,7,[[["self"],[R[12]]],[R[1]]]],[11,"fmt",E,E,8,[[["self"],[R[12]]],[R[1]]]],[11,"fmt",E,E,9,[[["self"],[R[12]]],[R[1]]]],[11,"fmt",E,E,3,[[["self"],[R[12]]],[R[1]]]],[11,"fmt",E,E,4,[[["self"],[R[12]]],[R[1]]]],[11,"fmt",E,E,5,[[[R[12]],["self"]],[R[1]]]],[11,"fmt",E,E,0,[[[R[12]],["self"]],[R[1]]]],[11,"fmt",E,E,1,[[[R[12]],["self"]],[R[1]]]],[11,"fmt",E,E,7,[[["self"],[R[12]]],[R[1]]]],[11,"fmt",E,E,8,[[["self"],[R[12]]],[R[1]]]],[11,"fmt",E,E,9,[[["self"],[R[12]]],[R[1]]]],[11,"sub",E,R[118],3,[[[R[402]]],[R[402]]]],[11,"sub",E,R[118],4,[[[R[403]]],[R[403]]]],[11,"eq",E,E,3,[[[R[402]],["self"]],["bool"]]],[11,"ne",E,E,3,[[[R[402]],["self"]],["bool"]]],[11,"eq",E,E,4,[[[R[403]],["self"]],["bool"]]],[11,"ne",E,E,4,[[[R[403]],["self"]],["bool"]]],[11,"cmp",E,E,3,[[[R[402]],["self"]],[R[16]]]],[11,"cmp",E,E,4,[[[R[403]],["self"]],[R[16]]]],[11,R[61],E,E,3,[[[R[402]],["self"]],[[R[16]],[R[31],[R[16]]]]]],[11,"lt",E,E,3,[[[R[402]],["self"]],["bool"]]],[11,"le",E,E,3,[[[R[402]],["self"]],["bool"]]],[11,"gt",E,E,3,[[[R[402]],["self"]],["bool"]]],[11,"ge",E,E,3,[[[R[402]],["self"]],["bool"]]],[11,R[61],E,E,4,[[[R[403]],["self"]],[[R[16]],[R[31],[R[16]]]]]],[11,"lt",E,E,4,[[[R[403]],["self"]],["bool"]]],[11,"le",E,E,4,[[[R[403]],["self"]],["bool"]]],[11,"gt",E,E,4,[[[R[403]],["self"]],["bool"]]],[11,"ge",E,E,4,[[[R[403]],["self"]],["bool"]]],[11,R[93],E,R[117],3,[[["self"],[R[402]]]]],[11,R[93],E,R[117],4,[[["self"],[R[403]]]]],[11,"not",E,R[120],3,[[],[R[402]]]],[11,"not",E,R[120],4,[[],[R[403]]]],[11,"bitand",E,R[116],3,[[[R[402]]],[R[402]]]],[11,"bitand",E,R[116],4,[[[R[403]]],[R[403]]]],[11,"bitor",E,R[114],3,[[[R[402]]],[R[402]]]],[11,"bitor",E,R[114],4,[[[R[403]]],[R[403]]]],[11,"bitxor",E,R[123],3,[[[R[402]]],[R[402]]]],[11,"bitxor",E,R[123],4,[[[R[403]]],[R[403]]]],[11,R[95],E,R[115],3,[[["self"],[R[402]]]]],[11,R[95],E,R[115],4,[[["self"],[R[403]]]]],[11,R[96],E,R[119],3,[[["self"],[R[402]]]]],[11,R[96],E,R[119],4,[[["self"],[R[403]]]]],[11,R[97],E,R[122],3,[[["self"],[R[402]]]]],[11,R[97],E,R[122],4,[[["self"],[R[403]]]]],[11,"hash",E,E,3,[[["self"],["__h"]]]],[11,"hash",E,E,4,[[["self"],["__h"]]]],[11,"next",E,E,6,[[["self"]],[R[31]]]],[11,R[121],E,E,3,[[[R[59]]],[R[402]]]],[11,R[121],E,E,4,[[[R[59]]],[R[403]]]],[11,"extend",E,E,3,[[["self"],[R[59]]]]],[11,"extend",E,E,4,[[["self"],[R[59]]]]],[11,"fmt",E,E,3,[[["self"],[R[12]]],[R[1]]]],[11,"fmt",E,E,4,[[["self"],[R[12]]],[R[1]]]],[11,"fmt",E,E,3,[[["self"],[R[12]]],[R[1]]]],[11,"fmt",E,E,4,[[["self"],[R[12]]],[R[1]]]],[11,"fmt",E,E,3,[[["self"],[R[12]]],[R[1]]]],[11,"fmt",E,E,4,[[["self"],[R[12]]],[R[1]]]],[11,"fmt",E,E,3,[[["self"],[R[12]]],[R[1]]]],[11,"fmt",E,E,4,[[["self"],[R[12]]],[R[1]]]],[11,"clone",E,E,3,[[["self"]],[R[402]]]],[11,"clone",E,E,4,[[["self"]],[R[403]]]],[11,"clone",E,E,6,[[["self"]],[R[406]]]],[11,"clone",E,E,1,[[["self"]],[R[407]]]],[11,"clone",E,E,7,[[["self"]],["ataserialnumber"]]],[11,"clone",E,E,8,[[["self"]],["atamodelnumber"]]],[11,"clone",E,E,9,[[["self"]],["atafirmwareversion"]]],[11,R[38],E,E,1,[[],[R[407]]]],[11,R[38],E,E,7,[[],["self"]]],[11,R[38],E,E,8,[[],["self"]]],[11,R[38],E,E,9,[[],["self"]]],[11,"devices",E,E,0,[[["self"]],[[R[419]],["box",[R[419]]]]]],[11,R[420],E,E,5,[[["self"],["usize"]],[["str"],["usize"],[R[1],["usize","str"]]]]],[11,R[421],E,E,5,[[["self"],["usize"]],[["str"],["usize"],[R[1],["usize","str"]]]]],[11,R[423],E,R[424],5,[[["self"]],["usize"]]],[11,R[422],E,E,5,[[["self"]],["usize"]]]],"p":[[3,R[408]],[3,R[409]],[4,R[410]],[3,"AtaError"],[3,R[411]],[3,"AtaDrive"],[3,R[412]],[3,R[413]],[3,R[414]],[3,R[415]]]};
searchIndex["block_allocator"]={"doc":E,"i":[[3,R[2],"block_allocator",E,N,N],[11,"new",E,"Creates an empty FixedSizeBlockAllocator.",0,[[],["self"]]],[11,"init",E,"Initialize the allocator with the given heap bounds.",0,[[["self"],["usize"]]]],[11,R[25],E,"Allocates a chunk of the given size with the given…",0,[[["self"],[R[0]]]]],[11,R[26],E,"Frees the given allocation. `ptr` must be a pointer…",0,[[["self"],[R[0]]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]]],"p":[[3,R[2]]]};
searchIndex["block_io"]={"doc":"Wrappers for converting block I/O operations from one…","i":[[3,"BlockIo","block_io","A wrapper around a `StorageDevice` that supports reads and…",N,N],[11,"new",E,"Creates a new `BlockIo` device ",0,[[["storagedeviceref"]],["blockio"]]],[11,"read",E,"Reads data from this block storage device and places it…",0,[[["self"],["usize"]],[["str"],["usize"],[R[1],["usize","str"]]]]],[11,"write",E,"Write data from the given `buffer` into this block storage…",0,[[["self"],["usize"]],[["str"],["usize"],[R[1],["usize","str"]]]]],[11,"flush",E,"Flushes the given block to the backing storage device. If…",0,[[["self"],[R[31],["usize"]],["usize"]],[[R[1],["str"]],["str"]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,R[405],E,E,0,[[["box"]],[["box",["any"]],["any"]]]],[11,"as_any",E,E,0,[[["self"]],["any"]]],[11,R[401],E,E,0,[[["self"]],["any"]]]],"p":[[3,"BlockIo"]]};
searchIndex["captain"]={"doc":"The main initialization routine and setup logic of the OS. ","i":[[5,"init","captain","Initialize the Captain, which is the main module that…",N,[[[R[168]],[R[682],[R[735]]],["arc",[R[682]]],["vec",[R[168]]],[R[81]]],[[R[1],["str"]],["str"]]]]],"p":[]};
searchIndex["catch_unwind"]={"doc":"Support for catching a panic while a panicked `Task` is…","i":[[5,"catch_unwind_with_arg","catch_unwind","Invokes the given closure `f`, catching a panic as it is…",N,[[["a"],["f"]],[[R[720]],[R[1],[R[720]]]]]]],"p":[]};
searchIndex["color"]={"doc":"A simple representation of the standard RGB color model.","i":[[3,"Color","color","This structure represents a color value in the standard…",N,N],[17,"BLACK",E,E,N,N],[17,"BLUE",E,E,N,N],[17,"GREEN",E,E,N,N],[17,"CYAN",E,E,N,N],[17,"RED",E,E,N,N],[17,"MAGENTA",E,E,N,N],[17,"BROWN",E,E,N,N],[17,"LIGHT_GRAY",E,E,N,N],[17,"GRAY",E,E,N,N],[17,"DARK_GRAY",E,E,N,N],[17,"LIGHT_BLUE",E,E,N,N],[17,"LIGHT_GREEN",E,E,N,N],[17,"LIGHT_CYAN",E,E,N,N],[17,"PINK",E,E,N,N],[17,"YELLOW",E,E,N,N],[17,"WHITE",E,E,N,N],[17,"TRANSPARENT",E,E,N,N],[11,"new",E,"Creates a new `Color` structure from a 4 bytes ARGB…",0,[[["u32"]],["color"]]],[11,"set_transparency",E,"Sets the transparency of the color, in which `0` is opaque…",0,[[["self"],["u8"]]]],[11,"transparency",E,"Returns the transparency component of this `Color` as a…",0,[[["self"]],["u8"]]],[11,"red",E,"Returns the red component of this `Color` as a `u8` value.",0,[[["self"]],["u8"]]],[11,"blue",E,"Returns the blue component of this `Color` as a `u8` value.",0,[[["self"]],["u8"]]],[11,"green",E,"Returns the green component of this `Color` as a `u8` value.",0,[[["self"]],["u8"]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,"fmt",E,E,0,[[[R[12]],["self"]],[R[1]]]],[11,"eq",E,E,0,[[["color"],["self"]],["bool"]]],[11,"clone",E,E,0,[[["self"]],["color"]]]],"p":[[3,"Color"]]};
searchIndex["compositor"]={"doc":"This crate defines a trait of `Compositor` . A compositor…","i":[[3,R[770],"compositor","A source framebuffer to be composited, along with its…",N,N],[12,"src_framebuffer",E,"The source framebuffer to be composited.",0,N],[12,"coordinate_in_dest_framebuffer",E,"The coordinate in the destination framebuffer where the…",0,N],[8,R[771],E,"A compositor composites (combines or blends) a series of…",N,N],[10,R[779],E,"Composites the framebuffers in the list of source…",1,[[[R[763]],["self"]],[[R[1],["str"]],["str"]]]],[8,R[772],E,"A `CompositableRegion` is an abstract region (i.e., a…",N,N],[10,"size",E,"Returns the number of pixels in the region.",2,[[["self"]],["usize"]]],[10,"row_range",E,"Returns the range of rows covered by this region, given as…",2,[[["self"]],[["isize"],["range",["isize"]]]]],[10,"blend_buffers",E,"Blends the pixels in the source framebuffer `src_fb`…",2,[[[R[763]],["usize"],[R[763]],["coord"],["self"],["range",["usize"]]],[[R[1],["str"]],["str"]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]]],"p":[[3,R[770]],[8,R[771]],[8,R[772]]]};
searchIndex["context_switch"]={"doc":"This is a wrapper crate around all other context switch…","i":[[3,"Context",R[68],R[20],N,N],[5,R[68],E,R[69],N,[[["usize"]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,"new",E,R[70],0,[[["usize"]],[R[71]]]]],"p":[[3,"Context"]]};
searchIndex["context_switch_avx"]={"doc":R[19],"i":[[3,R[24],R[23],R[20],N,N],[5,R[23],E,"Switches context from an AVX Task to another AVX Task.",N,[[["usize"]]]],[11,"new",E,"Creates a new ContextAVX struct that will cause the…",0,[[["usize"]],["contextavx"]]],[14,"save_registers_avx",E,"An assembly macro for saving AVX registers by pushing them…",N,N],[14,"restore_registers_avx",E,"An assembly macro for restoring AVX registers by popping…",N,N],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]]],"p":[[3,R[24]]]};
searchIndex["context_switch_regular"]={"doc":R[19],"i":[[3,R[10],R[4],R[20],N,N],[5,R[4],E,"Switches context from a regular Task to another regular…",N,[[["usize"]]]],[11,"new",E,"Creates a new ContextRegular struct that will cause the…",0,[[["usize"]],["contextregular"]]],[14,"save_registers_regular",E,R[5],N,N],[14,"switch_stacks",E,"An assembly macro for switching stacks, which is the…",N,N],[14,"restore_registers_regular",E,R[5],N,N],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]]],"p":[[3,R[10]]]};
searchIndex["context_switch_sse"]={"doc":R[19],"i":[[3,R[22],R[21],R[20],N,N],[5,R[21],E,R[69],N,[[["usize"]]]],[11,"new",E,R[70],0,[[["usize"]],[R[71]]]],[14,"save_registers_sse",E,R[5],N,N],[14,"restore_registers_sse",E,R[5],N,N],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]]],"p":[[3,R[22]]]};
searchIndex["crate_metadata"]={"doc":"Defines types that contain metadata about crates loaded in…","i":[[3,R[355],"crate_metadata",R[487],N,N],[12,R[488],E,R[489],0,N],[12,R[490],E,R[491],0,N],[12,R[492],E,R[493],0,N],[12,"sections",E,R[494],0,N],[12,R[495],E,R[344],0,N],[12,R[496],E,R[344],0,N],[12,R[497],E,R[344],0,N],[12,R[498],E,R[499],0,N],[12,R[500],E,R[501],0,N],[12,R[502],E,R[503],0,N],[3,R[356],E,R[508],N,N],[12,R[509],E,R[510],1,N],[12,R[511],E,R[512],1,N],[3,R[357],E,R[513],N,N],[12,"name",E,R[514],2,N],[12,"typ",E,R[515],2,N],[12,"global",E,R[516],2,N],[12,R[517],E,R[518],2,N],[12,R[519],E,R[520],2,N],[12,R[521],E,R[522],2,N],[12,R[523],E,R[524],2,N],[12,"inner",E,R[525],2,N],[3,R[358],E,R[526],N,N],[12,"section",E,R[527],3,N],[12,R[345],E,R[346],3,N],[3,R[359],E,R[528],N,N],[12,"section",E,R[529],4,N],[12,R[345],E,R[346],4,N],[3,R[360],E,R[530],N,N],[12,"typ",E,R[531],5,N],[12,"addend",E,R[532],5,N],[12,"offset",E,R[533],5,N],[4,R[361],E,R[484],N,N],[13,"Kernel",E,E,6,N],[13,R[485],E,E,6,N],[13,R[486],E,E,6,N],[4,R[362],E,R[504],N,N],[13,"Text",E,E,7,N],[13,"Rodata",E,E,7,N],[13,"Data",E,E,7,N],[13,"Bss",E,E,7,N],[13,R[505],E,R[506],7,N],[13,"EhFrame",E,R[507],7,N],[5,R[534],E,R[535],N,[[["bool"],["usize"],[R[168]],[R[354]],[R[81]]],[[R[1],["str"]],["str"]]]],[6,R[463],E,R[464],N,N],[6,R[465],E,R[466],N,N],[6,R[467],E,R[468],N,N],[6,R[469],E,R[470],N,N],[6,"Shndx",E,R[471],N,N],[17,R[472],E,R[473],N,N],[17,R[474],E,R[475],N,N],[17,R[476],E,R[477],N,N],[17,R[478],E,R[479],N,N],[17,R[480],E,R[481],N,N],[17,R[482],E,R[483],N,N],[11,R[548],E,R[549],6,[[["self"]],["str"]]],[11,R[550],E,R[551],6,[[["str"]],[[R[1],["str"]],["str"]]]],[11,R[552],E,R[553],6,[[["str"]],["bool"]]],[11,R[554],E,R[347],6,[[["str"]],["bool"]]],[11,R[555],E,R[347],6,[[["str"]],["bool"]]],[11,R[556],E,R[557],0,[[["str"],["self"]],[[R[31],[R[348]]],[R[348]]]]],[11,R[558],E,R[559],0,[[["self"]]]],[11,R[560],E,R[561],0,[[["self"]]]],[11,R[562],E,R[563],0,[[["self"],["f"]],[[R[31],[R[348]]],[R[348]]]]],[11,R[564],E,R[565],0,[[["self"]],["str"]]],[11,R[566],E,R[567],0,[[["self"]],["string"]]],[11,R[568],E,R[569],0,[[["self"]],[["vec",[R[349]]],[R[349]]]]],[11,R[570],E,R[571],0,[[["self"]],[["vec",[R[349]]],[R[349]]]]],[11,R[573],E,R[574],7,[[["self"]],["bool"]]],[11,"new",E,R[575],2,[[["string"],[R[351]],[R[81]],["arc",["mutex"]],["bool"],["usize"],[R[349]],["mutex",[R[168]]]],[R[353]]]],[11,R[576],E,R[577],2,[[["string"],[R[352]],["vec",[R[350]]],[R[350]],[R[351]],[R[81]],["arc",["mutex"]],["bool"],["usize"],[R[349]],["vec",[R[352]]],["mutex",[R[168]]]],[R[353]]]],[11,R[86],E,R[579],2,[[["self"]],[R[81]]]],[11,"size",E,R[580],2,[[["self"]],["usize"]]],[11,"get_type",E,R[581],2,[[["self"]],[R[351]]]],[11,R[582],E,R[583],2,[[["self"]],["str"]]],[11,R[584],E,R[585],2,[[["str"]],["str"]]],[11,R[586],E,R[587],2,[[["self"],[R[348]]],[[R[31],["usize"]],["usize"]]]],[11,R[588],E,R[589],2,[[[R[353]],["self"]],[[R[1],["str"]],["str"]]]],[11,R[590],E,E,5,[[["rela"]],[R[354]]]],[11,R[394],E,R[591],5,[[["self"]],["bool"]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[6],E,E,1,[[[U]],[R[1]]]],[11,"into",E,E,1,[[],[U]]],[11,R[7],E,E,1,[[],[R[1]]]],[11,R[8],E,E,1,[[["self"]],[T]]],[11,R[9],E,E,1,[[["self"]],[T]]],[11,R[11],E,E,1,[[["self"]],[R[14]]]],[11,"from",E,E,2,[[[T]],[T]]],[11,R[6],E,E,2,[[[U]],[R[1]]]],[11,"into",E,E,2,[[],[U]]],[11,R[7],E,E,2,[[],[R[1]]]],[11,R[8],E,E,2,[[["self"]],[T]]],[11,R[9],E,E,2,[[["self"]],[T]]],[11,R[11],E,E,2,[[["self"]],[R[14]]]],[11,"from",E,E,3,[[[T]],[T]]],[11,R[6],E,E,3,[[[U]],[R[1]]]],[11,"into",E,E,3,[[],[U]]],[11,R[7],E,E,3,[[],[R[1]]]],[11,R[8],E,E,3,[[["self"]],[T]]],[11,R[9],E,E,3,[[["self"]],[T]]],[11,R[11],E,E,3,[[["self"]],[R[14]]]],[11,R[64],E,E,3,[[["self"]],[T]]],[11,R[65],E,E,3,[[["self"],[T]]]],[11,"from",E,E,4,[[[T]],[T]]],[11,R[6],E,E,4,[[[U]],[R[1]]]],[11,"into",E,E,4,[[],[U]]],[11,R[7],E,E,4,[[],[R[1]]]],[11,R[8],E,E,4,[[["self"]],[T]]],[11,R[9],E,E,4,[[["self"]],[T]]],[11,R[11],E,E,4,[[["self"]],[R[14]]]],[11,R[64],E,E,4,[[["self"]],[T]]],[11,R[65],E,E,4,[[["self"],[T]]]],[11,"from",E,E,5,[[[T]],[T]]],[11,R[6],E,E,5,[[[U]],[R[1]]]],[11,"into",E,E,5,[[],[U]]],[11,R[7],E,E,5,[[],[R[1]]]],[11,R[8],E,E,5,[[["self"]],[T]]],[11,R[9],E,E,5,[[["self"]],[T]]],[11,R[11],E,E,5,[[["self"]],[R[14]]]],[11,R[64],E,E,5,[[["self"]],[T]]],[11,R[65],E,E,5,[[["self"],[T]]]],[11,"from",E,E,6,[[[T]],[T]]],[11,R[6],E,E,6,[[[U]],[R[1]]]],[11,"into",E,E,6,[[],[U]]],[11,R[7],E,E,6,[[],[R[1]]]],[11,R[8],E,E,6,[[["self"]],[T]]],[11,R[9],E,E,6,[[["self"]],[T]]],[11,R[11],E,E,6,[[["self"]],[R[14]]]],[11,"from",E,E,7,[[[T]],[T]]],[11,R[6],E,E,7,[[[U]],[R[1]]]],[11,"into",E,E,7,[[],[U]]],[11,R[7],E,E,7,[[],[R[1]]]],[11,R[8],E,E,7,[[["self"]],[T]]],[11,R[9],E,E,7,[[["self"]],[T]]],[11,R[11],E,E,7,[[["self"]],[R[14]]]],[11,R[64],E,E,7,[[["self"]],[T]]],[11,R[65],E,E,7,[[["self"],[T]]]],[11,"fmt",E,E,6,[[[R[12]],["self"]],[R[1]]]],[11,"fmt",E,E,0,[[["self"],[R[12]]],[R[1]]]],[11,"fmt",E,E,7,[[[R[12]],["self"]],[R[1]]]],[11,"fmt",E,E,2,[[["self"],[R[12]]],[R[1]]]],[11,"fmt",E,E,3,[[[R[12]],["self"]],[R[1]]]],[11,"fmt",E,E,4,[[[R[12]],["self"]],[R[1]]]],[11,"fmt",E,E,5,[[["self"],[R[12]]],[R[1]]]],[11,"eq",E,E,6,[[["self"],[R[546]]],["bool"]]],[11,"eq",E,E,7,[[["self"],[R[351]]],["bool"]]],[11,"eq",E,E,5,[[["self"],[R[354]]],["bool"]]],[11,"ne",E,E,5,[[["self"],[R[354]]],["bool"]]],[11,"drop",E,E,0,[[["self"]]]],[11,"clone",E,E,7,[[["self"]],[R[351]]]],[11,"clone",E,E,3,[[["self"]],[R[352]]]],[11,"clone",E,E,4,[[["self"]],[R[350]]]],[11,"clone",E,E,5,[[["self"]],[R[354]]]],[11,R[38],E,E,1,[[],[R[547]]]]],"p":[[3,R[355]],[3,R[356]],[3,R[357]],[3,R[358]],[3,R[359]],[3,R[360]],[4,R[361]],[4,R[362]]]};
searchIndex["crate_name_utils"]={"doc":"Utility functions for parsing and processing crate names…","i":[[5,R[461],"crate_name_utils",R[462],N,[[["path"]],["str"]]],[5,"is_valid_crate_name_char",E,"Crate names must be only alphanumeric characters, an…",N,[[["char"]],["bool"]]],[5,R[457],E,R[458],N,[[["str"]],[["str"],["vec",["str"]]]]],[5,"get_containing_crate_name_ranges",E,"Same as `get_containing_crate_name()`, but returns the…",N,[[["str"]],[["vec",["range"]],["range",["usize"]]]]],[5,R[459],E,R[460],N,[[["str"]],[["string"],[R[31],["string"]]]]]],"p":[]};
searchIndex["crate_swap"]={"doc":"Defines functions and types for crate swapping, used in…","i":[[3,R[620],"crate_swap","This struct is used to specify the details of a…",N,N],[4,R[619],E,"The possible errors that can occur when trying to create a…",N,N],[13,"OldCrateNotFound",E,"The old crate was not found in the old `CrateNamespace`.…",0,N],[13,"NewCrateAbsolutePathNotFound",E,"The given absolute `Path` for the new crate object file…",0,N],[13,"NewCratePathNotAbsolute",E,"The given `Path` for the new crate object file was not an…",0,N],[13,"NewCratePrefixNotFound",E,"A single crate object file could not be found by matching…",0,N],[5,"clear_unloaded_crate_cache",E,"Clears the cache of unloaded (swapped-out) crates saved…",N,[[]]],[5,"swap_crates",E,"Swaps in new crates that can optionally replace existing…",N,[[["string"],[R[31],[R[540]]],["mmiref"],["vec",["string"]],["swaprequestlist"],["bool"],["arc"],[R[540]]],[[R[1],["str"]],["str"]]]],[6,"StateTransferFunction",E,"A state transfer function is an arbitrary function called…",N,N],[6,"SwapRequestList",E,"A list of one or more `SwapRequest`s that is used by the…",N,N],[11,"new",E,"Create a new `SwapRequest` that, when given to…",1,[[["str"],[R[31],["str"]],[R[536]],[R[31],["arc"]],["bool"],["arc",[R[536]]],["intocrateobjectfile"]],[[R[1],[R[618],R[617]]],[R[617]],[R[618]]]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[6],E,E,1,[[[U]],[R[1]]]],[11,"into",E,E,1,[[],[U]]],[11,R[7],E,E,1,[[],[R[1]]]],[11,R[8],E,E,1,[[["self"]],[T]]],[11,R[9],E,E,1,[[["self"]],[T]]],[11,R[11],E,E,1,[[["self"]],[R[14]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,"fmt",E,E,1,[[["self"],[R[12]]],[R[1]]]],[11,"fmt",E,E,0,[[["self"],[R[12]]],[R[1]]]],[11,"eq",E,E,1,[[["self"],[R[618]]],["bool"]]],[11,"ne",E,E,1,[[["self"],[R[618]]],["bool"]]],[11,"hash",E,E,1,[[["self"],["__h"]]]]],"p":[[4,R[619]],[3,R[620]]]};
searchIndex["debug_info"]={"doc":"Support for DWARF debug information from ELF files.","i":[[3,R[616],R[613],"The set of debug sections that we need to use from a crate…",N,N],[4,R[615],E,"An enum describing the possible forms of debug information…",N,N],[13,"Unloaded",E,"Debug information that hasn't yet been parsed from the…",0,N],[13,"Loaded",E,"The debug information has already been parsed from the file",0,N],[11,"debug_str",E,"Returns the `\".debug_str\"` section.",1,[[["self"]],[["debugstr",[R[611]]],[R[611],[R[612]]]]]],[11,"debug_loc",E,"Returns the `\".debug_loc\"` section.",1,[[["self"]],[["debugloc",[R[611]]],[R[31],["debugloc"]]]]],[11,"debug_abbrev",E,"Returns the `\".debug_abbrev\"` section.",1,[[["self"]],[["debugabbrev",[R[611]]],[R[611],[R[612]]]]]],[11,R[613],E,"Returns the `\".debug_info\"` section.",1,[[["self"]],[["debuginfo",[R[611]]],[R[611],[R[612]]]]]],[11,"debug_ranges",E,"Returns the `\".debug_ranges\"` section.",1,[[["self"]],[["debugranges",[R[611]]],[R[611],[R[612]]]]]],[11,"debug_pubnames",E,"Returns the `\".debug_pubnames\"` section.",1,[[["self"]],[["debugpubnames",[R[611]]],[R[611],[R[612]]]]]],[11,"debug_pubtypes",E,"Returns the `\".debug_pubtypes\"` section.",1,[[["self"]],[["debugpubtypes",[R[611]]],[R[611],[R[612]]]]]],[11,"debug_line",E,"Returns the `\".debug_line\"` section.",1,[[["self"]],[["debugline",[R[611]]],[R[611],[R[612]]]]]],[11,"find_subprogram_containing",E,"Finds the subprogram that contains the given instruction…",1,[[["self"],[R[81]]],[[R[1],[R[31]]],[R[31],["debuginfooffset"]]]]],[11,"load",E,"Loads the debug symbols from the enclosed weak file…",0,[[[R[541]],["self"],[R[536]]],[[R[1],[R[614],"str"]],["str"],[R[614]]]]],[11,"get_loaded",E,"A convenience method for accessing the already-loaded…",0,[[["self"]],[[R[31],[R[614]]],[R[614]]]]],[11,"unload",E,"Unloads these `DebugSymbols`, returning the enclosed…",0,[[["self"]],[[R[614]],[R[31],[R[614]]]]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[6],E,E,1,[[[U]],[R[1]]]],[11,"into",E,E,1,[[],[U]]],[11,R[7],E,E,1,[[],[R[1]]]],[11,R[8],E,E,1,[[["self"]],[T]]],[11,R[9],E,E,1,[[["self"]],[T]]],[11,R[11],E,E,1,[[["self"]],[R[14]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]]],"p":[[4,R[615]],[3,R[616]]]};
searchIndex["device_manager"]={"doc":E,"i":[[5,"early_init","device_manager","This is for early-stage initialization of things like VGA,…",N,[[[R[735]]],[[R[1],["str"]],["str"]]]],[5,"init",E,"Initializes all other devices, such as the keyboard and…",N,[[["event"],["queue",["event"]]],[[R[1],["str"]],["str"]]]]],"p":[]};
searchIndex["displayable"]={"doc":"This crate defines a trait of `Displayable`. A displayable…","i":[[8,R[769],"displayable","The `Displayable` trait is an abstraction for any object…",N,N],[10,"display",E,"Displays this `Displayable`'s content in the given…",0,[[["coord"],["self"],[R[763]]],[[R[1],[R[15],"str"]],[R[15]],["str"]]]],[10,"set_size",E,"Resizes the displayable area, but does not automatically…",0,[[["self"],["usize"]]]],[10,R[774],E,"Gets the size of the area occupied by the displayable.",0,[[["self"]]]]],"p":[[8,R[769]]]};
searchIndex["e1000"]={"doc":E,"i":[[3,R[684],"e1000","struct to hold mapping of registers",N,N],[12,"ctrl",E,E,0,N],[12,"status",E,E,0,N],[12,"icr",E,"Interrupt control registers",0,N],[12,"ims",E,E,0,N],[12,"rctl",E,"Receive control register",0,N],[12,"tctl",E,"Transmit control register",0,N],[12,"rx_regs",E,E,0,N],[12,"tx_regs",E,E,0,N],[12,"ral",E,"The lower (least significant) 32 bits of the NIC's MAC…",0,N],[12,"rah",E,"The higher (most significant) 32 bits of the NIC's MAC…",0,N],[3,R[685],E,"struct to hold registers related to one receive queue",N,N],[12,"rdbal",E,R[680],1,N],[12,"rdbah",E,R[681],1,N],[12,"rdlen",E,"The length in bytes of the array of receive descriptors.",1,N],[12,"rdh",E,"The receive descriptor head index, which points to the…",1,N],[12,"rdt",E,"The receive descriptor tail index, which points to the…",1,N],[3,R[686],E,"struct to hold registers related to one transmit queue",N,N],[12,"tdbal",E,R[680],2,N],[12,"tdbah",E,R[681],2,N],[12,"tdlen",E,"The length in bytes of the array of transmit descriptors.",2,N],[12,"tdh",E,"The transmit descriptor head index, which points to the…",2,N],[12,"tdt",E,"The transmit descriptor tail index, which points to the…",2,N],[3,"E1000Nic",E,"struct representing an e1000 network interface card.",N,N],[5,"get_e1000_nic",E,"Returns a reference to the E1000Nic wrapped in a…",N,[[],[[R[31],[R[682]]],[R[682]]]]],[0,"test_e1000_driver",E,E,N,N],[3,R[687],R[683],E,N,N],[12,"dest1",E,E,3,N],[12,"dest2",E,E,3,N],[12,"dest3",E,E,3,N],[12,"source1",E,E,3,N],[12,"source2",E,E,3,N],[12,"source3",E,E,3,N],[12,"packet_type",E,E,3,N],[12,"h_type",E,E,3,N],[12,"p_type",E,E,3,N],[12,"hlen",E,E,3,N],[12,"plen",E,E,3,N],[12,"oper",E,E,3,N],[12,"sha1",E,E,3,N],[12,"sha2",E,E,3,N],[12,"sha3",E,E,3,N],[12,"spa1",E,E,3,N],[12,"spa2",E,E,3,N],[12,"tha1",E,E,3,N],[12,"tha2",E,E,3,N],[12,"tha3",E,E,3,N],[12,"tpa1",E,E,3,N],[12,"tpa2",E,E,3,N],[5,"test_e1000_nic_driver",E,E,N,[[["u64"],[R[31],["u64"]]]]],[5,"dhcp_request_packet",E,E,N,[[],[[R[1],["str"]],["str"]]]],[17,"INTEL_VEND","e1000",E,N,N],[17,"E1000_DEV",E,E,N,N],[11,"init",E,"Initializes the new E1000 network interface card that is…",4,[[[R[281]]],[[R[682]],[R[1],[R[682],"str"]],["str"]]]],[11,"spoof_mac",E,E,4,[[["self"]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[6],E,E,1,[[[U]],[R[1]]]],[11,"into",E,E,1,[[],[U]]],[11,R[7],E,E,1,[[],[R[1]]]],[11,R[8],E,E,1,[[["self"]],[T]]],[11,R[9],E,E,1,[[["self"]],[T]]],[11,R[11],E,E,1,[[["self"]],[R[14]]]],[11,"from",E,E,2,[[[T]],[T]]],[11,R[6],E,E,2,[[[U]],[R[1]]]],[11,"into",E,E,2,[[],[U]]],[11,R[7],E,E,2,[[],[R[1]]]],[11,R[8],E,E,2,[[["self"]],[T]]],[11,R[9],E,E,2,[[["self"]],[T]]],[11,R[11],E,E,2,[[["self"]],[R[14]]]],[11,"from",E,E,4,[[[T]],[T]]],[11,R[6],E,E,4,[[[U]],[R[1]]]],[11,"into",E,E,4,[[],[U]]],[11,R[7],E,E,4,[[],[R[1]]]],[11,R[8],E,E,4,[[["self"]],[T]]],[11,R[9],E,E,4,[[["self"]],[T]]],[11,R[11],E,E,4,[[["self"]],[R[14]]]],[11,"from",R[683],E,3,[[[T]],[T]]],[11,R[6],E,E,3,[[[U]],[R[1]]]],[11,"into",E,E,3,[[],[U]]],[11,R[7],E,E,3,[[],[R[1]]]],[11,R[8],E,E,3,[[["self"]],[T]]],[11,R[9],E,E,3,[[["self"]],[T]]],[11,R[11],E,E,3,[[["self"]],[R[14]]]],[11,R[688],"e1000",E,4,[[["self"],[R[288]]],[[R[1],["str"]],["str"]]]],[11,R[689],E,E,4,[[["self"]],[[R[372]],[R[31],[R[372]]]]]],[11,R[690],E,E,4,[[["self"]],[[R[1],["str"]],["str"]]]],[11,R[691],E,E,4,[[["self"]]]]],"p":[[3,R[684]],[3,R[685]],[3,R[686]],[3,R[687]],[3,"E1000Nic"]]};
searchIndex["entryflags_x86_64"]={"doc":"This crate defines the structure of page table entry flags…","i":[[3,R[60],"entryflags_x86_64",R[112],N,N],[18,"PRESENT",E,E,0,N],[18,R[246],E,E,0,N],[18,R[145],E,E,0,N],[18,R[146],E,E,0,N],[18,R[247],E,E,0,N],[18,R[248],E,E,0,N],[18,"DIRTY",E,E,0,N],[18,R[147],E,E,0,N],[18,"GLOBAL",E,E,0,N],[18,R[148],E,E,0,N],[11,"empty",E,R[149],0,[[],[R[57]]]],[11,"all",E,R[150],0,[[],[R[57]]]],[11,"bits",E,R[151],0,[[["self"]],["u64"]]],[11,R[152],E,R[153],0,[[["u64"]],[[R[57]],[R[31],[R[57]]]]]],[11,R[154],E,R[155],0,[[["u64"]],[R[57]]]],[11,R[47],E,R[156],0,[[["self"]],["bool"]]],[11,"is_all",E,R[157],0,[[["self"]],["bool"]]],[11,R[158],E,R[159],0,[[["self"],[R[57]]],["bool"]]],[11,R[249],E,R[160],0,[[["self"],[R[57]]],["bool"]]],[11,"insert",E,R[161],0,[[["self"],[R[57]]]]],[11,"remove",E,R[162],0,[[["self"],[R[57]]]]],[11,"toggle",E,R[163],0,[[["self"],[R[57]]]]],[11,"set",E,R[164],0,[[["self"],[R[57]],["bool"]]]],[11,"is_huge",E,R[131],0,[[["self"]],["bool"]]],[11,R[132],E,R[133],0,[[],[R[57]]]],[11,R[134],E,R[135],0,[[["self"]],["bool"]]],[11,R[136],E,R[137],0,[[],[R[57]]]],[11,R[138],E,R[139],0,[[["self"]],["bool"]]],[11,R[140],E,R[58],0,[[[R[141]]],[R[57]]]],[11,R[142],E,R[58],0,[[["u64"]],[R[57]]]],[11,R[143],E,R[144],0,[[["flags"]],[R[57]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,"fmt",E,E,0,[[["self"],[R[12]]],[R[1]]]],[11,"sub",E,R[118],0,[[[R[57]]],[R[57]]]],[11,"eq",E,E,0,[[[R[57]],["self"]],["bool"]]],[11,"ne",E,E,0,[[[R[57]],["self"]],["bool"]]],[11,"cmp",E,E,0,[[[R[57]],["self"]],[R[16]]]],[11,R[61],E,E,0,[[[R[57]],["self"]],[[R[16]],[R[31],[R[16]]]]]],[11,"lt",E,E,0,[[[R[57]],["self"]],["bool"]]],[11,"le",E,E,0,[[[R[57]],["self"]],["bool"]]],[11,"gt",E,E,0,[[[R[57]],["self"]],["bool"]]],[11,"ge",E,E,0,[[[R[57]],["self"]],["bool"]]],[11,R[93],E,R[117],0,[[["self"],[R[57]]]]],[11,"not",E,R[120],0,[[],[R[57]]]],[11,"bitand",E,R[116],0,[[[R[57]]],[R[57]]]],[11,"bitor",E,R[114],0,[[[R[57]]],[R[57]]]],[11,"bitxor",E,R[123],0,[[[R[57]]],[R[57]]]],[11,R[95],E,R[115],0,[[["self"],[R[57]]]]],[11,R[96],E,R[119],0,[[["self"],[R[57]]]]],[11,R[97],E,R[122],0,[[["self"],[R[57]]]]],[11,"hash",E,E,0,[[["self"],["__h"]]]],[11,R[121],E,E,0,[[[R[59]]],[R[57]]]],[11,"extend",E,E,0,[[["self"],[R[59]]]]],[11,"fmt",E,E,0,[[["self"],[R[12]]],[R[1]]]],[11,"fmt",E,E,0,[[["self"],[R[12]]],[R[1]]]],[11,"fmt",E,E,0,[[["self"],[R[12]]],[R[1]]]],[11,"fmt",E,E,0,[[["self"],[R[12]]],[R[1]]]],[11,"clone",E,E,0,[[["self"]],[R[57]]]],[11,R[38],E,E,0,[[],[R[57]]]]],"p":[[3,R[60]]]};
searchIndex["environment"]={"doc":E,"i":[[3,R[393],R[392],"A structure that contains environment state for a given…",N,N],[12,"working_dir",E,"The \"current working directory\", i.e., where a task's…",0,N],[11,"get_wd_path",E,"Gets the absolute file path of the working directory",0,[[["self"]],["string"]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,R[38],E,E,0,[[],[R[392]]]]],"p":[[3,R[393]]]};
searchIndex["ethernet_smoltcp_device"]={"doc":"This crate implements an interface/glue layer between our…","i":[[3,R[728],"ethernet_smoltcp_device","A struct that implements the `NetworkInterface` trait for…",N,N],[12,"iface",E,E,0,N],[3,R[729],E,"An implementation of smoltcp's `Device` trait, which…",N,N],[3,"TxToken",E,"The transmit token type used by smoltcp, which contains…",N,N],[3,"RxToken",E,"The receive token type used by smoltcp, which contains…",N,N],[11,"new",E,"Creates a new instance of an ethernet network interface,…",0,[[[R[31]],["ipcidr"],[R[31],["ipcidr"]],["into",[R[725]]],[R[725]],[R[682]]],[["str"],[R[726]],[R[1],[R[726],"str"]]]]],[11,"new_ipv4_interface",E,"Creates a new ethernet network interface with an ipv4…",0,[[["str"],[R[682]]],[["str"],[R[726]],[R[1],[R[726],"str"]]]]],[11,"new",E,"Create a new instance of the `EthernetDevice`.",1,[[[R[682]]],["ethernetdevice"]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[6],E,E,1,[[[U]],[R[1]]]],[11,"into",E,E,1,[[],[U]]],[11,R[7],E,E,1,[[],[R[1]]]],[11,R[8],E,E,1,[[["self"]],[T]]],[11,R[9],E,E,1,[[["self"]],[T]]],[11,R[11],E,E,1,[[["self"]],[R[14]]]],[11,"from",E,E,2,[[[T]],[T]]],[11,R[6],E,E,2,[[[U]],[R[1]]]],[11,"into",E,E,2,[[],[U]]],[11,R[7],E,E,2,[[],[R[1]]]],[11,R[8],E,E,2,[[["self"]],[T]]],[11,R[9],E,E,2,[[["self"]],[T]]],[11,R[11],E,E,2,[[["self"]],[R[14]]]],[11,"from",E,E,3,[[[T]],[T]]],[11,R[6],E,E,3,[[[U]],[R[1]]]],[11,"into",E,E,3,[[],[U]]],[11,R[7],E,E,3,[[],[R[1]]]],[11,R[8],E,E,3,[[["self"]],[T]]],[11,R[9],E,E,3,[[["self"]],[T]]],[11,R[11],E,E,3,[[["self"]],[R[14]]]],[11,R[727],E,E,1,[[["self"]],["devicecapabilities"]]],[11,"receive",E,E,1,[[["self"]],[R[31]]]],[11,"transmit",E,E,1,[[["self"]],[R[31]]]],[11,"consume",E,E,3,[[["instant"],["f"]],[R[1]]]],[11,"consume",E,E,2,[[["instant"],["usize"],["f"]],[R[1]]]],[11,R[730],E,E,0,[[["self"]],[R[717]]]],[11,R[731],E,E,0,[[["self"],[R[717]]]]],[11,"poll",E,E,0,[[["instant"],["self"],[R[724]]],[["bool"],[R[1],["bool"]]]]],[11,"ip_addrs",E,E,0,[[["self"]]]],[11,R[732],E,E,0,[[["self"],[R[725]]],["bool"]]],[11,"routes",E,E,0,[[["self"]],["routes"]]],[11,R[733],E,E,0,[[["self"]],["routes"]]]],"p":[[3,R[728]],[3,R[729]],[3,"TxToken"],[3,"RxToken"]]};
searchIndex["event_types"]={"doc":E,"i":[[3,R[62],"event_types","An event describing mouse position rather than movement…",N,N],[12,"coordinate",E,"the relative position in window",0,N],[12,"gcoordinate",E,"the global position in window",0,N],[12,"scrolling_up",E,"whether the mouse is scrolling up",0,N],[12,"scrolling_down",E,"whether the mouse is scrolling down",0,N],[12,"left_button_hold",E,"whether the left button holds",0,N],[12,"right_button_hold",E,"whether the right button holds",0,N],[12,"fourth_button_hold",E,"whether the fourth button holds",0,N],[12,"fifth_button_hold",E,"whether the fifth button holds",0,N],[3,R[67],E,"A keyboard event, indicating that one or more keys were…",N,N],[12,"key_event",E,"The key input event from i/o device",1,N],[4,"Event",E,E,N,N],[13,"KeyboardEvent",E,"An input event from a keyboard",2,N],[13,"MouseMovementEvent",E,"An input event from a mouse",2,N],[13,"OutputEvent",E,"An event indicating that another entity wants to print the…",2,N],[13,"WindowResizeEvent",E,"Tells an application that the window manager has resized…",2,N],[13,R[62],E,"The event tells application about mouse's position…",2,N],[13,"ExitEvent",E,E,2,N],[11,"new_keyboard_event",E,"Create a new keyboard event",2,[[[R[63]]],["event"]]],[11,"new_output_event",E,"Create a new output event",2,[[["s"]],["event"]]],[11,"new_window_resize_event",E,"Create a new window resize event",2,[[[R[15]]],["event"]]],[11,"new",E,"Create a new key board input event. `key` is the key input…",1,[[[R[63]]],[R[66]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,R[64],E,E,0,[[["self"]],[T]]],[11,R[65],E,E,0,[[["self"],[T]]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[6],E,E,1,[[[U]],[R[1]]]],[11,"into",E,E,1,[[],[U]]],[11,R[7],E,E,1,[[],[R[1]]]],[11,R[8],E,E,1,[[["self"]],[T]]],[11,R[9],E,E,1,[[["self"]],[T]]],[11,R[11],E,E,1,[[["self"]],[R[14]]]],[11,R[64],E,E,1,[[["self"]],[T]]],[11,R[65],E,E,1,[[["self"],[T]]]],[11,"from",E,E,2,[[[T]],[T]]],[11,R[6],E,E,2,[[[U]],[R[1]]]],[11,"into",E,E,2,[[],[U]]],[11,R[7],E,E,2,[[],[R[1]]]],[11,R[8],E,E,2,[[["self"]],[T]]],[11,R[9],E,E,2,[[["self"]],[T]]],[11,R[11],E,E,2,[[["self"]],[R[14]]]],[11,R[64],E,E,2,[[["self"]],[T]]],[11,R[65],E,E,2,[[["self"],[T]]]],[11,"fmt",E,E,0,[[[R[12]],["self"]],[R[1]]]],[11,"fmt",E,E,2,[[[R[12]],["self"]],[R[1]]]],[11,"fmt",E,E,1,[[[R[12]],["self"]],[R[1]]]],[11,"clone",E,E,0,[[["self"]],["mousepositionevent"]]],[11,"clone",E,E,2,[[["self"]],["event"]]],[11,"clone",E,E,1,[[["self"]],[R[66]]]],[11,R[38],E,E,0,[[],["self"]]]],"p":[[3,R[62]],[3,R[67]],[4,"Event"]]};
searchIndex["exceptions_early"]={"doc":"Early exception handlers that do nothing but print an…","i":[[5,"init","exceptions_early",E,N,[[[R[678]]]]],[5,R[741],E,R[742],N,[[[R[596]]]]],[5,"nmi_handler",E,"exception 0x02",N,[[[R[596]]]]],[5,R[743],E,R[744],N,[[[R[596]]]]],[5,R[745],E,R[746],N,[[[R[596]]]]],[5,R[747],E,R[748],N,[[[R[596]]]]],[5,R[749],E,E,N,[[["u64"],[R[596]]]]],[5,R[750],E,E,N,[[["u64"],[R[596]]]]],[5,R[751],E,E,N,[[["u64"],[R[596]]]]],[5,"early_page_fault_handler",E,E,N,[[[R[752]],[R[596]]]]]],"p":[]};
searchIndex["exceptions_full"]={"doc":"Exception handlers that are task-aware, and will kill a…","i":[[5,"init","exceptions_full",E,N,[[[R[678]]]]],[5,R[741],E,R[742],N,[[[R[596]]]]],[5,"debug_handler",E,"exception 0x01",N,[[[R[596]]]]],[5,R[743],E,R[744],N,[[[R[596]]]]],[5,"overflow_handler",E,"exception 0x04",N,[[[R[596]]]]],[5,"bound_range_exceeded_handler",E,E,N,[[[R[596]]]]],[5,R[745],E,R[746],N,[[[R[596]]]]],[5,R[747],E,R[748],N,[[[R[596]]]]],[5,R[749],E,"exception 0x08",N,[[[R[596]],["u64"]]]],[5,"invalid_tss_handler",E,"exception 0x0a",N,[[[R[596]],["u64"]]]],[5,R[750],E,"exception 0x0b",N,[[[R[596]],["u64"]]]],[5,R[751],E,"exception 0x0d",N,[[[R[596]],["u64"]]]],[5,"page_fault_handler",E,"exception 0x0e",N,[[[R[596]],[R[752]]]]]],"p":[]};
searchIndex["fadt"]={"doc":R[364],"i":[[3,"Fadt","fadt",E,N,N],[12,"header",E,E,0,N],[12,"firmware_ctrl",E,E,0,N],[12,"dsdt",E,"The physical address of the DSDT table",0,N],[12,"preferred_power_managament",E,E,0,N],[12,"sci_interrupt",E,E,0,N],[12,"smi_command_port",E,E,0,N],[12,"acpi_enable",E,E,0,N],[12,"acpi_disable",E,E,0,N],[12,"s4_bios_req",E,E,0,N],[12,"pstate_control",E,E,0,N],[12,"pm1a_event_block",E,E,0,N],[12,"pm1b_event_block",E,E,0,N],[12,"pm1a_control_block",E,E,0,N],[12,"pm1b_control_block",E,E,0,N],[12,"pm2_control_block",E,E,0,N],[12,"pm_timer_block",E,E,0,N],[12,"gpe0_block",E,E,0,N],[12,"gpe1_block",E,E,0,N],[12,"pm1_event_length",E,E,0,N],[12,"pm1_control_length",E,E,0,N],[12,"pm2_control_length",E,E,0,N],[12,"pm_timer_length",E,E,0,N],[12,"gpe0_ength",E,E,0,N],[12,"gpe1_length",E,E,0,N],[12,"gpe1_base",E,E,0,N],[12,"c_state_control",E,E,0,N],[12,"worst_c2_latency",E,E,0,N],[12,"worst_c3_latency",E,E,0,N],[12,"flush_size",E,E,0,N],[12,"flush_stride",E,E,0,N],[12,"duty_offset",E,E,0,N],[12,"duty_width",E,E,0,N],[12,"day_alarm",E,E,0,N],[12,"month_alarm",E,E,0,N],[12,"century",E,E,0,N],[12,"boot_architecture_flags",E,E,0,N],[12,"flags",E,E,0,N],[5,"handle",E,"The handler for parsing the FADT table and adding it to…",N,[[["usize"],[R[82]],[R[300]],[R[363]]],[[R[1],["str"]],["str"]]]],[17,"FADT_SIGNATURE",E,E,N,N],[11,"get",E,"Finds the FADT in the given `AcpiTables` and returns a…",0,[[[R[363]]],[["fadt"],[R[31],["fadt"]]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,R[64],E,E,0,[[["self"]],[T]]],[11,R[65],E,E,0,[[["self"],[T]]]],[11,"fmt",E,E,0,[[[R[12]],["self"]],[R[1]]]],[11,"clone",E,E,0,[[["self"]],["fadt"]]]],"p":[[3,"Fadt"]]};
searchIndex["fault_crate_swap"]={"doc":"Defines support functions needed for swapping of corrupted…","i":[[3,R[667],"fault_crate_swap","A data structure to hold the ranges of memory used by the…",N,N],[12,"old_text",E,E,0,N],[12,"old_rodata",E,E,0,N],[12,"old_data",E,E,0,N],[12,"new_text",E,E,0,N],[12,"new_rodata",E,E,0,N],[12,"new_data",E,E,0,N],[5,"do_self_swap",E,"For swapping of a crate from the identical object file in…",N,[[[R[31],[R[540]]],["string"],[R[540]],["vec",["string"]],["bool"],["str"],["arc",[R[536]]],["dirref"],[R[536]]],[[R[1],[R[666],"string"]],["string"],[R[666]]]]],[5,"constant_offset_fix",E,"A support function for self swap of crate Iterates through…",N,[[[R[666]],["usize"]],[["string"],[R[1],["string"]]]]],[5,"self_swap_handler",E,"This function calls the crate swapping routine for a…",N,[[["str"]],[[R[1],[R[666],"string"]],["string"],[R[666]]]]],[5,"get_crate_to_swap",E,"This function returns the name of the crate to replace if…",N,[[],[["string"],[R[31],["string"]]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,R[64],E,E,0,[[["self"]],[T]]],[11,R[65],E,E,0,[[["self"],[T]]]],[11,"clone",E,E,0,[[["self"]],[R[666]]]],[11,R[38],E,E,0,[[],[R[666]]]]],"p":[[3,R[667]]]};
searchIndex["fault_log"]={"doc":"This crate logs all the faults occuring within Theseus.…","i":[[3,R[624],"fault_log","A data structure to hold information about each fault. ",N,N],[12,"fault_type",E,"Type of fault",0,N],[12,"error_code",E,"Error code returned with the exception",0,N],[12,"core",E,"The core error occured",0,N],[12,"running_task",E,"Task runnning immediately before the Exception",0,N],[12,"running_app_crate",E,"If available the application crate that spawned the task",0,N],[12,"address_accessed",E,"For page faults the address the program attempted to…",0,N],[12,"instruction_pointer",E,"Address at which exception occured",0,N],[12,"crate_error_occured",E,"Crate the address at which exception occured located",0,N],[12,"replaced_crates",E,"List of crates reloaded from memory to recover from fault",0,N],[12,"action_taken",E,"Recovery Action taken as a result of the fault",0,N],[4,R[625],E,"The possible faults (panics and exceptions) encountered…",N,N],[13,"PageFault",E,E,1,N],[13,"GeneralProtectionFault",E,E,1,N],[13,"SegmentNotPresent",E,E,1,N],[13,"InvalidTSS",E,E,1,N],[13,"DoubleFault",E,E,1,N],[13,"DeviceNotAvailable",E,E,1,N],[13,"InvalidOpCode",E,E,1,N],[13,"BoundRangeExceeded",E,E,1,N],[13,"Overflow",E,E,1,N],[13,"NMI",E,E,1,N],[13,"DivideByZero",E,E,1,N],[13,"Panic",E,E,1,N],[13,"UnknownException",E,E,1,N],[4,R[626],E,"The different types of recovery procedures used for the…",N,N],[13,"None",E,"No action taken on this fault.",2,N],[13,"TaskRestarted",E,"Task restarted only. No crate replaced.",2,N],[13,"FaultCrateReplaced",E,"Crate where fault is observed is replaced, and then task…",2,N],[13,"IterativelyCrateReplaced",E,"Different Crate than the crate where fault is observed is…",2,N],[13,"MultipleFaultRecovery",E,"This fault is handled as a recovery for different fault.…",2,N],[5,"from_exception_number",E,"Utility function to get Fault type from exception number. ",N,[[["u8"]],[R[622]]]],[5,"clear_fault_log",E,"Clears the log of faults so far occured in the system ",N,[[]]],[5,"log_exception",E,"Add a new exception instance to the fault log. Generally…",N,[[[R[31],["u64"]],[R[31],["usize"]],["usize"],["u64"],["u8"]]]],[5,"log_panic_entry",E,"Add a new panic instance to the fault log. ",N,[[[R[627]]]]],[5,"remove_unhandled_exceptions",E,"Removes the unhandled faults from the fault log and…",N,[[],[["vec",[R[621]]],[R[621]]]]],[5,"print_fault_log",E,"Prints the fault log",N,[[]]],[5,"log_handled_fault",E,"Add a `FaultEntry` to fault log.",N,[[[R[621]]]]],[5,"get_the_most_recent_match",E,"Provides the most recent entry in the log for given crate…",N,[[["str"]],[[R[621]],[R[31],[R[621]]]]]],[11,"new",E,"Returns an empty `FaultEntry` with only `fault_type` field…",0,[[[R[622]]],[R[621]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,R[64],E,E,0,[[["self"]],[T]]],[11,R[65],E,E,0,[[["self"],[T]]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[6],E,E,1,[[[U]],[R[1]]]],[11,"into",E,E,1,[[],[U]]],[11,R[7],E,E,1,[[],[R[1]]]],[11,R[8],E,E,1,[[["self"]],[T]]],[11,R[9],E,E,1,[[["self"]],[T]]],[11,R[11],E,E,1,[[["self"]],[R[14]]]],[11,R[64],E,E,1,[[["self"]],[T]]],[11,R[65],E,E,1,[[["self"],[T]]]],[11,"from",E,E,2,[[[T]],[T]]],[11,R[6],E,E,2,[[[U]],[R[1]]]],[11,"into",E,E,2,[[],[U]]],[11,R[7],E,E,2,[[],[R[1]]]],[11,R[8],E,E,2,[[["self"]],[T]]],[11,R[9],E,E,2,[[["self"]],[T]]],[11,R[11],E,E,2,[[["self"]],[R[14]]]],[11,R[64],E,E,2,[[["self"]],[T]]],[11,R[65],E,E,2,[[["self"],[T]]]],[11,"fmt",E,E,1,[[[R[12]],["self"]],[R[1]]]],[11,"fmt",E,E,2,[[[R[12]],["self"]],[R[1]]]],[11,"fmt",E,E,0,[[[R[12]],["self"]],[R[1]]]],[11,"eq",E,E,2,[[["self"],[R[623]]],["bool"]]],[11,"clone",E,E,1,[[["self"]],[R[622]]]],[11,"clone",E,E,2,[[["self"]],[R[623]]]],[11,"clone",E,E,0,[[["self"]],[R[621]]]]],"p":[[3,R[624]],[4,R[625]],[4,R[626]]]};
searchIndex["first_application"]={"doc":"This crate contains a simple routine to start the first…","i":[[5,"start","first_application","Starts the first applications that run in Theseus by…",N,[[],[[R[1],["str"]],["str"]]]]],"p":[]};
searchIndex["font"]={"doc":E,"i":[[7,"FONT_BASIC","font","The bitmap array of characters.",N,N],[17,"CHARACTER_WIDTH",E,"The width of a character.",N,N],[17,"CHARACTER_HEIGHT",E,"The height of a character.",N,N]],"p":[]};
searchIndex["framebuffer"]={"doc":"This crate defines a `Framebuffer` structure, which is…","i":[[3,R[768],R[763],"A framebuffer is a region of memory interpreted as a 2-D…",N,N],[5,"init",E,"Initializes the final framebuffer based on VESA graphics…",N,[[],[[R[763]],["str"],[R[1],[R[763],"str"]]]]],[0,"pixel",E,"Defines the `Pixel` trait as well as basic pixel formats,…",N,N],[3,"RGBPixel",R[765],"An RGB Pixel is a pixel with no extra channel.",N,N],[12,"blue",E,E,0,N],[12,"green",E,E,0,N],[12,"red",E,E,0,N],[3,R[767],E,"An Alpha Pixel is a pixel with an alpha channel",N,N],[12,"blue",E,E,1,N],[12,"green",E,E,1,N],[12,"red",E,E,1,N],[12,"alpha",E,E,1,N],[8,"Pixel",E,"A pixel provides methods to blend with others.",N,N],[10,R[764],E,"Composites the `src` pixel slice to the `dest` pixel slice.",2,[[]]],[10,"blend",E,"blend with another pixel considering their extra channel.",2,[[],["self"]]],[10,R[766],E,"Blend two pixels linearly with weights, as `blend` for…",2,[[["f32"]],["self"]]],[11,"new",R[763],"Creates a new framebuffer with rectangular dimensions of…",3,[[[R[82]],["usize"],[R[31],[R[82]]]],[[R[763]],["str"],[R[1],[R[763],"str"]]]]],[11,"buffer_mut",E,"Returns a mutable reference to the mapped memory of the…",3,[[["self"]],[R[366]]]],[11,"buffer",E,"Returns a reference to the mapped memory of the buffer",3,[[["self"]],[R[366]]]],[11,R[774],E,"Returns the `(width, height)` of this framebuffer.",3,[[["self"]]]],[11,R[764],E,"Composites `src` to the buffer starting from `index`.",3,[[["self"],["usize"]]]],[11,"draw_pixel",E,"Draw a pixel at the given 1coordinate1. The `pixel` will…",3,[[["self"],["coord"],["p"]]]],[11,"overwrite_pixel",E,"Overwites a pixel at the given coordinate in this…",3,[[["self"],["coord"],["p"]]]],[11,R[775],E,"Returns the pixel value at the given `coordinate` in this…",3,[[["coord"],["self"]],[R[31]]]],[11,"fill",E,"Fills (overwrites) the entire framebuffer with the given…",3,[[["self"],["p"]]]],[11,"index_of",E,"Returns the index of the given `coordinate` in this…",3,[[["coord"],["self"]],[[R[31],["usize"]],["usize"]]]],[11,R[249],E,"Checks if the given `coordinate` is within the…",3,[[["coord"],["self"]],["bool"]]],[11,R[778],E,"Checks if a framebuffer overlaps with an area. # Arguments…",3,[[["usize"],["self"],["coord"]],["bool"]]],[11,"from",E,E,3,[[[T]],[T]]],[11,R[6],E,E,3,[[[U]],[R[1]]]],[11,"into",E,E,3,[[],[U]]],[11,R[7],E,E,3,[[],[R[1]]]],[11,R[8],E,E,3,[[["self"]],[T]]],[11,R[9],E,E,3,[[["self"]],[T]]],[11,R[11],E,E,3,[[["self"]],[R[14]]]],[11,"from",R[765],E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,R[64],E,E,0,[[["self"]],[T]]],[11,R[65],E,E,0,[[["self"],[T]]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[6],E,E,1,[[[U]],[R[1]]]],[11,"into",E,E,1,[[],[U]]],[11,R[7],E,E,1,[[],[R[1]]]],[11,R[8],E,E,1,[[["self"]],[T]]],[11,R[9],E,E,1,[[["self"]],[T]]],[11,R[11],E,E,1,[[["self"]],[R[14]]]],[11,R[64],E,E,1,[[["self"]],[T]]],[11,R[65],E,E,1,[[["self"],[T]]]],[11,R[764],E,E,0,[[]]],[11,"blend",E,E,0,[[],["self"]]],[11,R[766],E,E,0,[[["f32"]],["self"]]],[11,R[764],E,E,1,[[]]],[11,"blend",E,E,1,[[],["self"]]],[11,R[766],E,E,1,[[["f32"]],["self"]]],[11,"from",E,E,0,[[["color"]],["self"]]],[11,"from",E,E,1,[[["color"]],["self"]]],[11,"fmt",E,E,0,[[[R[12]],["self"]],[R[1]]]],[11,"fmt",E,E,1,[[[R[12]],["self"]],[R[1]]]],[11,"hash",E,E,0,[[["self"],["__h"]]]],[11,"hash",E,E,1,[[["self"],["__h"]]]],[11,"hash",R[763],E,3,[[["self"],["__h"]]]],[11,"clone",R[765],E,0,[[["self"]],["rgbpixel"]]],[11,"clone",E,E,1,[[["self"]],[R[773]]]]],"p":[[3,"RGBPixel"],[3,R[767]],[8,"Pixel"],[3,R[768]]]};
searchIndex["framebuffer_compositor"]={"doc":"This crate defines a framebuffer compositor.","i":[[3,R[781],"framebuffer_compositor","The instance of the framebuffer compositor.",N,N],[3,R[780],E,"A `CacheBlock` represents the cached…",N,N],[3,R[782],E,"The framebuffer compositor structure. It caches…",N,N],[17,"CACHE_BLOCK_HEIGHT",E,"The height of a cache block. In every iteration the…",N,N],[11,R[778],E,"Checks if a cache block overlaps with another one",0,[[["self"],["cacheblock"]],["bool"]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[6],E,E,1,[[[U]],[R[1]]]],[11,"into",E,E,1,[[],[U]]],[11,R[7],E,E,1,[[],[R[1]]]],[11,R[8],E,E,1,[[["self"]],[T]]],[11,R[9],E,E,1,[[["self"]],[T]]],[11,R[11],E,E,1,[[["self"]],[R[14]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,"from",E,E,2,[[[T]],[T]]],[11,R[6],E,E,2,[[[U]],[R[1]]]],[11,"into",E,E,2,[[],[U]]],[11,R[7],E,E,2,[[],[R[1]]]],[11,R[8],E,E,2,[[["self"]],[T]]],[11,R[9],E,E,2,[[["self"]],[T]]],[11,R[11],E,E,2,[[["self"]],[R[14]]]],[11,"deref",E,E,1,[[["self"]],["mutex"]]],[11,R[779],E,E,2,[[[R[763]],["self"]],[[R[1],["str"]],["str"]]]],[11,R[442],E,E,1,[[["self"]]]]],"p":[[3,R[780]],[3,R[781]],[3,R[782]]]};
searchIndex["framebuffer_drawer"]={"doc":"This crate contains a series of basic draw functions to…","i":[[5,"draw_line","framebuffer_drawer","Draws a line in a framebuffer. The part exceeding the…",N,[[[R[763]],["coord"],["pixel"]]]],[5,"draw_rectangle",E,"Draws a rectangle in a framebuffer. The part exceeding the…",N,[[[R[763]],["usize"],["pixel"],["coord"]]]],[5,"fill_rectangle",E,"Fills a rectangle in a framebuffer with color. The part…",N,[[[R[763]],["usize"],["pixel"],["coord"]]]],[5,"draw_circle",E,"Draw a circle in the framebuffer. `coordinate` is the…",N,[[[R[763]],["usize"],["pixel"],["coord"]]]]],"p":[]};
searchIndex["framebuffer_printer"]={"doc":"This crate contains functions to print strings in a…","i":[[5,"print_string","framebuffer_printer","Prints a string in a framebuffer. Returns (column, line,…",N,[[["str"],["pixel"],["usize"],[R[763]],["coord"]]]],[5,"print_ascii_character",E,"Prints a character to the framebuffer at position (line,…",N,[[["coord"],["pixel"],["usize"],[R[763]],["u8"]]]],[5,"fill_blank",E,"Fill a blank text area (left, top, right, bottom) with…",N,[[[R[15]],["pixel"],[R[763]]]]]],"p":[]};
searchIndex["fs_node"]={"doc":"Defines traits for Files and Directories within the…","i":[[4,R[333],"fs_node","Allows us to return a generic type that can be matched by…",N,N],[13,"File",E,E,0,N],[13,"Dir",E,E,0,N],[6,"DirRef",E,"A reference to any type that implements the Directory trait.",N,N],[6,"WeakDirRef",E,"A weak reference to any type that implements the Directory…",N,N],[6,"FileRef",E,"A reference to any type that implements the File trait.",N,N],[6,"WeakFileRef",E,"A weak reference to any type that implements the File trait.",N,N],[8,"FsNode",E,"A trait that covers any filesystem node, both files and…",N,N],[11,R[329],E,R[341],1,[[["self"]],["string"]]],[10,R[338],E,"Returns the string name of the node",1,[[["self"]],["string"]]],[10,R[330],E,"Returns the parent directory of the current node.",1,[[["self"]],[[R[31],["dirref"]],["dirref"]]]],[10,R[331],E,"Sets this node's parent directory. This is useful for…",1,[[["self"],[R[332]]]]],[8,"File",E,E,N,N],[10,"read",E,"Reads the contents of this file starting at the given…",2,[[["usize"],["self"]],[["str"],["usize"],[R[1],["usize","str"]]]]],[10,"write",E,"Writes the given `buffer` to this file starting at the…",2,[[["self"],["usize"]],[["str"],["usize"],[R[1],["usize","str"]]]]],[10,"size",E,"Returns the size in bytes of this file.",2,[[["self"]],["usize"]]],[10,R[339],E,"Returns a view of this file as an immutable memory-mapped…",2,[[["self"]],[["str"],[R[168]],[R[1],[R[168],"str"]]]]],[8,R[334],E,"Trait for directories, implementors of Directory must also…",N,N],[10,"get",E,"Gets either the file or directory in this `Directory` on…",3,[[["str"],["self"]],[[R[31],[R[328]]],[R[328]]]]],[11,"get_file",E,"Like [`get()`], but only looks for files matching the…",3,[[["str"],["self"]],[[R[337]],[R[31],[R[337]]]]]],[11,"get_dir",E,"Like [`get()`], but only looks for directories matching…",3,[[["str"],["self"]],[[R[31],["dirref"]],["dirref"]]]],[10,"insert",E,"Inserts the given new file or directory into this…",3,[[["self"],[R[328]]],[["str"],[R[1],[R[31],"str"]],[R[31],[R[328]]]]]],[10,"remove",E,"Removes a file or directory from this directory and…",3,[[["self"],[R[328]]],[[R[31],[R[328]]],[R[328]]]]],[10,"list",E,"Lists the names of the nodes in this directory.",3,[[["self"]],[["string"],["vec",["string"]]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,R[64],E,E,0,[[["self"]],[T]]],[11,R[65],E,E,0,[[["self"],[T]]]],[11,R[329],E,E,0,[[["self"]],["string"]]],[11,R[338],E,E,0,[[["self"]],["string"]]],[11,R[330],E,E,0,[[["self"]],[[R[31],["dirref"]],["dirref"]]]],[11,R[331],E,E,0,[[["self"],[R[332]]]]],[11,"clone",E,E,0,[[["self"]],[R[328]]]]],"p":[[4,R[333]],[8,"FsNode"],[8,"File"],[8,R[334]]]};
searchIndex["gdt"]={"doc":E,"i":[[3,"Gdt","gdt","The Global Descriptor Table, as specified by the x86_64…",N,N],[4,R[399],E,"The GDT SegmentSelectors available in Theseus. Use this…",N,N],[13,"KernelCode",E,E,0,N],[13,"KernelData",E,E,0,N],[13,"UserCode32",E,E,0,N],[13,"UserData32",E,E,0,N],[13,"UserCode64",E,E,0,N],[13,"UserData64",E,E,0,N],[13,"Tss",E,E,0,N],[4,R[400],E,"We need 6 GDT segments even for 64-bit:…",N,N],[13,"UserSegment",E,"UserSegment is used for both code and data segments, in…",1,N],[13,"SystemSegment",E,"SystemSegment is used only for TSS",1,N],[5,"get_segment_selector",E,"Stupid hack because SegmentSelector is not…",N,[[["availablesegmentselector"]],[R[397]]]],[5,"create_tss_gdt",E,"Creates a new GDT, sets up the TSS with the given double…",N,[[[R[81]],["u8"]]]],[11,"new",E,E,2,[[],["gdt"]]],[11,"add_entry",E,E,2,[[["self"],["privilegelevel"],[R[398]]],[R[397]]]],[11,"load",E,E,2,[[["self"]]]],[11,"kernel_code_segment",E,E,1,[[],[R[398]]]],[11,"kernel_data_segment",E,E,1,[[],[R[398]]]],[11,"user_code_32_segment",E,E,1,[[],[R[398]]]],[11,"user_data_32_segment",E,E,1,[[],[R[398]]]],[11,"user_code_64_segment",E,E,1,[[],[R[398]]]],[11,"user_data_64_segment",E,E,1,[[],[R[398]]]],[11,"tss_segment",E,E,1,[[["taskstatesegment"]],[R[398]]]],[11,"from",E,E,2,[[[T]],[T]]],[11,R[6],E,E,2,[[[U]],[R[1]]]],[11,"into",E,E,2,[[],[U]]],[11,R[7],E,E,2,[[],[R[1]]]],[11,R[8],E,E,2,[[["self"]],[T]]],[11,R[9],E,E,2,[[["self"]],[T]]],[11,R[11],E,E,2,[[["self"]],[R[14]]]],[11,R[176],E,E,2,[[["self"]],["string"]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[6],E,E,1,[[[U]],[R[1]]]],[11,"into",E,E,1,[[],[U]]],[11,R[7],E,E,1,[[],[R[1]]]],[11,R[8],E,E,1,[[["self"]],[T]]],[11,R[9],E,E,1,[[["self"]],[T]]],[11,R[11],E,E,1,[[["self"]],[R[14]]]],[11,"fmt",E,E,2,[[["self"],[R[12]]],[[R[1],["error"]],["error"]]]]],"p":[[4,R[399]],[4,R[400]],[3,"Gdt"]]};
searchIndex["heap"]={"doc":"The global allocator for the system. It starts off as a…","i":[[3,"Heap","heap","The heap which is used as a global allocator for the…",N,N],[5,"init_single_heap",E,"Initializes the single heap, which is the first heap used…",N,[[["usize"]]]],[5,"set_allocator",E,"Sets a new default allocator to be used by the global…",N,[[[R[286]],["box",[R[286]]]]]],[7,"GLOBAL_ALLOCATOR",E,E,N,N],[17,"HEAP_FLAGS",E,"The heap mapped pages should be writable",N,N],[11,"empty",E,"Returns a heap in which only an empty initial allocator…",0,[[],["heap"]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,"alloc",E,E,0,[[[R[0]],["self"]]]],[11,"dealloc",E,E,0,[[["self"],[R[0]]]]]],"p":[[3,"Heap"]]};
searchIndex["heapfile"]={"doc":"An implementation of in-memory files, backed by heap…","i":[[3,"HeapFile","heapfile","A file in memory that is backed by the heap, i.e., a `Vec`.",N,N],[11,"new",E,"Creates a new file with empty content in the given…",0,[[["string"],["dirref"]],[[R[1],[R[337],"str"]],["str"],[R[337]]]]],[11,"from_vec",E,"Creates a new `HeapFile` in the given `parent` directory…",0,[[["vec",["u8"]],["string"],["dirref"],["u8"]],[[R[1],[R[337],"str"]],["str"],[R[337]]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,R[338],E,E,0,[[["self"]],["string"]]],[11,R[330],E,E,0,[[["self"]],[["dirref"],[R[31],["dirref"]]]]],[11,R[331],E,E,0,[[["self"],[R[332]]]]],[11,"read",E,E,0,[[["usize"],["self"]],[["str"],["usize"],[R[1],["usize","str"]]]]],[11,"write",E,E,0,[[["self"],["usize"]],[["str"],["usize"],[R[1],["usize","str"]]]]],[11,"size",E,E,0,[[["self"]],["usize"]]],[11,R[339],E,E,0,[[["self"]],[["str"],[R[168]],[R[1],[R[168],"str"]]]]]],"p":[[3,"HeapFile"]]};
searchIndex["hpet"]={"doc":"Support for the x86 HPET: High Precision Event Timer.","i":[[3,"Hpet","hpet","A structure that offers access to HPET through its I/O…",N,N],[12,"general_capabilities_and_id",E,"The General Capabilities and ID Register, at offset 0x0.",0,N],[12,R[416],E,"The General Configuration Register, at offset 0x10.",0,N],[12,"general_interrupt_status",E,"The General Interrupt Status Register, at offset 0x20.",0,N],[12,"main_counter_value",E,"The Main Counter Value Register, at offset 0xF0.",0,N],[12,"timers",E,"The timers (comparators) available for separate. There is…",0,N],[3,R[369],E,"A structure that wraps HPET I/O register for each timer…",N,N],[12,"configuration_and_capability",E,"This timer's Configuration and Capability register.",1,N],[12,"comparator_value",E,"This timer's Comparator Value register.",1,N],[12,"fsb_interrupt_route",E,"This timer's FSB Interrupt Route register. Some info here:…",1,N],[3,R[370],E,"The structure of the HPET ACPI table.",N,N],[5,"get_hpet",E,"Returns a reference to the HPET timer structure, wrapped…",N,[[],[[R[365],[R[366]]],[R[31],[R[365]]]]]],[5,"get_hpet_mut",E,"Returns a mutable reference to the HPET timer structure,…",N,[[],[[R[367],[R[366]]],[R[31],[R[367]]]]]],[5,"handle",E,"The handler for parsing the HPET table and adding it to…",N,[[["usize"],[R[300]],[R[363]],[R[82]]],[[R[1],["str"]],["str"]]]],[17,"HPET_SIGNATURE",E,E,N,N],[11,"get_counter",E,"Returns the HPET's main counter value",0,[[["self"]],["u64"]]],[11,"enable_counter",E,"Turns on or off the main counter",0,[[["self"],["bool"]]]],[11,"counter_period_femtoseconds",E,"Returns the period of the HPET counter in femtoseconds,…",0,[[["self"]],["u32"]]],[11,R[371],E,E,0,[[["self"]],["u16"]]],[11,"num_timers",E,E,0,[[["self"]],["u8"]]],[11,"get",E,"Finds the HPET in the given `AcpiTables` and returns a…",2,[[[R[363]]],[[R[368]],[R[31],[R[368]]]]]],[11,"init_hpet",E,"Initializes the HPET counter-based timer based on the…",2,[[["self"],[R[170]]],[["rwlock"],[R[1],["rwlock","str"]],["str"]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[6],E,E,1,[[[U]],[R[1]]]],[11,"into",E,E,1,[[],[U]]],[11,R[7],E,E,1,[[],[R[1]]]],[11,R[8],E,E,1,[[["self"]],[T]]],[11,R[9],E,E,1,[[["self"]],[T]]],[11,R[11],E,E,1,[[["self"]],[R[14]]]],[11,"from",E,E,2,[[[T]],[T]]],[11,R[6],E,E,2,[[[U]],[R[1]]]],[11,"into",E,E,2,[[],[U]]],[11,R[7],E,E,2,[[],[R[1]]]],[11,R[8],E,E,2,[[["self"]],[T]]],[11,R[9],E,E,2,[[["self"]],[T]]],[11,R[11],E,E,2,[[["self"]],[R[14]]]]],"p":[[3,"Hpet"],[3,R[369]],[3,R[370]]]};
searchIndex["http_client"]={"doc":"Functions for creating and sending HTTP requests and…","i":[[3,R[755],"http_client","An HttpResponse that has been fully received from a remote…",N,N],[12,"packet",E,"The actual array of raw bytes received from the server,…",0,N],[12,"header_length",E,"The length of all headers",0,N],[12,"status_code",E,"The status code, e.g., 200, 404",0,N],[12,"reason",E,"The reason, e.g., \"OK\", \"File not found\"",0,N],[3,R[756],E,"A convenience struct that packages together a connected…",N,N],[5,"check_http_request",E,"Checks to see if the provided HTTP request can be properly…",N,[[],["bool"]]],[5,"send_request",E,"Sends the given HTTP request over the network via the…",N,[[[R[754]],["httprequest"],["u64"],[R[31],["u64"]]],[["str"],[R[1],[R[753],"str"]],[R[753]]]]],[6,"HttpRequest",E,"TODO: create a proper HttpRequest type with header…",N,N],[11,"header_bytes",E,E,0,[[["self"]]]],[11,"as_result",E,"Returns the content of this `HttpResponse` as a `Result`,…",0,[[["self"]],[R[1]]]],[11,"as_result_err_str",E,"A convenience function that just returns a standard Err…",0,[[["self"]],[["str"],[R[1],["str"]]]]],[11,"new",E,"Create a new `ConnectedTcpSocket` with the given necessary…",1,[[[R[757]],[R[723]],[R[724]]],[[R[754]],["str"],[R[1],[R[754],"str"]]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[6],E,E,1,[[[U]],[R[1]]]],[11,"into",E,E,1,[[],[U]]],[11,R[7],E,E,1,[[],[R[1]]]],[11,R[8],E,E,1,[[["self"]],[T]]],[11,R[9],E,E,1,[[["self"]],[T]]],[11,R[11],E,E,1,[[["self"]],[R[14]]]]],"p":[[3,R[755]],[3,R[756]]]};
searchIndex["intel_ethernet"]={"doc":"Definitions of descriptor types and type aliases for NIC…","i":[[0,"descriptors",R[316],"The different descriptor types used by Intel NICs. Usually…",N,N],[3,R[323],R[317],"This struct is a Legacy Transmit Descriptor. It's the…",N,N],[12,R[287],E,"The starting physical address of the transmit buffer",0,N],[12,"length",E,"Length of the transmit buffer in bytes",0,N],[12,"cso",E,"Checksum offset: where to insert the checksum from the…",0,N],[12,"cmd",E,"Command bits",0,N],[12,"status",E,"Status bits",0,N],[12,"css",E,"Checksum start: where to begin computing the checksum, if…",0,N],[12,"vlan",E,"Vlan tags ",0,N],[3,R[324],E,"This struct is a Legacy Receive Descriptor. The driver…",N,N],[12,R[287],E,"The starting physical address of the receive buffer",1,N],[12,"length",E,"Length of the receive buffer in bytes",1,N],[12,R[418],E,"Checksum value of the packet after the IP header till the…",1,N],[12,"status",E,"Status bits which tell if the descriptor has been used",1,N],[12,"errors",E,"Receive errors",1,N],[12,"vlan",E,"Vlan tags",1,N],[3,R[325],E,"Advanced Receive Descriptor used in the Ixgbe driver. It…",N,N],[12,"packet_buffer_address",E,R[314],2,N],[12,"header_buffer_address",E,R[314],2,N],[17,"TX_CMD_EOP",E,"Tx Command: End of Packet",N,N],[17,"TX_CMD_IFCS",E,"Tx Command: Insert FCS",N,N],[17,"TX_CMD_IC",E,"Tx Command: Insert Checksum",N,N],[17,"TX_CMD_RS",E,"Tx Command: Report Status",N,N],[17,"TX_CMD_RPS",E,"Tx Command: Report Packet Sent",N,N],[17,"TX_CMD_VLE",E,"Tx Command: VLAN Packet Enable",N,N],[17,"TX_CMD_IDE",E,"Tx Command: Interrupt Delay Enable",N,N],[17,"TX_STATUS_DD",E,"Tx Status: descriptor Done",N,N],[17,"RX_STATUS_DD",E,"Rx Status: Descriptor Done",N,N],[17,"RX_STATUS_EOP",E,"Rx Status: End of Packet",N,N],[8,R[326],E,"A trait for the minimum set of functions needed to receive…",N,N],[10,"init",E,"Initializes a receive descriptor by clearing its status…",3,[[[R[82]],["self"]]]],[10,R[318],E,"Updates the descriptor's physical address.",3,[[[R[82]],["self"]]]],[10,R[319],E,"Clears the status bits of the descriptor.",3,[[["self"]]]],[10,R[320],E,"Returns true if the descriptor has a received packet…",3,[[["self"]],["bool"]]],[10,R[321],E,"Returns true if the descriptor's packet buffer is the last…",3,[[["self"]],["bool"]]],[10,"length",E,"The length of the packet in the descriptor's packet buffer.",3,[[["self"]],["u64"]]],[8,R[327],E,"A trait for the minimum set of functions needed to…",N,N],[10,"init",E,"Initializes a transmit descriptor by clearing all of its…",4,[[["self"]]]],[10,"send",E,"Updates the transmit descriptor to send the packet. We…",4,[[[R[82]],["self"],["u16"]]]],[10,R[322],E,"Polls the Descriptor Done bit until the packet has been…",4,[[["self"]]]],[11,"get_rss_type",E,R[315],2,[[["self"]],["u64"]]],[11,"get_packet_type",E,R[315],2,[[["self"]],["u64"]]],[11,"get_rsccnt",E,R[315],2,[[["self"]],["u64"]]],[11,"get_hdr_len",E,R[315],2,[[["self"]],["u64"]]],[11,"get_sph",E,R[315],2,[[["self"]],["bool"]]],[11,"get_rss_hash",E,R[315],2,[[["self"]],["u64"]]],[11,"get_fdf_id",E,R[315],2,[[["self"]],["u64"]]],[11,"get_ext_status",E,R[315],2,[[["self"]],["u64"]]],[11,"get_ext_error",E,R[315],2,[[["self"]],["u64"]]],[11,"get_pkt_len",E,R[315],2,[[["self"]],["u64"]]],[11,"get_vlan_tag",E,R[315],2,[[["self"]],["u64"]]],[0,"types",R[316],"Type aliases for 32-bit registers that are used to…",N,N],[6,"Rdbal","intel_ethernet::types","Receive Descriptor Base Address Low Register",N,N],[6,"Rdbah",E,"Receive Descriptor Base Address High Register",N,N],[6,"Rdlen",E,"Receive Descriptor Length Register",N,N],[6,"Rdt",E,"Receive Descriptor Tail Register",N,N],[6,"Rdh",E,"Receive Descriptor Head Register",N,N],[6,"Tdbal",E,"Transmit Descriptor Base Address Low Register",N,N],[6,"Tdbah",E,"Transmit Descriptor Base Address High Register",N,N],[6,"Tdlen",E,"Transmit Descriptor Length Register",N,N],[6,"Tdt",E,"Transmit Descriptor Tail Register",N,N],[6,"Tdh",E,"Transmit Descriptor Head Register",N,N],[11,"from",R[317],E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[6],E,E,1,[[[U]],[R[1]]]],[11,"into",E,E,1,[[],[U]]],[11,R[7],E,E,1,[[],[R[1]]]],[11,R[8],E,E,1,[[["self"]],[T]]],[11,R[9],E,E,1,[[["self"]],[T]]],[11,R[11],E,E,1,[[["self"]],[R[14]]]],[11,"from",E,E,2,[[[T]],[T]]],[11,R[6],E,E,2,[[[U]],[R[1]]]],[11,"into",E,E,2,[[],[U]]],[11,R[7],E,E,2,[[],[R[1]]]],[11,R[8],E,E,2,[[["self"]],[T]]],[11,R[9],E,E,2,[[["self"]],[T]]],[11,R[11],E,E,2,[[["self"]],[R[14]]]],[11,"init",E,E,1,[[[R[82]],["self"]]]],[11,R[318],E,E,1,[[[R[82]],["self"]]]],[11,R[319],E,E,1,[[["self"]]]],[11,R[320],E,E,1,[[["self"]],["bool"]]],[11,R[321],E,E,1,[[["self"]],["bool"]]],[11,"length",E,E,1,[[["self"]],["u64"]]],[11,"init",E,E,2,[[[R[82]],["self"]]]],[11,R[318],E,E,2,[[[R[82]],["self"]]]],[11,R[319],E,E,2,[[["self"]]]],[11,R[320],E,E,2,[[["self"]],["bool"]]],[11,R[321],E,E,2,[[["self"]],["bool"]]],[11,"length",E,E,2,[[["self"]],["u64"]]],[11,"init",E,E,0,[[["self"]]]],[11,"send",E,E,0,[[[R[82]],["self"],["u16"]]]],[11,R[322],E,E,0,[[["self"]]]],[11,"fmt",E,E,0,[[["self"],[R[12]]],[R[1]]]],[11,"fmt",E,E,1,[[["self"],[R[12]]],[R[1]]]],[11,"fmt",E,E,2,[[["self"],[R[12]]],[R[1]]]]],"p":[[3,R[323]],[3,R[324]],[3,R[325]],[8,R[326]],[8,R[327]]]};
searchIndex["interrupts"]={"doc":"Basic interrupt handling structures and simple handler…","i":[[5,"is_exception_handler_with_error_code","interrupts","Returns `true` if the given address is the exception…",N,[[["u64"]],["bool"]]],[5,"init",E,"initializes the interrupt subsystem and properly sets up…",N,[[[R[81]]],[[R[1],[R[678],"str"]],[R[678]],["str"]]]],[5,"init_ap",E,"Similar to `init()`, but for APs to call after the BSP has…",N,[[[R[81]],["u8"]],[[R[1],[R[678],"str"]],[R[678]],["str"]]]],[5,"init_handlers_apic",E,E,N,[[]]],[5,"init_handlers_pic",E,E,N,[[]]],[5,"register_interrupt",E,"Registers an interrupt handler. The function fails if the…",N,[[[R[679]],["u8"]],[[R[1],["str"]],["str"]]]],[5,"register_msi_interrupt",E,"Returns an interrupt number assigned by the OS and sets…",N,[[[R[679]]],[[R[1],["u8","str"]],["str"],["u8"]]]],[5,"deregister_interrupt",E,"Returns an interrupt to the system by setting the handler…",N,[[[R[679]],["u8"]],[[R[1],["str"]],["str"]]]],[5,"eoi",E,"Send an end of interrupt signal, which works for all types…",N,[[[R[31],["u8"]],["u8"]]]],[7,"IDT",E,"The single system-wide IDT Note: this could be per-core…",N,N],[7,"APIC_TIMER_TICKS",E,E,N,N]],"p":[]};
searchIndex["ioapic"]={"doc":E,"i":[[3,"IoApic","ioapic","A representation of an IoApic (x86-specific interrupt chip…",N,N],[12,"id",E,"The ID of this IoApic.",0,N],[5,"get_ioapics",E,"Returns a reference to the list of IoApics.",N,[[],[R[313]]]],[5,"get_ioapic",E,"If an `IoApic` with the given `id` exists, then lock it…",N,[[["u8"]],[[R[31],[R[250]]],[R[250],["ioapic"]]]]],[5,"get_first_ioapic",E,"Returns the first `IoApic` that was created, if any, after…",N,[[],[[R[31],[R[250]]],[R[250],["ioapic"]]]]],[11,"new",E,"Creates a new IoApic struct from the given `id`,…",0,[[["u32"],[R[170]],[R[82]],["u8"]],[[R[1],["str"]],["str"]]]],[11,"handles_irq",E,"Returns whether this IoApic handles the given `irq_num`,…",0,[[["u32"],["self"]],["bool"]]],[11,"id",E,"gets this IoApic's id.",0,[[["self"]],["u32"]]],[11,"version",E,"gets this IoApic's version.",0,[[["self"]],["u32"]]],[11,"arbitration_id",E,"gets this IoApic's arbitration id.",0,[[["self"]],["u32"]]],[11,"mask_irq",E,"Masks (disables) the given IRQ line. NOTE: this function…",0,[[["self"],["u8"]]]],[11,"set_irq",E,"Set IRQ to an interrupt vector. # Arguments ioapic_irq:…",0,[[["self"],["u8"]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]]],"p":[[3,"IoApic"]]};
searchIndex["kernel_config"]={"doc":E,"i":[[0,"memory",R[3],"WARNING: DO NOT USE ANY ADDRESS THAT MAPS TO THE SAME P4…",N,N],[17,"BYTES_PER_ADDR","kernel_config::memory","64-bit architecture results in 8 bytes per address.",N,N],[17,"PAGE_SHIFT",E,"The lower 12 bits of a virtual address correspond to the…",N,N],[17,"PAGE_SIZE",E,"Page size is 4096 bytes, 4KiB pages.",N,N],[17,"P1_INDEX_SHIFT",E,"Value: 0. Shift the Page number (not the address!) by this…",N,N],[17,"P2_INDEX_SHIFT",E,"Value: 9. Shift the Page number (not the address!) by this…",N,N],[17,"P3_INDEX_SHIFT",E,"Value: 18. Shift the Page number (not the address!) by…",N,N],[17,"P4_INDEX_SHIFT",E,"Value: 27. Shift the Page number (not the address!) by…",N,N],[17,"ADDRESSABILITY_PER_P4_ENTRY",E,"Value: 512 GiB.",N,N],[17,"MAX_VIRTUAL_ADDRESS",E,E,N,N],[17,"TEMPORARY_PAGE_VIRT_ADDR",E,E,N,N],[17,"ENTRIES_PER_PAGE_TABLE",E,"Value: 512. ",N,N],[17,"KERNEL_TEXT_P4_INDEX",E,"Value: 511. The 511th entry is used for kernel text sections",N,N],[17,"RECURSIVE_P4_INDEX",E,"Value: 510. The 510th entry is used for the recursive P4…",N,N],[17,"KERNEL_HEAP_P4_INDEX",E,"Value: 509. The 509th entry is used for the kernel heap",N,N],[17,"KERNEL_STACK_P4_INDEX",E,"Value: 508. The 508th entry is used for all kernel stacks",N,N],[17,"USER_STACK_P4_INDEX",E,"Value: 507. The 507th entry is used for all userspace stacks",N,N],[17,"MAX_PAGE_NUMBER",E,E,N,N],[17,"KERNEL_STACK_SIZE_IN_PAGES",E,"The size in pages of each kernel stack. If it's too small,…",N,N],[17,"KERNEL_OFFSET",E,"The virtual address where the initial kernel (the…",N,N],[17,"KERNEL_TEXT_START",E,"The kernel text region is where we load kernel modules. It…",N,N],[17,"KERNEL_TEXT_MAX_SIZE",E,"The size in bytes, not in pages.",N,N],[17,"KERNEL_HEAP_START",E,"higher-half heap gets 512 GB address range starting at the…",N,N],[17,"KERNEL_HEAP_INITIAL_SIZE",E,E,N,N],[17,"KERNEL_HEAP_MAX_SIZE",E,"the kernel heap gets the whole 509th P4 entry.",N,N],[17,"KERNEL_STACK_ALLOCATOR_BOTTOM",E,"the kernel stack allocator gets the 508th P4 entry of…",N,N],[17,"KERNEL_STACK_ALLOCATOR_TOP_ADDR",E,"the highest actually usuable address in the kernel stack…",N,N],[17,"USER_STACK_ALLOCATOR_BOTTOM",E,"the userspace stack allocators (one per userspace task)…",N,N],[17,"USER_STACK_ALLOCATOR_TOP_ADDR",E,"the highest actually usuable address in each userspace…",N,N],[0,"time",R[3],E,N,N],[17,"CONFIG_PIT_FREQUENCY_HZ","kernel_config::time","the chosen interrupt frequency (in Hertz) of the PIT clock ",N,N],[17,"CONFIG_RTC_FREQUENCY_HZ",E,"the chosen interrupt frequency (in Hertz) of the RTC.…",N,N],[17,"CONFIG_TIMESLICE_PERIOD_MICROSECONDS",E,"The timeslice period, specified in microseconds.",N,N],[17,"CONFIG_HEARTBEAT_PERIOD_MS",E,"the heartbeat period in milliseconds",N,N]],"p":[]};
searchIndex["keyboard"]={"doc":E,"i":[[5,"init","keyboard","Initialize the keyboard driver. Arguments: a reference to…",N,[[["queue",["event"]],["event"]]]],[5,"handle_keyboard_input",E,"returns Ok(()) if everything was handled properly.…",N,[[["bool"],["u8"]],[[R[1],["str"]],["str"]]]]],"p":[]};
searchIndex["libterm"]={"doc":"A basic terminal emulator library.","i":[[3,"Terminal","libterm","An instance of a graphical terminal emulator.",N,N],[12,"window",E,"The terminal's own window.",0,N],[12,"cursor",E,"The cursor of the terminal.",0,N],[4,R[794],E,"Error type for tracking different scroll errors that a…",N,N],[13,"OffEndBound",E,"Occurs when a index-calculation returns an index that is…",1,N],[0,"cursor",E,E,N,N],[3,"Cursor",R[793],"The cursor structure used in the terminal. A cursor is a…",N,N],[12,R[791],E,"The position of the cursor relative to the end of terminal…",2,N],[12,R[792],E,"The underlying character at the position of the cursor. It…",2,N],[11,"reset",E,"Reset the state of the cursor as unseen",2,[[["self"]]]],[11,"enable",E,"Enable a cursor",2,[[["self"]]]],[11,"disable",E,"Disable a cursor",2,[[["self"]]]],[11,"blink",E,"Let a cursor blink. It is invoked in a loop.",2,[[["self"]],["bool"]]],[11,"show",E,"Whether a cursor is seen",2,[[["self"]],["bool"]]],[11,"display",E,"Display a cursor in a framebuffer # Arguments *…",2,[[["usize"],["coord"],[R[763]],["self"]],[[R[1],[R[15],"str"]],[R[15]],["str"]]]],[11,"set_offset_from_end",E,"Sets the position of the cursor relative to the end of the…",2,[[["self"],["usize"]]]],[11,R[791],E,"Gets the position of the cursor relative to the end of the…",2,[[["self"]],["usize"]]],[11,"set_underlying_char",E,"Sets the character at the position of the cursor",2,[[["self"],["u8"]]]],[11,R[792],E,"Gets the character at the position of the cursor",2,[[["self"]],["u8"]]],[17,"FONT_FOREGROUND_COLOR","libterm",E,N,N],[17,"FONT_BACKGROUND_COLOR",E,E,N,N],[11,"get_text_dimensions",E,"Gets the width and height of the text displayable in…",0,[[["self"]]]],[11,"new",E,"Creates a new terminal and adds it to the window manager…",0,[[],[["terminal"],["str"],[R[1],["terminal","str"]]]]],[11,"print_to_terminal",E,"Adds a string to be printed to the terminal to the…",0,[[["self"],["string"]]]],[11,"refresh_display",E,"Actually refresh the screen. Currently it's expensive.",0,[[["self"]],[[R[1],["str"]],["str"]]]],[11,"insert_char",E,"Insert a character to the terminal.",0,[[["self"],["char"],["usize"]],[[R[1],["str"]],["str"]]]],[11,"remove_char",E,"Remove a character from the terminal.",0,[[["self"],["usize"]],[[R[1],["str"]],["str"]]]],[11,"move_screen_to_begin",E,"Scroll the screen to the very beginning.",0,[[["self"]],[[R[1],["str"]],["str"]]]],[11,"move_screen_to_end",E,"Scroll the screen to the very end.",0,[[["self"]],[[R[1],["str"]],["str"]]]],[11,"move_screen_line_up",E,"Scroll the screen a line up.",0,[[["self"]],[[R[1],["str"]],["str"]]]],[11,"move_screen_line_down",E,"Scroll the screen a line down.",0,[[["self"]],[[R[1],["str"]],["str"]]]],[11,"move_screen_page_up",E,"Scroll the screen a page up.",0,[[["self"]],[[R[1],["str"]],["str"]]]],[11,"move_screen_page_down",E,"Scroll the screen a page down.",0,[[["self"]],[[R[1],["str"]],["str"]]]],[11,"clear",E,"Clear the scrollback buffer and reset the scroll positions.",0,[[["self"]]]],[11,"get_event",E,"Gets an event from the window's event queue.",0,[[["self"]],[[R[31],["event"]],["event"]]]],[11,"display_cursor",E,"Display the cursor of the terminal.",0,[[["self"]],[[R[1],["str"]],["str"]]]],[11,"get_cursor_offset_from_end",E,"Gets the position of the cursor relative to the end of…",0,[[["self"]],["usize"]]],[11,"update_cursor_pos",E,"Updates the position of a cursor. # Arguments *…",0,[[["self"],["usize"],["u8"]]]],[11,"resize",E,"Resizes this terminal and its underlying text display and…",0,[[["self"],[R[15]]],[[R[1],["str"]],["str"]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[6],E,E,1,[[[U]],[R[1]]]],[11,"into",E,E,1,[[],[U]]],[11,R[7],E,E,1,[[],[R[1]]]],[11,R[8],E,E,1,[[["self"]],[T]]],[11,R[9],E,E,1,[[["self"]],[T]]],[11,R[11],E,E,1,[[["self"]],[R[14]]]],[11,"from",R[793],E,2,[[[T]],[T]]],[11,R[6],E,E,2,[[[U]],[R[1]]]],[11,"into",E,E,2,[[],[U]]],[11,R[7],E,E,2,[[],[R[1]]]],[11,R[8],E,E,2,[[["self"]],[T]]],[11,R[9],E,E,2,[[["self"]],[T]]],[11,R[11],E,E,2,[[["self"]],[R[14]]]],[11,R[38],E,E,2,[[],["self"]]]],"p":[[3,"Terminal"],[4,R[794]],[3,"Cursor"]]};
searchIndex["libtest"]={"doc":E,"i":[[3,"Stats","libtest",E,N,N],[12,"min",E,E,0,N],[12,"p_25",E,E,0,N],[12,"median",E,E,0,N],[12,"p_75",E,E,0,N],[12,"max",E,E,0,N],[12,"mode",E,E,0,N],[12,"mean",E,E,0,N],[12,"std_dev",E,E,0,N],[5,"hpet_2_ns",E,"Helper function to convert ticks to nano seconds",N,[[["u64"]],["u64"]]],[5,"hpet_2_us",E,"Helper function to convert ticks to micro seconds",N,[[["u64"]],["u64"]]],[5,"nr_tasks_in_rq",E,"Helper function return the tasks in a given core's runqueue",N,[[["u8"]],[[R[31],["usize"]],["usize"]]]],[5,"check_myrq",E,"True if only two tasks are running in the current…",N,[[],["bool"]]],[5,"pick_free_core",E,"Helper function to pick a free child core if possible",N,[[],[[R[1],["u8","str"]],["str"],["u8"]]]],[5,"start_counting_reference_cycles",E,"Starts the PMU counter to measure reference cycles. The…",N,[[],[[R[1],["counter","str"]],["str"],["counter"]]]],[5,"stop_counting_reference_cycles",E,"Stops the PMU counter and stores the reference cycles…",N,[[["counter"]],[["str"],["u64"],[R[1],["u64","str"]]]]],[5,"cycle_count_overhead",E,"Measures the overhead of using the PMU reference cycles…",N,[[],[["str"],["u64"],[R[1],["u64","str"]]]]],[5,"hpet_timing_overhead",E,"Measures the overhead of using the hpet timer. Calls…",N,[[],[["str"],["u64"],[R[1],["u64","str"]]]]],[5,"calculate_stats",E,"Helper function to calculate statistics of a provided…",N,[[["vec"]],[["stats"],[R[31],["stats"]]]]],[17,"THRESHOLD_ERROR_RATIO",E,E,N,N],[14,"CPU_ID",E,E,N,N],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,"fmt",E,E,0,[[["self"],[R[12]]],[R[1]]]]],"p":[[3,"Stats"]]};
searchIndex["logger"]={"doc":E,"i":[[4,R[78],"logger","See ANSI terminal formatting schemes",N,N],[13,"Black",E,E,0,N],[13,"Red",E,E,0,N],[13,"Green",E,E,0,N],[13,"Yellow",E,E,0,N],[13,"Blue",E,E,0,N],[13,"Purple",E,E,0,N],[13,"Cyan",E,E,0,N],[13,"White",E,E,0,N],[13,"Reset",E,E,0,N],[5,"mirror_to_vga",E,"Call this to enable mirroring logging macros to the screen",N,[[["logoutputfunc"]]]],[5,"init",E,"Initialize the Theseus system logger, which writes log…",N,[[],[[R[77]],[R[1],[R[77]]]]]],[5,"set_log_level",E,"Set the log level, which determines whether a given log…",N,[[["level"]]]],[6,"LogOutputFunc",E,E,N,N],[11,"as_terminal_string",E,E,0,[[["self"]],["str"]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]]],"p":[[4,R[78]]]};
searchIndex["madt"]={"doc":"Support for the MADT ACPI table, which includes interrupt…","i":[[3,"Madt","madt","A wrapper around the MADT ACPI table (Multiple APIC…",N,N],[3,"MadtIter",E,"An Iterator over the dynamic entries of the MADT. Its…",N,N],[3,R[381],E,"MADT Local APIC",N,N],[12,R[379],E,"Processor ID",0,N],[12,"apic_id",E,"Local APIC ID",0,N],[12,"flags",E,"Flags. 1 means that the processor is enabled",0,N],[3,R[382],E,"MADT I/O APIC",N,N],[12,"id",E,"I/O APIC ID",1,N],[12,"address",E,"I/O APIC address",1,N],[12,"gsi_base",E,"Global system interrupt base",1,N],[3,R[383],E,"MADT Interrupt Source Override",N,N],[12,"bus_source",E,"Bus Source",2,N],[12,"irq_source",E,"IRQ Source",2,N],[12,"gsi",E,"Global system interrupt",2,N],[12,"flags",E,"Flags",2,N],[3,R[384],E,"MADT Non-maskable Interrupt. Use these to configure the…",N,N],[12,R[379],E,"which processor this is for, 0xFF means all processors",3,N],[12,"flags",E,"Flags",3,N],[12,"lint",E,"LINT (either 0 or 1)",3,N],[3,R[385],E,"MADT Local APIC Address Override. If this struct exists,…",N,N],[12,R[287],E,"Local APIC physical address",4,N],[4,R[386],E,"The set of possible MADT Entries.",N,N],[13,R[309],E,"A Local APIC MADT entry.",5,N],[13,"IoApic",E,"A IOAPIC MADT entry.",5,N],[13,"IntSrcOverride",E,"A Interrupt Source Override MADT entry.",5,N],[13,"NonMaskableInterrupt",E,"A Non-Maskable Interrupt MADT entry.",5,N],[13,"LocalApicAddressOverride",E,"A Local APIC Address Override MADT entry.",5,N],[13,"UnknownOrCorrupt",E,"The MADT table had an entry of an unknown type or…",5,N],[5,"handle",E,"The handler for parsing the MADT table and adding it to…",N,[[["usize"],[R[300]],[R[363]],[R[82]]],[[R[1],["str"]],["str"]]]],[5,"find_nmi_entry_for_processor",E,"Finds the Non-Maskable Interrupt (NMI) entry in the MADT…",N,[[[R[380]],["u8"]]]],[17,"MADT_SIGNATURE",E,E,N,N],[11,"get",E,"Finds the MADT in the given `AcpiTables` and returns a…",6,[[[R[363]]],[[R[31],["madt"]],["madt"]]]],[11,"bsp_init",E,"Performs initialization functions of the IOAPIC and…",6,[[["self"],[R[170]]],[[R[1],["str"]],["str"]]]],[11,"iter",E,"Returns an iterator over the MADT's entries, which are…",6,[[["self"]],[R[380]]]],[11,"sdt",E,"Returns a reference to the `Sdt` header in this MADT table.",6,[[["self"]],["sdt"]]],[11,"local_apic_phys_addr",E,"Returns the Local APIC physical address value in this MADT…",6,[[["self"]],["u32"]]],[11,"flags",E,"Returns the `flags` value in this MADT table.",6,[[["self"]],["u32"]]],[11,"from",E,E,6,[[[T]],[T]]],[11,R[6],E,E,6,[[[U]],[R[1]]]],[11,"into",E,E,6,[[],[U]]],[11,R[7],E,E,6,[[],[R[1]]]],[11,R[8],E,E,6,[[["self"]],[T]]],[11,R[9],E,E,6,[[["self"]],[T]]],[11,R[11],E,E,6,[[["self"]],[R[14]]]],[11,"from",E,E,7,[[[T]],[T]]],[11,R[6],E,E,7,[[[U]],[R[1]]]],[11,R[91],E,E,7,[[],["i"]]],[11,"into",E,E,7,[[],[U]]],[11,R[7],E,E,7,[[],[R[1]]]],[11,R[8],E,E,7,[[["self"]],[T]]],[11,R[9],E,E,7,[[["self"]],[T]]],[11,R[11],E,E,7,[[["self"]],[R[14]]]],[11,R[64],E,E,7,[[["self"]],[T]]],[11,R[65],E,E,7,[[["self"],[T]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,R[64],E,E,0,[[["self"]],[T]]],[11,R[65],E,E,0,[[["self"],[T]]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[6],E,E,1,[[[U]],[R[1]]]],[11,"into",E,E,1,[[],[U]]],[11,R[7],E,E,1,[[],[R[1]]]],[11,R[8],E,E,1,[[["self"]],[T]]],[11,R[9],E,E,1,[[["self"]],[T]]],[11,R[11],E,E,1,[[["self"]],[R[14]]]],[11,R[64],E,E,1,[[["self"]],[T]]],[11,R[65],E,E,1,[[["self"],[T]]]],[11,"from",E,E,2,[[[T]],[T]]],[11,R[6],E,E,2,[[[U]],[R[1]]]],[11,"into",E,E,2,[[],[U]]],[11,R[7],E,E,2,[[],[R[1]]]],[11,R[8],E,E,2,[[["self"]],[T]]],[11,R[9],E,E,2,[[["self"]],[T]]],[11,R[11],E,E,2,[[["self"]],[R[14]]]],[11,R[64],E,E,2,[[["self"]],[T]]],[11,R[65],E,E,2,[[["self"],[T]]]],[11,"from",E,E,3,[[[T]],[T]]],[11,R[6],E,E,3,[[[U]],[R[1]]]],[11,"into",E,E,3,[[],[U]]],[11,R[7],E,E,3,[[],[R[1]]]],[11,R[8],E,E,3,[[["self"]],[T]]],[11,R[9],E,E,3,[[["self"]],[T]]],[11,R[11],E,E,3,[[["self"]],[R[14]]]],[11,R[64],E,E,3,[[["self"]],[T]]],[11,R[65],E,E,3,[[["self"],[T]]]],[11,"from",E,E,4,[[[T]],[T]]],[11,R[6],E,E,4,[[[U]],[R[1]]]],[11,"into",E,E,4,[[],[U]]],[11,R[7],E,E,4,[[],[R[1]]]],[11,R[8],E,E,4,[[["self"]],[T]]],[11,R[9],E,E,4,[[["self"]],[T]]],[11,R[11],E,E,4,[[["self"]],[R[14]]]],[11,R[64],E,E,4,[[["self"]],[T]]],[11,R[65],E,E,4,[[["self"],[T]]]],[11,"from",E,E,5,[[[T]],[T]]],[11,R[6],E,E,5,[[[U]],[R[1]]]],[11,"into",E,E,5,[[],[U]]],[11,R[7],E,E,5,[[],[R[1]]]],[11,R[8],E,E,5,[[["self"]],[T]]],[11,R[9],E,E,5,[[["self"]],[T]]],[11,R[11],E,E,5,[[["self"]],[R[14]]]],[11,R[64],E,E,5,[[["self"]],[T]]],[11,R[65],E,E,5,[[["self"],[T]]]],[11,"fmt",E,E,5,[[[R[12]],["self"]],[R[1]]]],[11,"fmt",E,E,0,[[[R[12]],["self"]],[R[1]]]],[11,"fmt",E,E,1,[[[R[12]],["self"]],[R[1]]]],[11,"fmt",E,E,2,[[[R[12]],["self"]],[R[1]]]],[11,"fmt",E,E,3,[[[R[12]],["self"]],[R[1]]]],[11,"fmt",E,E,4,[[[R[12]],["self"]],[R[1]]]],[11,"next",E,E,7,[[["self"]],[R[31]]]],[11,"clone",E,E,7,[[["self"]],[R[380]]]],[11,"clone",E,E,5,[[["self"]],["madtentry"]]],[11,"clone",E,E,0,[[["self"]],["madtlocalapic"]]],[11,"clone",E,E,1,[[["self"]],["madtioapic"]]],[11,"clone",E,E,2,[[["self"]],["madtintsrcoverride"]]],[11,"clone",E,E,3,[[["self"]],["madtnonmaskableinterrupt"]]],[11,"clone",E,E,4,[[["self"]],["madtlocalapicaddressoverride"]]]],"p":[[3,R[381]],[3,R[382]],[3,R[383]],[3,R[384]],[3,R[385]],[4,R[386]],[3,"Madt"],[3,"MadtIter"]]};
searchIndex["mapper_spillful"]={"doc":E,"i":[],"p":[]};
searchIndex["memfs"]={"doc":"This crate contains an implementation of an in-memory…","i":[[3,"MemFile","memfs","The struct that represents a file in memory that is backed…",N,N],[11,"new",E,"Allocates writable memory space for the given `contents`…",0,[[["string"],["dirref"]],[[R[337]],[R[1],[R[337],"str"]],["str"]]]],[11,"from_mapped_pages",E,"Creates a new `MemFile` in the given `parent` directory…",0,[[["string"],["usize"],["dirref"],[R[168]]],[[R[337]],[R[1],[R[337],"str"]],["str"]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,R[338],E,E,0,[[["self"]],["string"]]],[11,R[330],E,E,0,[[["self"]],[[R[31],["dirref"]],["dirref"]]]],[11,R[331],E,E,0,[[["self"],[R[332]]]]],[11,"read",E,E,0,[[["usize"],["self"]],[["str"],["usize"],[R[1],["usize","str"]]]]],[11,"write",E,E,0,[[["self"],["usize"]],[["str"],["usize"],[R[1],["usize","str"]]]]],[11,"size",E,E,0,[[["self"]],["usize"]]],[11,R[339],E,E,0,[[["self"]],[[R[1],[R[168],"str"]],[R[168]],["str"]]]]],"p":[[3,"MemFile"]]};
searchIndex["memory"]={"doc":"This crate implements the virtual memory subsystem for…","i":[[3,R[108],"memory",R[188],N,N],[3,R[109],E,R[189],N,N],[3,R[105],E,R[190],N,N],[12,R[191],E,E,0,N],[12,R[90],E,E,0,N],[12,"typ",E,E,0,N],[12,"acpi",E,E,0,N],[3,"Frame",E,R[192],N,N],[12,"number",E,E,1,N],[3,R[110],E,R[193],N,N],[3,"Page",E,R[194],N,N],[3,R[111],E,R[195],N,N],[3,R[106],E,R[196],N,N],[12,"start",E,R[197],2,N],[12,"end",E,R[198],2,N],[12,"flags",E,R[199],2,N],[3,R[107],E,R[200],N,N],[12,"text",E,E,3,N],[12,"rodata",E,E,3,N],[12,"data",E,E,3,N],[3,R[60],E,R[112],N,N],[3,R[183],E,"A frame allocator that uses the memory areas from the…",N,N],[3,"Entry",E,"A page table entry, which is a `u64` value under the hood.…",N,N],[3,R[184],E,"A Page that can be temporarily mapped to the recursive…",N,N],[3,"Mapper",E,E,N,N],[12,"target_p4",E,"The Frame contaning the top-level P4 page table.",4,N],[3,R[185],E,"Represents a contiguous range of virtual memory pages that…",N,N],[3,R[180],E,"Represents an allocated range of virtual addresses,…",N,N],[12,"pages",E,E,5,N],[3,R[186],E,"A root (P4) page table.",N,N],[3,R[181],E,E,N,N],[12,"range",E,E,6,N],[12,"usermode",E,E,6,N],[3,"Stack",E,E,N,N],[3,R[182],E,"This holds all the information for a `Task`'s memory…",N,N],[12,"page_table",E,"the PageTable that should be switched to when this Task is…",7,N],[12,"extra_mapped_pages",E,"a list of additional virtual-mapped Pages that have the…",7,N],[5,"allocate_pages_by_bytes",E,"Convenience function for allocating pages by giving the…",N,[[["usize"]],[[R[31],[R[166]]],[R[166]]]]],[5,"allocate_pages",E,"Allocates the given number of pages, but simply reserves…",N,[[["usize"]],[[R[31],[R[166]]],[R[166]]]]],[5,"get_current_p4",E,"Returns the current top-level page table frame",N,[[],["frame"]]],[5,"get_kernel_mmi_ref",E,"Returns a cloned reference to the kernel's…",N,[[],[[R[31],["mmiref"]],["mmiref"]]]],[5,"get_frame_allocator_ref",E,"Returns a reference to the system-wide `FrameAllocator`,…",N,[[],[[R[31],[R[167]]],[R[167]]]]],[5,R[173],E,"Convenience method for allocating a new Frame.",N,[[],[["frame"],[R[31],["frame"]]]]],[5,R[174],E,"Convenience method for allocating several contiguous Frames.",N,[[["usize"]],[[R[31],[R[85]]],[R[85]]]]],[5,"create_contiguous_mapping",E,"A convenience function that creates a new memory mapping…",N,[[["usize"],[R[57]]],[[R[1],["str"]],["str"]]]],[5,"create_mapping",E,"A convenience function that creates a new memory mapping.…",N,[[["usize"],[R[57]]],[[R[168]],["str"],[R[1],[R[168],"str"]]]]],[5,"set_broadcast_tlb_shootdown_cb",E,"Set the function callback that will be invoked every time…",N,[[]]],[5,"init",E,"Initializes the virtual memory management system. Consumes…",N,[[[R[113]]],[["str"],[R[1],["str"]]]]],[5,"init_post_heap",E,"Finishes Initializing the virtual memory management system…",N,[[[R[170]],[R[168]]],[[R[1],["str"]],["str"]]]],[11,"new",E,E,8,[[["usize"]],[[R[1],[R[169],"str"]],["str"],[R[169]]]]],[11,"add_area",E,"`available`: specifies whether the given `area` is an…",8,[[["self"],[R[104]],["bool"]],[[R[1],["str"]],["str"]]]],[11,"new",E,"Create a new `StackAllocator` that allocates random frames…",6,[[[R[89]],["bool"]],["stackallocator"]]],[11,R[175],E,"Allocates a new stack and maps it to the active page…",6,[[["usize"],[R[167]],["mapper"],["self"]],[["stack"],[R[31],["stack"]]]]],[11,"new",E,E,9,[[[R[168]],[R[81]]],["stack"]]],[11,"top_unusable",E,"the top of this Stack. This address is not…",9,[[["self"]],[R[81]]]],[11,"top_usable",E,"Returns the highest usable address of this Stack, which is…",9,[[["self"]],[R[81]]]],[11,"bottom",E,E,9,[[["self"]],[R[81]]]],[11,"size",E,E,9,[[["self"]],["usize"]]],[11,R[86],E,"Returns the start address of the first page. ",5,[[["self"]],[R[81]]]],[11,R[179],E,E,5,[[["self"]],["usize"]]],[11,"is_unused",E,E,10,[[["self"]],["bool"]]],[11,"set_unused",E,E,10,[[["self"]]]],[11,"flags",E,E,10,[[["self"]],[R[57]]]],[11,"pointed_frame",E,E,10,[[["self"]],[["frame"],[R[31],["frame"]]]]],[11,"set",E,E,10,[[["self"],["frame"],[R[57]]]]],[11,"copy",E,E,10,[[["self"]],["entry"]]],[11,"value",E,E,10,[[["self"]],["u64"]]],[11,"new",E,"Creates a new [`TemporaryPage`] but does not yet map it to…",11,[[],[R[172]]]],[11,"map_table_frame",E,"Maps the temporary page to the given page table frame in…",11,[[["self"],["frame"],[R[170]]],[["table"],["str"],[R[1],["table","str"]]]]],[11,"from_current",E,E,4,[[],["mapper"]]],[11,"with_p4_frame",E,E,4,[[["frame"]],["mapper"]]],[11,"p4",E,E,4,[[["self"]],["table"]]],[11,"p4_mut",E,E,4,[[["self"]],["table"]]],[11,"dump_pte",E,"Dumps all page table entries at all four levels for the…",4,[[["self"],[R[81]]]]],[11,"translate",E,"Translates a `VirtualAddress` to a `PhysicalAddress` by…",4,[[["self"],[R[81]]],[[R[82]],[R[31],[R[82]]]]]],[11,"translate_page",E,"Translates a virtual memory `Page` to a physical memory…",4,[[["page"],["self"]],[["frame"],[R[31],["frame"]]]]],[11,"map_to",E,"creates a mapping for a specific page -> specific frame",4,[[["a"],["page"],["self"],["frame"],[R[57]]],[[R[168]],["str"],[R[1],[R[168],"str"]]]]],[11,"map",E,"maps the given Page to a randomly selected (newly…",4,[[["a"],["page"],["self"],[R[57]]],[[R[168]],["str"],[R[1],[R[168],"str"]]]]],[11,"map_pages",E,"maps the given `Page`s to a randomly selected (newly…",4,[[[R[89]],["a"],["self"],[R[57]]],[[R[168]],["str"],[R[1],[R[168],"str"]]]]],[11,"map_frames",E,"maps the given contiguous range of Frames `frame_range` to…",4,[[["a"],[R[85]],["page"],["self"],[R[57]]],[[R[168]],["str"],[R[1],[R[168],"str"]]]]],[11,"map_allocated_pages_to",E,"maps the given `AllocatedPages` to the given actual…",4,[[["a"],[R[85]],[R[166]],["self"],[R[57]]],[[R[168]],["str"],[R[1],[R[168],"str"]]]]],[11,"map_allocated_pages",E,"maps the given `AllocatedPages` to randomly chosen…",4,[[["a"],[R[166]],["self"],[R[57]]],[[R[168]],["str"],[R[1],[R[168],"str"]]]]],[11,"empty",E,"Returns an empty MappedPages object that performs no…",12,[[],[R[168]]]],[11,"flags",E,"Returns the flags that describe this `MappedPages` page…",12,[[["self"]],[R[57]]]],[11,"from_existing",E,"Constructs a MappedPages object from an already existing…",12,[[[R[89]],[R[57]]],[R[168]]]],[11,"merge",E,"Merges the given `MappedPages` object into this…",12,[[["self"],[R[168]]],[R[1]]]],[11,"deep_copy",E,"Creates a deep copy of this `MappedPages` memory region,…",12,[[[R[57]],["a"],["mapper"],["self"],[R[31],[R[57]]]],[[R[168]],["str"],[R[1],[R[168],"str"]]]]],[11,"remap",E,"Change the permissions (`new_flags`) of this…",12,[[["mapper"],["self"],[R[57]]],[[R[1],["str"]],["str"]]]],[11,"as_type",E,R[171],12,[[["self"],["usize"]],[[T],[R[1],["str"]],["str"]]]],[11,"as_type_mut",E,"Same as `as_type()`, but returns a mutable reference to…",12,[[["self"],["usize"]],[["str"],[R[1],["str"]],[T]]]],[11,"as_slice",E,R[171],12,[[["self"],["usize"]],[["str"],[R[1],["str"]]]]],[11,"as_slice_mut",E,"Same as `as_slice()`, but returns a mutable slice. ",12,[[["self"],["usize"]],[["str"],[R[1],["str"]]]]],[11,"as_func",E,R[171],12,[[["usize"],["self"],["usize"]],[["f"],["str"],[R[1],["str"]]]]],[11,"new_table",E,"Initializes a brand new top-level P4 `PageTable`…",13,[[[R[170]],["frame"],[R[172]]],[[R[170]],["str"],[R[1],[R[170],"str"]]]]],[11,"with",E,"Temporarily maps the given other `PageTable` to the…",13,[[[R[172]],["self"],[R[170]],["f"]],[[R[1],["str"]],["str"]]]],[11,"switch",E,"Switches from the currently-active page table (this…",13,[[["self"],[R[170]]],[R[170]]]],[11,R[761],E,"Returns the physical address of this page table's…",13,[[["self"]],[R[82]]]],[6,"MmiRef",E,"A shareable reference to a `MemoryManagementInfo` struct…",N,N],[6,"FrameAllocatorRef",E,"A shareable reference to a `FrameAllocator` struct wrapper…",N,N],[7,"BROADCAST_TLB_SHOOTDOWN_FUNC",E,E,N,N],[8,R[187],E,E,N,N],[10,R[173],E,E,14,[[["self"]],[["frame"],[R[31],["frame"]]]]],[10,R[174],E,E,14,[[["self"],["usize"]],[[R[31],[R[85]]],[R[85]]]]],[10,R[177],E,E,14,[[["self"],["frame"]]]],[10,R[178],E,"Call this when a heap is set up, and the `alloc` types can…",14,[[["self"]]]],[11,R[175],E,"Allocates a new stack in the currently-running Task's…",7,[[["self"],["usize"]],[["stack"],[R[31],["stack"]]]]],[11,"from",E,E,15,[[[T]],[T]]],[11,R[6],E,E,15,[[[U]],[R[1]]]],[11,"into",E,E,15,[[],[U]]],[11,R[7],E,E,15,[[],[R[1]]]],[11,R[8],E,E,15,[[["self"]],[T]]],[11,R[9],E,E,15,[[["self"]],[T]]],[11,R[11],E,E,15,[[["self"]],[R[14]]]],[11,R[64],E,E,15,[[["self"]],[T]]],[11,R[65],E,E,15,[[["self"],[T]]]],[11,R[176],E,E,15,[[["self"]],["string"]]],[11,"from",E,E,16,[[[T]],[T]]],[11,R[6],E,E,16,[[[U]],[R[1]]]],[11,"into",E,E,16,[[],[U]]],[11,R[7],E,E,16,[[],[R[1]]]],[11,R[8],E,E,16,[[["self"]],[T]]],[11,R[9],E,E,16,[[["self"]],[T]]],[11,R[11],E,E,16,[[["self"]],[R[14]]]],[11,R[64],E,E,16,[[["self"]],[T]]],[11,R[65],E,E,16,[[["self"],[T]]]],[11,R[176],E,E,16,[[["self"]],["string"]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,R[64],E,E,0,[[["self"]],[T]]],[11,R[65],E,E,0,[[["self"],[T]]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[6],E,E,1,[[[U]],[R[1]]]],[11,"into",E,E,1,[[],[U]]],[11,R[7],E,E,1,[[],[R[1]]]],[11,R[8],E,E,1,[[["self"]],[T]]],[11,R[9],E,E,1,[[["self"]],[T]]],[11,R[11],E,E,1,[[["self"]],[R[14]]]],[11,R[64],E,E,1,[[["self"]],[T]]],[11,R[65],E,E,1,[[["self"],[T]]]],[11,"from",E,E,17,[[[T]],[T]]],[11,R[6],E,E,17,[[[U]],[R[1]]]],[11,R[91],E,E,17,[[],["i"]]],[11,"into",E,E,17,[[],[U]]],[11,R[7],E,E,17,[[],[R[1]]]],[11,R[8],E,E,17,[[["self"]],[T]]],[11,R[9],E,E,17,[[["self"]],[T]]],[11,R[11],E,E,17,[[["self"]],[R[14]]]],[11,R[64],E,E,17,[[["self"]],[T]]],[11,R[65],E,E,17,[[["self"],[T]]]],[11,"from",E,E,18,[[[T]],[T]]],[11,R[6],E,E,18,[[[U]],[R[1]]]],[11,"into",E,E,18,[[],[U]]],[11,R[7],E,E,18,[[],[R[1]]]],[11,R[8],E,E,18,[[["self"]],[T]]],[11,R[9],E,E,18,[[["self"]],[T]]],[11,R[11],E,E,18,[[["self"]],[R[14]]]],[11,R[64],E,E,18,[[["self"]],[T]]],[11,R[65],E,E,18,[[["self"],[T]]]],[11,"from",E,E,19,[[[T]],[T]]],[11,R[6],E,E,19,[[[U]],[R[1]]]],[11,R[91],E,E,19,[[],["i"]]],[11,"into",E,E,19,[[],[U]]],[11,R[7],E,E,19,[[],[R[1]]]],[11,R[8],E,E,19,[[["self"]],[T]]],[11,R[9],E,E,19,[[["self"]],[T]]],[11,R[11],E,E,19,[[["self"]],[R[14]]]],[11,R[64],E,E,19,[[["self"]],[T]]],[11,R[65],E,E,19,[[["self"],[T]]]],[11,"from",E,E,2,[[[T]],[T]]],[11,R[6],E,E,2,[[[U]],[R[1]]]],[11,"into",E,E,2,[[],[U]]],[11,R[7],E,E,2,[[],[R[1]]]],[11,R[8],E,E,2,[[["self"]],[T]]],[11,R[9],E,E,2,[[["self"]],[T]]],[11,R[11],E,E,2,[[["self"]],[R[14]]]],[11,"from",E,E,3,[[[T]],[T]]],[11,R[6],E,E,3,[[[U]],[R[1]]]],[11,"into",E,E,3,[[],[U]]],[11,R[7],E,E,3,[[],[R[1]]]],[11,R[8],E,E,3,[[["self"]],[T]]],[11,R[9],E,E,3,[[["self"]],[T]]],[11,R[11],E,E,3,[[["self"]],[R[14]]]],[11,"from",E,E,20,[[[T]],[T]]],[11,R[6],E,E,20,[[[U]],[R[1]]]],[11,"into",E,E,20,[[],[U]]],[11,R[7],E,E,20,[[],[R[1]]]],[11,R[8],E,E,20,[[["self"]],[T]]],[11,R[9],E,E,20,[[["self"]],[T]]],[11,R[11],E,E,20,[[["self"]],[R[14]]]],[11,R[64],E,E,20,[[["self"]],[T]]],[11,R[65],E,E,20,[[["self"],[T]]]],[11,"from",E,E,8,[[[T]],[T]]],[11,R[6],E,E,8,[[[U]],[R[1]]]],[11,"into",E,E,8,[[],[U]]],[11,R[7],E,E,8,[[],[R[1]]]],[11,R[8],E,E,8,[[["self"]],[T]]],[11,R[9],E,E,8,[[["self"]],[T]]],[11,R[11],E,E,8,[[["self"]],[R[14]]]],[11,"from",E,E,10,[[[T]],[T]]],[11,R[6],E,E,10,[[[U]],[R[1]]]],[11,"into",E,E,10,[[],[U]]],[11,R[7],E,E,10,[[],[R[1]]]],[11,R[8],E,E,10,[[["self"]],[T]]],[11,R[9],E,E,10,[[["self"]],[T]]],[11,R[11],E,E,10,[[["self"]],[R[14]]]],[11,"from",E,E,11,[[[T]],[T]]],[11,R[6],E,E,11,[[[U]],[R[1]]]],[11,"into",E,E,11,[[],[U]]],[11,R[7],E,E,11,[[],[R[1]]]],[11,R[8],E,E,11,[[["self"]],[T]]],[11,R[9],E,E,11,[[["self"]],[T]]],[11,R[11],E,E,11,[[["self"]],[R[14]]]],[11,"from",E,E,4,[[[T]],[T]]],[11,R[6],E,E,4,[[[U]],[R[1]]]],[11,"into",E,E,4,[[],[U]]],[11,R[7],E,E,4,[[],[R[1]]]],[11,R[8],E,E,4,[[["self"]],[T]]],[11,R[9],E,E,4,[[["self"]],[T]]],[11,R[11],E,E,4,[[["self"]],[R[14]]]],[11,"from",E,E,12,[[[T]],[T]]],[11,R[6],E,E,12,[[[U]],[R[1]]]],[11,"into",E,E,12,[[],[U]]],[11,R[7],E,E,12,[[],[R[1]]]],[11,R[8],E,E,12,[[["self"]],[T]]],[11,R[9],E,E,12,[[["self"]],[T]]],[11,R[11],E,E,12,[[["self"]],[R[14]]]],[11,"from",E,E,5,[[[T]],[T]]],[11,R[6],E,E,5,[[[U]],[R[1]]]],[11,"into",E,E,5,[[],[U]]],[11,R[7],E,E,5,[[],[R[1]]]],[11,R[8],E,E,5,[[["self"]],[T]]],[11,R[9],E,E,5,[[["self"]],[T]]],[11,R[11],E,E,5,[[["self"]],[R[14]]]],[11,"from",E,E,13,[[[T]],[T]]],[11,R[6],E,E,13,[[[U]],[R[1]]]],[11,"into",E,E,13,[[],[U]]],[11,R[7],E,E,13,[[],[R[1]]]],[11,R[8],E,E,13,[[["self"]],[T]]],[11,R[9],E,E,13,[[["self"]],[T]]],[11,R[11],E,E,13,[[["self"]],[R[14]]]],[11,"from",E,E,6,[[[T]],[T]]],[11,R[6],E,E,6,[[[U]],[R[1]]]],[11,"into",E,E,6,[[],[U]]],[11,R[7],E,E,6,[[],[R[1]]]],[11,R[8],E,E,6,[[["self"]],[T]]],[11,R[9],E,E,6,[[["self"]],[T]]],[11,R[11],E,E,6,[[["self"]],[R[14]]]],[11,"from",E,E,9,[[[T]],[T]]],[11,R[6],E,E,9,[[[U]],[R[1]]]],[11,"into",E,E,9,[[],[U]]],[11,R[7],E,E,9,[[],[R[1]]]],[11,R[8],E,E,9,[[["self"]],[T]]],[11,R[9],E,E,9,[[["self"]],[T]]],[11,R[11],E,E,9,[[["self"]],[R[14]]]],[11,"from",E,E,7,[[[T]],[T]]],[11,R[6],E,E,7,[[[U]],[R[1]]]],[11,"into",E,E,7,[[],[U]]],[11,R[7],E,E,7,[[],[R[1]]]],[11,R[8],E,E,7,[[["self"]],[T]]],[11,R[9],E,E,7,[[["self"]],[T]]],[11,R[11],E,E,7,[[["self"]],[R[14]]]],[11,R[95],E,E,16,[[[R[82]],["self"]]]],[11,R[95],E,E,15,[[[R[81]],["self"]]]],[11,"rem",E,E,16,[[[R[94]]],[R[82]]]],[11,"fmt",E,E,16,[[[R[12]],["self"]],[[R[1],["error"]],["error"]]]],[11,"fmt",E,E,15,[[[R[12]],["self"]],[[R[1],["error"]],["error"]]]],[11,"shl",E,E,16,[[[R[94]]],[R[82]]]],[11,"fmt",E,E,15,[[[R[12]],["self"]],[[R[1],["error"]],["error"]]]],[11,"fmt",E,E,16,[[[R[12]],["self"]],[[R[1],["error"]],["error"]]]],[11,"fmt",E,E,15,[[[R[12]],["self"]],[[R[1],["error"]],["error"]]]],[11,"bitand",E,E,15,[[[R[81]]],[R[81]]]],[11,"bitand",E,E,16,[[[R[82]]],[R[82]]]],[11,"fmt",E,E,18,[[[R[12]],["self"]],[[R[1],["error"]],["error"]]]],[11,"fmt",E,E,16,[[[R[12]],["self"]],[[R[1],["error"]],["error"]]]],[11,"fmt",E,E,19,[[[R[12]],["self"]],[[R[1],["error"]],["error"]]]],[11,"fmt",E,E,1,[[[R[12]],["self"]],[[R[1],["error"]],["error"]]]],[11,"fmt",E,E,15,[[[R[12]],["self"]],[[R[1],["error"]],["error"]]]],[11,"fmt",E,E,17,[[[R[12]],["self"]],[[R[1],["error"]],["error"]]]],[11,"fmt",E,E,0,[[[R[12]],["self"]],[[R[1],["error"]],["error"]]]],[11,"bitor",E,E,15,[[[R[81]]],[R[81]]]],[11,"bitor",E,E,16,[[[R[82]]],[R[82]]]],[11,"deref",E,E,17,[[["self"]],[R[98]]]],[11,"deref",E,E,19,[[["self"]],[R[98]]]],[11,R[93],E,E,18,[[["self"],["usize"]]]],[11,R[93],E,E,15,[[[R[81]],["self"]]]],[11,R[93],E,E,16,[[[R[82]],["self"]]]],[11,R[93],E,E,16,[[["self"],["usize"]]]],[11,R[93],E,E,1,[[["self"],["usize"]]]],[11,R[93],E,E,15,[[["self"],["usize"]]]],[11,R[96],E,E,15,[[[R[81]],["self"]]]],[11,R[96],E,E,16,[[[R[82]],["self"]]]],[11,"cmp",E,E,15,[[[R[81]],["self"]],[R[16]]]],[11,"cmp",E,E,1,[[["self"],["frame"]],[R[16]]]],[11,"cmp",E,E,16,[[[R[82]],["self"]],[R[16]]]],[11,"cmp",E,E,18,[[["page"],["self"]],[R[16]]]],[11,R[97],E,E,16,[[[R[82]],["self"]]]],[11,R[97],E,E,15,[[[R[81]],["self"]]]],[11,"mul",E,E,16,[[[R[94]]],[R[82]]]],[11,"fmt",E,E,16,[[[R[12]],["self"]],[[R[1],["error"]],["error"]]]],[11,"fmt",E,E,15,[[[R[12]],["self"]],[[R[1],["error"]],["error"]]]],[11,"clone",E,E,0,[[["self"]],[R[104]]]],[11,"clone",E,E,19,[[["self"]],[R[89]]]],[11,"clone",E,E,15,[[["self"]],[R[81]]]],[11,"clone",E,E,1,[[["self"]],["frame"]]],[11,"clone",E,E,16,[[["self"]],[R[82]]]],[11,"clone",E,E,18,[[["self"]],["page"]]],[11,"clone",E,E,17,[[["self"]],[R[85]]]],[11,"div",E,E,16,[[[R[94]]],[R[82]]]],[11,"shr",E,E,16,[[[R[94]]],[R[82]]]],[11,"eq",E,E,18,[[["page"],["self"]],["bool"]]],[11,"ne",E,E,18,[[["page"],["self"]],["bool"]]],[11,"eq",E,E,16,[[[R[82]],["self"]],["bool"]]],[11,"ne",E,E,16,[[[R[82]],["self"]],["bool"]]],[11,"eq",E,E,15,[[[R[81]],["self"]],["bool"]]],[11,"ne",E,E,15,[[[R[81]],["self"]],["bool"]]],[11,"eq",E,E,1,[[["self"],["frame"]],["bool"]]],[11,"ne",E,E,1,[[["self"],["frame"]],["bool"]]],[11,"fmt",E,E,15,[[[R[12]],["self"]],[[R[1],["error"]],["error"]]]],[11,"fmt",E,E,16,[[[R[12]],["self"]],[[R[1],["error"]],["error"]]]],[11,"add",E,E,15,[[["usize"]],[R[81]]]],[11,"add",E,E,1,[[["usize"]],["frame"]]],[11,"add",E,E,16,[[[R[82]]],[R[82]]]],[11,"add",E,E,18,[[["usize"]],["page"]]],[11,"add",E,E,15,[[[R[81]]],[R[81]]]],[11,"add",E,E,16,[[["usize"]],[R[82]]]],[11,R[241],E,E,16,[[[R[94]],["self"]]]],[11,R[245],E,E,16,[[[R[94]],["self"]]]],[11,R[242],E,E,16,[[[R[94]],["self"]]]],[11,"hash",E,E,16,[[["self"],["__h"]]]],[11,"hash",E,E,15,[[["self"],["__h"]]]],[11,R[244],E,E,16,[[[R[94]],["self"]]]],[11,R[38],E,E,16,[[],[R[82]]]],[11,R[38],E,E,15,[[],[R[81]]]],[11,R[38],E,E,0,[[],[R[104]]]],[11,R[61],E,E,15,[[[R[81]],["self"]],[[R[31],[R[16]]],[R[16]]]]],[11,"lt",E,E,15,[[[R[81]],["self"]],["bool"]]],[11,"le",E,E,15,[[[R[81]],["self"]],["bool"]]],[11,"gt",E,E,15,[[[R[81]],["self"]],["bool"]]],[11,"ge",E,E,15,[[[R[81]],["self"]],["bool"]]],[11,R[61],E,E,16,[[[R[82]],["self"]],[[R[31],[R[16]]],[R[16]]]]],[11,"lt",E,E,16,[[[R[82]],["self"]],["bool"]]],[11,"le",E,E,16,[[[R[82]],["self"]],["bool"]]],[11,"gt",E,E,16,[[[R[82]],["self"]],["bool"]]],[11,"ge",E,E,16,[[[R[82]],["self"]],["bool"]]],[11,R[61],E,E,1,[[["self"],["frame"]],[[R[31],[R[16]]],[R[16]]]]],[11,"lt",E,E,1,[[["self"],["frame"]],["bool"]]],[11,"le",E,E,1,[[["self"],["frame"]],["bool"]]],[11,"gt",E,E,1,[[["self"],["frame"]],["bool"]]],[11,"ge",E,E,1,[[["self"],["frame"]],["bool"]]],[11,R[61],E,E,18,[[["page"],["self"]],[[R[31],[R[16]]],[R[16]]]]],[11,"lt",E,E,18,[[["page"],["self"]],["bool"]]],[11,"le",E,E,18,[[["page"],["self"]],["bool"]]],[11,"gt",E,E,18,[[["page"],["self"]],["bool"]]],[11,"ge",E,E,18,[[["page"],["self"]],["bool"]]],[11,R[92],E,E,1,[[["self"],["usize"]]]],[11,R[92],E,E,16,[[["self"],["usize"]]]],[11,R[92],E,E,15,[[["self"],["usize"]]]],[11,R[92],E,E,15,[[[R[81]],["self"]]]],[11,R[92],E,E,18,[[["self"],["usize"]]]],[11,R[92],E,E,16,[[[R[82]],["self"]]]],[11,"sub",E,E,1,[[["usize"]],["frame"]]],[11,"sub",E,E,15,[[[R[81]]],[R[81]]]],[11,"sub",E,E,16,[[[R[82]]],[R[82]]]],[11,"sub",E,E,15,[[["usize"]],[R[81]]]],[11,"sub",E,E,16,[[["usize"]],[R[82]]]],[11,"sub",E,E,18,[[["usize"]],["page"]]],[11,R[100],E,E,18,[[["page"]],[[R[31],["usize"]],["usize"]]]],[11,R[101],E,E,18,[[["self"]],["page"]]],[11,R[102],E,E,18,[[["self"]],["page"]]],[11,"add_one",E,E,18,[[["self"]],["page"]]],[11,"sub_one",E,E,18,[[["self"]],["page"]]],[11,R[103],E,E,18,[[["self"],["usize"]],[["page"],[R[31],["page"]]]]],[11,R[100],E,E,1,[[["frame"]],[[R[31],["usize"]],["usize"]]]],[11,R[101],E,E,1,[[["self"]],["frame"]]],[11,R[102],E,E,1,[[["self"]],["frame"]]],[11,"add_one",E,E,1,[[["self"]],["frame"]]],[11,"sub_one",E,E,1,[[["self"]],["frame"]]],[11,R[103],E,E,1,[[["self"],["usize"]],[[R[31],["frame"]],["frame"]]]],[11,"fmt",E,E,16,[[[R[12]],["self"]],[[R[1],["error"]],["error"]]]],[11,"fmt",E,E,15,[[[R[12]],["self"]],[[R[1],["error"]],["error"]]]],[11,R[99],E,E,17,[[["self"]],[R[98]]]],[11,R[99],E,E,19,[[["self"]],[R[98]]]],[11,"bitxor",E,E,16,[[[R[82]]],[R[82]]]],[11,"bitxor",E,E,15,[[[R[81]]],[R[81]]]],[11,R[91],E,E,19,[[]]],[11,R[91],E,E,17,[[]]],[11,R[243],E,E,16,[[[R[94]],["self"]]]],[11,"bitor",E,R[114],20,[[[R[57]]],[R[57]]]],[11,"eq",E,E,20,[[[R[57]],["self"]],["bool"]]],[11,"ne",E,E,20,[[[R[57]],["self"]],["bool"]]],[11,R[95],E,R[115],20,[[["self"],[R[57]]]]],[11,"fmt",E,E,20,[[[R[12]],["self"]],[[R[1],["error"]],["error"]]]],[11,"fmt",E,E,20,[[[R[12]],["self"]],[[R[1],["error"]],["error"]]]],[11,"bitand",E,R[116],20,[[[R[57]]],[R[57]]]],[11,"hash",E,E,20,[[["self"],["__h"]]]],[11,R[38],E,E,20,[[],[R[57]]]],[11,"fmt",E,E,20,[[[R[12]],["self"]],[[R[1],["error"]],["error"]]]],[11,R[61],E,E,20,[[[R[57]],["self"]],[[R[31],[R[16]]],[R[16]]]]],[11,"lt",E,E,20,[[[R[57]],["self"]],["bool"]]],[11,"le",E,E,20,[[[R[57]],["self"]],["bool"]]],[11,"gt",E,E,20,[[[R[57]],["self"]],["bool"]]],[11,"ge",E,E,20,[[[R[57]],["self"]],["bool"]]],[11,R[93],E,R[117],20,[[["self"],[R[57]]]]],[11,"sub",E,R[118],20,[[[R[57]]],[R[57]]]],[11,"fmt",E,E,20,[[[R[12]],["self"]],[[R[1],["error"]],["error"]]]],[11,R[96],E,R[119],20,[[["self"],[R[57]]]]],[11,"not",E,R[120],20,[[],[R[57]]]],[11,"cmp",E,E,20,[[[R[57]],["self"]],[R[16]]]],[11,R[121],E,E,20,[[[T]],[R[57]]]],[11,R[97],E,R[122],20,[[["self"],[R[57]]]]],[11,"bitxor",E,R[123],20,[[[R[57]]],[R[57]]]],[11,"fmt",E,E,20,[[[R[12]],["self"]],[[R[1],["error"]],["error"]]]],[11,"extend",E,E,20,[[["self"],[T]]]],[11,"clone",E,E,20,[[["self"]],[R[57]]]],[11,R[174],E,E,8,[[["self"],["usize"]],[[R[31],[R[85]]],[R[85]]]]],[11,R[173],E,E,8,[[["self"]],[["frame"],[R[31],["frame"]]]]],[11,R[177],E,E,8,[[["self"],["frame"]]]],[11,R[178],E,"Call this when the kernel heap has been set up",8,[[["self"]]]],[11,"fmt",E,E,6,[[[R[12]],["self"]],[R[1]]]],[11,"fmt",E,E,9,[[[R[12]],["self"]],[R[1]]]],[11,"fmt",E,E,5,[[[R[12]],["self"]],[R[1]]]],[11,"fmt",E,E,12,[[[R[12]],["self"]],[R[1]]]],[11,"fmt",E,E,13,[[["self"],[R[12]]],[R[1]]]],[11,"fmt",E,E,7,[[[R[12]],["self"]],[R[1]]]],[11,"deref",E,E,9,[[["self"]],[R[168]]]],[11,"deref",E,E,5,[[["self"]],[R[89]]]],[11,"deref",E,E,12,[[["self"]],[R[89]]]],[11,"deref",E,E,13,[[["self"]],["mapper"]]],[11,R[99],E,E,9,[[["self"]],[R[168]]]],[11,R[99],E,E,13,[[["self"]],["mapper"]]],[11,"drop",E,E,12,[[["self"]]]],[11,"new",E,R[201],15,[[["usize"]],[[R[1],[R[81],"str"]],[R[81]],["str"]]]],[11,R[83],E,R[202],15,[[["usize"]],[R[81]]]],[11,"zero",E,R[203],15,[[],[R[81]]]],[11,"value",E,R[84],15,[[["self"]],["usize"]]],[11,R[204],E,R[205],15,[[["self"]],["usize"]]],[11,"new",E,R[206],16,[[["usize"]],[[R[82]],["str"],[R[1],[R[82],"str"]]]]],[11,R[83],E,R[207],16,[[["usize"]],[R[82]]]],[11,"value",E,R[84],16,[[["self"]],["usize"]]],[11,"zero",E,R[208],16,[[],[R[82]]]],[11,R[209],E,R[210],16,[[["self"]],["usize"]]],[11,"new",E,E,0,[[[R[82]],["u32"],["usize"]],[R[104]]]],[11,R[87],E,R[211],1,[[[R[82]]],["frame"]]],[11,R[86],E,R[212],1,[[["self"]],[R[82]]]],[11,"new",E,R[213],17,[[["frame"]],[R[85]]]],[11,"empty",E,R[214],17,[[],[R[85]]]],[11,R[215],E,R[216],17,[[[R[82]],["usize"]],[R[85]]]],[11,R[86],E,R[217],17,[[["self"]],[R[82]]]],[11,R[218],E,R[219],17,[[["self"]],["usize"]]],[11,R[220],E,R[221],17,[[[R[82]],["self"]],["bool"]]],[11,R[222],E,R[223],17,[[[R[82]],["self"]],[[R[31],["usize"]],["usize"]]]],[11,R[224],E,R[225],17,[[["self"],["frame"]],[R[85]]]],[11,R[87],E,R[226],18,[[[R[81]]],["page"]]],[11,R[86],E,R[227],18,[[["self"]],[R[81]]]],[11,"p4_index",E,R[88],18,[[["self"]],["usize"]]],[11,"p3_index",E,R[88],18,[[["self"]],["usize"]]],[11,"p2_index",E,R[88],18,[[["self"]],["usize"]]],[11,"p1_index",E,R[88],18,[[["self"]],["usize"]]],[11,"new",E,R[228],19,[[["page"]],[R[89]]]],[11,"empty",E,R[229],19,[[],[R[89]]]],[11,R[230],E,R[231],19,[[[R[81]],["usize"]],[R[89]]]],[11,R[86],E,R[232],19,[[["self"]],[R[81]]]],[11,R[179],E,R[233],19,[[["self"]],["usize"]]],[11,R[90],E,R[234],19,[[["self"]],["usize"]]],[11,R[235],E,R[236],19,[[[R[81]],["self"]],["bool"]]],[11,R[237],E,R[238],19,[[[R[81]],["self"]],[[R[31],["usize"]],["usize"]]]],[11,R[239],E,R[240],19,[[["self"],["usize"]],[[R[81]],[R[31],[R[81]]]]]],[11,"is_huge",E,R[131],20,[[["self"]],["bool"]]],[11,R[132],E,R[133],20,[[],[R[57]]]],[11,R[134],E,R[135],20,[[["self"]],["bool"]]],[11,R[136],E,R[137],20,[[],[R[57]]]],[11,R[138],E,R[139],20,[[["self"]],["bool"]]],[11,R[140],E,R[58],20,[[[R[141]]],[R[57]]]],[11,R[142],E,R[58],20,[[["u64"]],[R[57]]]],[11,R[143],E,R[144],20,[[["flags"]],[R[57]]]],[18,"PRESENT",E,E,20,N],[18,R[246],E,E,20,N],[18,R[145],E,E,20,N],[18,R[146],E,E,20,N],[18,R[247],E,E,20,N],[18,R[248],E,E,20,N],[18,"DIRTY",E,E,20,N],[18,R[147],E,E,20,N],[18,"GLOBAL",E,E,20,N],[18,R[148],E,E,20,N],[11,"empty",E,R[149],20,[[],[R[57]]]],[11,"all",E,R[150],20,[[],[R[57]]]],[11,"bits",E,R[151],20,[[["self"]],["u64"]]],[11,R[152],E,R[153],20,[[["u64"]],[[R[31],[R[57]]],[R[57]]]]],[11,R[154],E,R[155],20,[[["u64"]],[R[57]]]],[11,R[47],E,R[156],20,[[["self"]],["bool"]]],[11,"is_all",E,R[157],20,[[["self"]],["bool"]]],[11,R[158],E,R[159],20,[[["self"],[R[57]]],["bool"]]],[11,R[249],E,R[160],20,[[["self"],[R[57]]],["bool"]]],[11,"insert",E,R[161],20,[[["self"],[R[57]]]]],[11,"remove",E,R[162],20,[[["self"],[R[57]]]]],[11,"toggle",E,R[163],20,[[["self"],[R[57]]]]],[11,"set",E,R[164],20,[[["self"],[R[57]],["bool"]]]]],"p":[[3,R[105]],[3,"Frame"],[3,R[106]],[3,R[107]],[3,"Mapper"],[3,R[180]],[3,R[181]],[3,R[182]],[3,R[183]],[3,"Stack"],[3,"Entry"],[3,R[184]],[3,R[185]],[3,R[186]],[8,R[187]],[3,R[108]],[3,R[109]],[3,R[110]],[3,"Page"],[3,R[111]],[3,R[60]]]};
searchIndex["memory_initialization"]={"doc":E,"i":[[5,"init_memory_management","memory_initialization","Initializes the virtual memory management system and…",N,[[[R[113]]],[["str"],[R[1],["str"]]]]]],"p":[]};
searchIndex["memory_structs"]={"doc":"This crate contains common types used for memory mapping. ","i":[[3,R[108],"memory_structs",R[188],N,N],[3,R[109],E,R[189],N,N],[3,R[105],E,R[190],N,N],[12,R[191],E,E,0,N],[12,R[90],E,E,0,N],[12,"typ",E,E,0,N],[12,"acpi",E,E,0,N],[3,"Frame",E,R[192],N,N],[12,"number",E,E,1,N],[3,R[110],E,R[193],N,N],[3,"Page",E,R[194],N,N],[3,R[111],E,R[195],N,N],[3,R[106],E,R[196],N,N],[12,"start",E,R[197],2,N],[12,"end",E,R[198],2,N],[12,"flags",E,R[199],2,N],[3,R[107],E,R[200],N,N],[12,"text",E,E,3,N],[12,"rodata",E,E,3,N],[12,"data",E,E,3,N],[11,"new",E,R[201],4,[[["usize"]],[["str"],[R[1],[R[81],"str"]],[R[81]]]]],[11,R[83],E,R[202],4,[[["usize"]],[R[81]]]],[11,"zero",E,R[203],4,[[],[R[81]]]],[11,"value",E,R[84],4,[[["self"]],["usize"]]],[11,R[204],E,R[205],4,[[["self"]],["usize"]]],[11,"new",E,R[206],5,[[["usize"]],[[R[82]],[R[1],[R[82],"str"]],["str"]]]],[11,R[83],E,R[207],5,[[["usize"]],[R[82]]]],[11,"value",E,R[84],5,[[["self"]],["usize"]]],[11,"zero",E,R[208],5,[[],[R[82]]]],[11,R[209],E,R[210],5,[[["self"]],["usize"]]],[11,"new",E,E,0,[[["u32"],["usize"],[R[82]]],[R[104]]]],[11,R[87],E,R[211],1,[[[R[82]]],["frame"]]],[11,R[86],E,R[212],1,[[["self"]],[R[82]]]],[11,"new",E,R[213],6,[[["frame"]],[R[85]]]],[11,"empty",E,R[214],6,[[],[R[85]]]],[11,R[215],E,R[216],6,[[[R[82]],["usize"]],[R[85]]]],[11,R[86],E,R[217],6,[[["self"]],[R[82]]]],[11,R[218],E,R[219],6,[[["self"]],["usize"]]],[11,R[220],E,R[221],6,[[[R[82]],["self"]],["bool"]]],[11,R[222],E,R[223],6,[[[R[82]],["self"]],[[R[31],["usize"]],["usize"]]]],[11,R[224],E,R[225],6,[[["frame"],["self"]],[R[85]]]],[11,R[87],E,R[226],7,[[[R[81]]],["page"]]],[11,R[86],E,R[227],7,[[["self"]],[R[81]]]],[11,"p4_index",E,R[88],7,[[["self"]],["usize"]]],[11,"p3_index",E,R[88],7,[[["self"]],["usize"]]],[11,"p2_index",E,R[88],7,[[["self"]],["usize"]]],[11,"p1_index",E,R[88],7,[[["self"]],["usize"]]],[11,"new",E,R[228],8,[[["page"]],[R[89]]]],[11,"empty",E,R[229],8,[[],[R[89]]]],[11,R[230],E,R[231],8,[[[R[81]],["usize"]],[R[89]]]],[11,R[86],E,R[232],8,[[["self"]],[R[81]]]],[11,R[179],E,R[233],8,[[["self"]],["usize"]]],[11,R[90],E,R[234],8,[[["self"]],["usize"]]],[11,R[235],E,R[236],8,[[["self"],[R[81]]],["bool"]]],[11,R[237],E,R[238],8,[[["self"],[R[81]]],[[R[31],["usize"]],["usize"]]]],[11,R[239],E,R[240],8,[[["self"],["usize"]],[[R[31],[R[81]]],[R[81]]]]],[11,"from",E,E,4,[[[T]],[T]]],[11,R[6],E,E,4,[[[U]],[R[1]]]],[11,"into",E,E,4,[[],[U]]],[11,R[7],E,E,4,[[],[R[1]]]],[11,R[8],E,E,4,[[["self"]],[T]]],[11,R[9],E,E,4,[[["self"]],[T]]],[11,R[11],E,E,4,[[["self"]],[R[14]]]],[11,"from",E,E,5,[[[T]],[T]]],[11,R[6],E,E,5,[[[U]],[R[1]]]],[11,"into",E,E,5,[[],[U]]],[11,R[7],E,E,5,[[],[R[1]]]],[11,R[8],E,E,5,[[["self"]],[T]]],[11,R[9],E,E,5,[[["self"]],[T]]],[11,R[11],E,E,5,[[["self"]],[R[14]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[6],E,E,1,[[[U]],[R[1]]]],[11,"into",E,E,1,[[],[U]]],[11,R[7],E,E,1,[[],[R[1]]]],[11,R[8],E,E,1,[[["self"]],[T]]],[11,R[9],E,E,1,[[["self"]],[T]]],[11,R[11],E,E,1,[[["self"]],[R[14]]]],[11,"from",E,E,6,[[[T]],[T]]],[11,R[6],E,E,6,[[[U]],[R[1]]]],[11,R[91],E,E,6,[[],["i"]]],[11,"into",E,E,6,[[],[U]]],[11,R[7],E,E,6,[[],[R[1]]]],[11,R[8],E,E,6,[[["self"]],[T]]],[11,R[9],E,E,6,[[["self"]],[T]]],[11,R[11],E,E,6,[[["self"]],[R[14]]]],[11,"from",E,E,7,[[[T]],[T]]],[11,R[6],E,E,7,[[[U]],[R[1]]]],[11,"into",E,E,7,[[],[U]]],[11,R[7],E,E,7,[[],[R[1]]]],[11,R[8],E,E,7,[[["self"]],[T]]],[11,R[9],E,E,7,[[["self"]],[T]]],[11,R[11],E,E,7,[[["self"]],[R[14]]]],[11,"from",E,E,8,[[[T]],[T]]],[11,R[6],E,E,8,[[[U]],[R[1]]]],[11,R[91],E,E,8,[[],["i"]]],[11,"into",E,E,8,[[],[U]]],[11,R[7],E,E,8,[[],[R[1]]]],[11,R[8],E,E,8,[[["self"]],[T]]],[11,R[9],E,E,8,[[["self"]],[T]]],[11,R[11],E,E,8,[[["self"]],[R[14]]]],[11,"from",E,E,2,[[[T]],[T]]],[11,R[6],E,E,2,[[[U]],[R[1]]]],[11,"into",E,E,2,[[],[U]]],[11,R[7],E,E,2,[[],[R[1]]]],[11,R[8],E,E,2,[[["self"]],[T]]],[11,R[9],E,E,2,[[["self"]],[T]]],[11,R[11],E,E,2,[[["self"]],[R[14]]]],[11,"from",E,E,3,[[[T]],[T]]],[11,R[6],E,E,3,[[[U]],[R[1]]]],[11,"into",E,E,3,[[],[U]]],[11,R[7],E,E,3,[[],[R[1]]]],[11,R[8],E,E,3,[[["self"]],[T]]],[11,R[9],E,E,3,[[["self"]],[T]]],[11,R[11],E,E,3,[[["self"]],[R[14]]]],[11,"fmt",E,E,4,[[[R[12]],["self"]],[R[1]]]],[11,"fmt",E,E,5,[[[R[12]],["self"]],[R[1]]]],[11,"fmt",E,E,4,[[[R[12]],["self"]],[R[1]]]],[11,"fmt",E,E,5,[[[R[12]],["self"]],[R[1]]]],[11,"fmt",E,E,0,[[[R[12]],["self"]],[R[1]]]],[11,"fmt",E,E,1,[[["self"],[R[12]]],[R[1]]]],[11,"fmt",E,E,6,[[[R[12]],["self"]],[R[1]]]],[11,"fmt",E,E,7,[[["self"],[R[12]]],[R[1]]]],[11,"fmt",E,E,8,[[[R[12]],["self"]],[R[1]]]],[11,"div",E,E,5,[[[R[94]]],[R[82]]]],[11,"rem",E,E,5,[[[R[94]]],[R[82]]]],[11,"sub",E,E,4,[[[R[81]]],[R[81]]]],[11,"sub",E,E,4,[[["usize"]],[R[81]]]],[11,"sub",E,E,5,[[[R[82]]],[R[82]]]],[11,"sub",E,E,5,[[["usize"]],[R[82]]]],[11,"sub",E,E,1,[[["usize"]],["frame"]]],[11,"sub",E,E,7,[[["usize"]],["page"]]],[11,"eq",E,E,4,[[["self"],[R[81]]],["bool"]]],[11,"ne",E,E,4,[[["self"],[R[81]]],["bool"]]],[11,"eq",E,E,5,[[["self"],[R[82]]],["bool"]]],[11,"ne",E,E,5,[[["self"],[R[82]]],["bool"]]],[11,"eq",E,E,1,[[["self"],["frame"]],["bool"]]],[11,"ne",E,E,1,[[["self"],["frame"]],["bool"]]],[11,"eq",E,E,7,[[["page"],["self"]],["bool"]]],[11,"ne",E,E,7,[[["page"],["self"]],["bool"]]],[11,"cmp",E,E,4,[[["self"],[R[81]]],[R[16]]]],[11,"cmp",E,E,5,[[["self"],[R[82]]],[R[16]]]],[11,"cmp",E,E,1,[[["self"],["frame"]],[R[16]]]],[11,"cmp",E,E,7,[[["page"],["self"]],[R[16]]]],[11,R[61],E,E,4,[[["self"],[R[81]]],[[R[16]],[R[31],[R[16]]]]]],[11,"lt",E,E,4,[[["self"],[R[81]]],["bool"]]],[11,"le",E,E,4,[[["self"],[R[81]]],["bool"]]],[11,"gt",E,E,4,[[["self"],[R[81]]],["bool"]]],[11,"ge",E,E,4,[[["self"],[R[81]]],["bool"]]],[11,R[61],E,E,5,[[["self"],[R[82]]],[[R[16]],[R[31],[R[16]]]]]],[11,"lt",E,E,5,[[["self"],[R[82]]],["bool"]]],[11,"le",E,E,5,[[["self"],[R[82]]],["bool"]]],[11,"gt",E,E,5,[[["self"],[R[82]]],["bool"]]],[11,"ge",E,E,5,[[["self"],[R[82]]],["bool"]]],[11,R[61],E,E,1,[[["self"],["frame"]],[[R[16]],[R[31],[R[16]]]]]],[11,"lt",E,E,1,[[["self"],["frame"]],["bool"]]],[11,"le",E,E,1,[[["self"],["frame"]],["bool"]]],[11,"gt",E,E,1,[[["self"],["frame"]],["bool"]]],[11,"ge",E,E,1,[[["self"],["frame"]],["bool"]]],[11,R[61],E,E,7,[[["page"],["self"]],[[R[16]],[R[31],[R[16]]]]]],[11,"lt",E,E,7,[[["page"],["self"]],["bool"]]],[11,"le",E,E,7,[[["page"],["self"]],["bool"]]],[11,"gt",E,E,7,[[["page"],["self"]],["bool"]]],[11,"ge",E,E,7,[[["page"],["self"]],["bool"]]],[11,"add",E,E,4,[[[R[81]]],[R[81]]]],[11,"add",E,E,4,[[["usize"]],[R[81]]]],[11,"add",E,E,5,[[[R[82]]],[R[82]]]],[11,"add",E,E,5,[[["usize"]],[R[82]]]],[11,"add",E,E,1,[[["usize"]],["frame"]]],[11,"add",E,E,7,[[["usize"]],["page"]]],[11,"mul",E,E,5,[[[R[94]]],[R[82]]]],[11,R[92],E,E,4,[[["self"],[R[81]]]]],[11,R[92],E,E,4,[[["self"],["usize"]]]],[11,R[92],E,E,5,[[[R[82]],["self"]]]],[11,R[92],E,E,5,[[["self"],["usize"]]]],[11,R[92],E,E,1,[[["self"],["usize"]]]],[11,R[92],E,E,7,[[["self"],["usize"]]]],[11,R[93],E,E,4,[[["self"],[R[81]]]]],[11,R[93],E,E,4,[[["self"],["usize"]]]],[11,R[93],E,E,5,[[[R[82]],["self"]]]],[11,R[93],E,E,5,[[["self"],["usize"]]]],[11,R[93],E,E,1,[[["self"],["usize"]]]],[11,R[93],E,E,7,[[["self"],["usize"]]]],[11,R[241],E,E,5,[[[R[94]],["self"]]]],[11,R[242],E,E,5,[[[R[94]],["self"]]]],[11,R[243],E,E,5,[[[R[94]],["self"]]]],[11,"bitand",E,E,4,[[[R[81]]],[R[81]]]],[11,"bitand",E,E,5,[[[R[82]]],[R[82]]]],[11,"bitor",E,E,4,[[[R[81]]],[R[81]]]],[11,"bitor",E,E,5,[[[R[82]]],[R[82]]]],[11,"bitxor",E,E,4,[[[R[81]]],[R[81]]]],[11,"bitxor",E,E,5,[[[R[82]]],[R[82]]]],[11,"shl",E,E,5,[[[R[94]]],[R[82]]]],[11,"shr",E,E,5,[[[R[94]]],[R[82]]]],[11,R[95],E,E,4,[[["self"],[R[81]]]]],[11,R[95],E,E,5,[[[R[82]],["self"]]]],[11,R[96],E,E,4,[[["self"],[R[81]]]]],[11,R[96],E,E,5,[[[R[82]],["self"]]]],[11,R[97],E,E,4,[[["self"],[R[81]]]]],[11,R[97],E,E,5,[[[R[82]],["self"]]]],[11,R[244],E,E,5,[[[R[94]],["self"]]]],[11,R[245],E,E,5,[[[R[94]],["self"]]]],[11,"deref",E,E,6,[[["self"]],[R[98]]]],[11,"deref",E,E,8,[[["self"]],[R[98]]]],[11,R[99],E,E,6,[[["self"]],[R[98]]]],[11,R[99],E,E,8,[[["self"]],[R[98]]]],[11,"hash",E,E,4,[[["self"],["__h"]]]],[11,"hash",E,E,5,[[["self"],["__h"]]]],[11,R[100],E,E,1,[[["frame"]],[[R[31],["usize"]],["usize"]]]],[11,R[101],E,E,1,[[["self"]],["self"]]],[11,R[102],E,E,1,[[["self"]],["self"]]],[11,"add_one",E,E,1,[[["self"]],["self"]]],[11,"sub_one",E,E,1,[[["self"]],["self"]]],[11,R[103],E,E,1,[[["self"],["usize"]],[["frame"],[R[31],["frame"]]]]],[11,R[100],E,E,7,[[["page"]],[[R[31],["usize"]],["usize"]]]],[11,R[101],E,E,7,[[["self"]],["self"]]],[11,R[102],E,E,7,[[["self"]],["self"]]],[11,"add_one",E,E,7,[[["self"]],["self"]]],[11,"sub_one",E,E,7,[[["self"]],["self"]]],[11,R[103],E,E,7,[[["self"],["usize"]],[[R[31],["page"]],["page"]]]],[11,R[91],E,E,6,[[]]],[11,R[91],E,E,8,[[]]],[11,"fmt",E,E,4,[[[R[12]],["self"]],[R[1]]]],[11,"fmt",E,E,5,[[[R[12]],["self"]],[R[1]]]],[11,"fmt",E,E,4,[[[R[12]],["self"]],[R[1]]]],[11,"fmt",E,E,5,[[[R[12]],["self"]],[R[1]]]],[11,"fmt",E,E,4,[[[R[12]],["self"]],[R[1]]]],[11,"fmt",E,E,5,[[[R[12]],["self"]],[R[1]]]],[11,"fmt",E,E,4,[[[R[12]],["self"]],[R[1]]]],[11,"fmt",E,E,5,[[[R[12]],["self"]],[R[1]]]],[11,"fmt",E,E,4,[[["self"],[R[12]]],[R[1]]]],[11,"clone",E,E,4,[[["self"]],[R[81]]]],[11,"clone",E,E,5,[[["self"]],[R[82]]]],[11,"clone",E,E,0,[[["self"]],[R[104]]]],[11,"clone",E,E,1,[[["self"]],["frame"]]],[11,"clone",E,E,6,[[["self"]],[R[85]]]],[11,"clone",E,E,7,[[["self"]],["page"]]],[11,"clone",E,E,8,[[["self"]],[R[89]]]],[11,R[38],E,E,4,[[],[R[81]]]],[11,R[38],E,E,5,[[],[R[82]]]],[11,R[38],E,E,0,[[],[R[104]]]]],"p":[[3,R[105]],[3,"Frame"],[3,R[106]],[3,R[107]],[3,R[108]],[3,R[109]],[3,R[110]],[3,"Page"],[3,R[111]]]};
searchIndex["memory_x86_64"]={"doc":"This crate implements the virtual memory subsystem…","i":[[3,R[165],"memory_x86_64",E,N,N],[3,R[60],E,R[112],N,N],[5,"get_kernel_address",E,"Finds and returns the relevant addresses for the kernel…",N,[[[R[113]]],[["str"],[R[1],["str"]]]]],[5,"get_available_memory",E,"Gets the available physical memory areas from the…",N,[[[R[82]],[R[113]]],[[R[1],["str"]],["str"]]]],[5,"get_modules_address",E,"Gets the address bounds of physical memory occupied by all…",N,[[[R[113]]]]],[5,"get_boot_info_mem_area",E,"Gets the physical memory area occupied by the bootloader…",N,[[[R[113]]],[[R[104]],["str"],[R[1],[R[104],"str"]]]]],[5,"find_section_memory_bounds",E,"Finds the addresses in memory of the main kernel sections,…",N,[[[R[113]]],[["str"],[R[1],["str"]]]]],[5,"get_vga_mem_addr",E,"Gets the physical memory occupied by vga.",N,[[],[[R[1],["str"]],["str"]]]],[5,"tlb_flush_virt_addr",E,"Flushes the specific virtual address in TLB. ",N,[[[R[81]]]]],[5,"tlb_flush_all",E,"Flushes the whole TLB. ",N,[[]]],[5,"get_p4",E,"Returns the current top-level page table address.",N,[[],[R[82]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[6],E,E,1,[[[U]],[R[1]]]],[11,"into",E,E,1,[[],[U]]],[11,R[7],E,E,1,[[],[R[1]]]],[11,R[8],E,E,1,[[["self"]],[T]]],[11,R[9],E,E,1,[[["self"]],[T]]],[11,R[11],E,E,1,[[["self"]],[R[14]]]],[11,R[64],E,E,1,[[["self"]],[T]]],[11,R[65],E,E,1,[[["self"],[T]]]],[11,"fmt",E,E,0,[[[R[12]],["self"]],[[R[1],["error"]],["error"]]]],[11,"bitor",E,R[114],1,[[[R[57]]],[R[57]]]],[11,"eq",E,E,1,[[["self"],[R[57]]],["bool"]]],[11,"ne",E,E,1,[[["self"],[R[57]]],["bool"]]],[11,R[95],E,R[115],1,[[["self"],[R[57]]]]],[11,"fmt",E,E,1,[[[R[12]],["self"]],[[R[1],["error"]],["error"]]]],[11,"fmt",E,E,1,[[[R[12]],["self"]],[[R[1],["error"]],["error"]]]],[11,"bitand",E,R[116],1,[[[R[57]]],[R[57]]]],[11,"hash",E,E,1,[[["self"],["__h"]]]],[11,R[38],E,E,1,[[],[R[57]]]],[11,"fmt",E,E,1,[[[R[12]],["self"]],[[R[1],["error"]],["error"]]]],[11,R[61],E,E,1,[[["self"],[R[57]]],[[R[31],[R[16]]],[R[16]]]]],[11,"lt",E,E,1,[[["self"],[R[57]]],["bool"]]],[11,"le",E,E,1,[[["self"],[R[57]]],["bool"]]],[11,"gt",E,E,1,[[["self"],[R[57]]],["bool"]]],[11,"ge",E,E,1,[[["self"],[R[57]]],["bool"]]],[11,R[93],E,R[117],1,[[["self"],[R[57]]]]],[11,"sub",E,R[118],1,[[[R[57]]],[R[57]]]],[11,"fmt",E,E,1,[[[R[12]],["self"]],[[R[1],["error"]],["error"]]]],[11,R[96],E,R[119],1,[[["self"],[R[57]]]]],[11,"not",E,R[120],1,[[],[R[57]]]],[11,"cmp",E,E,1,[[["self"],[R[57]]],[R[16]]]],[11,R[121],E,E,1,[[[T]],[R[57]]]],[11,R[97],E,R[122],1,[[["self"],[R[57]]]]],[11,"bitxor",E,R[123],1,[[[R[57]]],[R[57]]]],[11,"fmt",E,E,1,[[[R[12]],["self"]],[[R[1],["error"]],["error"]]]],[11,"extend",E,E,1,[[["self"],[T]]]],[11,"clone",E,E,1,[[["self"]],[R[57]]]],[11,R[86],E,E,0,[[["self"]],["usize"]]],[11,"end_address",E,E,0,[[["self"]],["usize"]]],[11,"total_size",E,E,0,[[["self"]],["usize"]]],[11,"elf_sections_tag",E,E,0,[[["self"]],[[R[31],[R[124]]],[R[124]]]]],[11,"memory_map_tag",E,E,0,[[["self"]],[[R[125]],[R[31],[R[125]]]]]],[11,"module_tags",E,E,0,[[["self"]],["moduleiter"]]],[11,"boot_loader_name_tag",E,E,0,[[["self"]],[[R[31],[R[126]]],[R[126]]]]],[11,"command_line_tag",E,E,0,[[["self"]],[[R[31],[R[127]]],[R[127]]]]],[11,"framebuffer_tag",E,E,0,[[["self"]],[[R[128]],[R[31],[R[128]]]]]],[11,"rsdp_v1_tag",E,E,0,[[["self"]],[[R[129]],[R[31],[R[129]]]]]],[11,"rsdp_v2_tag",E,E,0,[[["self"]],[[R[31],[R[130]]],[R[130]]]]],[11,"is_huge",E,R[131],1,[[["self"]],["bool"]]],[11,R[132],E,R[133],1,[[],[R[57]]]],[11,R[134],E,R[135],1,[[["self"]],["bool"]]],[11,R[136],E,R[137],1,[[],[R[57]]]],[11,R[138],E,R[139],1,[[["self"]],["bool"]]],[11,R[140],E,R[58],1,[[[R[141]]],[R[57]]]],[11,R[142],E,R[58],1,[[["u64"]],[R[57]]]],[11,R[143],E,R[144],1,[[["flags"]],[R[57]]]],[18,"PRESENT",E,E,1,N],[18,R[246],E,E,1,N],[18,R[145],E,E,1,N],[18,R[146],E,E,1,N],[18,R[247],E,E,1,N],[18,R[248],E,E,1,N],[18,"DIRTY",E,E,1,N],[18,R[147],E,E,1,N],[18,"GLOBAL",E,E,1,N],[18,R[148],E,E,1,N],[11,"empty",E,R[149],1,[[],[R[57]]]],[11,"all",E,R[150],1,[[],[R[57]]]],[11,"bits",E,R[151],1,[[["self"]],["u64"]]],[11,R[152],E,R[153],1,[[["u64"]],[[R[57]],[R[31],[R[57]]]]]],[11,R[154],E,R[155],1,[[["u64"]],[R[57]]]],[11,R[47],E,R[156],1,[[["self"]],["bool"]]],[11,"is_all",E,R[157],1,[[["self"]],["bool"]]],[11,R[158],E,R[159],1,[[[R[57]],["self"]],["bool"]]],[11,R[249],E,R[160],1,[[[R[57]],["self"]],["bool"]]],[11,"insert",E,R[161],1,[[["self"],[R[57]]]]],[11,"remove",E,R[162],1,[[["self"],[R[57]]]]],[11,"toggle",E,R[163],1,[[["self"],[R[57]]]]],[11,"set",E,R[164],1,[[["self"],[R[57]],["bool"]]]]],"p":[[3,R[165]],[3,R[60]]]};
searchIndex["mod_mgmt"]={"doc":E,"i":[[5,R[457],R[539],R[458],N,[[["str"]],[["str"],["vec",["str"]]]]],[5,R[459],E,R[460],N,[[["str"]],[["string"],[R[31],["string"]]]]],[5,R[461],E,R[462],N,[[["path"]],["str"]]],[6,R[463],E,R[464],N,N],[6,R[465],E,R[466],N,N],[6,R[467],E,R[468],N,N],[6,R[469],E,R[470],N,N],[6,"Shndx",E,R[471],N,N],[17,R[472],E,R[473],N,N],[17,R[474],E,R[475],N,N],[17,R[476],E,R[477],N,N],[17,R[478],E,R[479],N,N],[17,R[480],E,R[481],N,N],[17,R[482],E,R[483],N,N],[4,R[361],E,R[484],N,N],[13,"Kernel",E,E,0,N],[13,R[485],E,E,0,N],[13,R[486],E,E,0,N],[3,R[355],E,R[487],N,N],[12,R[488],E,R[489],1,N],[12,R[490],E,R[491],1,N],[12,R[492],E,R[493],1,N],[12,"sections",E,R[494],1,N],[12,R[495],E,R[344],1,N],[12,R[496],E,R[344],1,N],[12,R[497],E,R[344],1,N],[12,R[498],E,R[499],1,N],[12,R[500],E,R[501],1,N],[12,R[502],E,R[503],1,N],[4,R[362],E,R[504],N,N],[13,"Text",E,E,2,N],[13,"Rodata",E,E,2,N],[13,"Data",E,E,2,N],[13,"Bss",E,E,2,N],[13,R[505],E,R[506],2,N],[13,"EhFrame",E,R[507],2,N],[3,R[356],E,R[508],N,N],[12,R[509],E,R[510],3,N],[12,R[511],E,R[512],3,N],[3,R[357],E,R[513],N,N],[12,"name",E,R[514],4,N],[12,"typ",E,R[515],4,N],[12,"global",E,R[516],4,N],[12,R[517],E,R[518],4,N],[12,R[519],E,R[520],4,N],[12,R[521],E,R[522],4,N],[12,R[523],E,R[524],4,N],[12,"inner",E,R[525],4,N],[3,R[358],E,R[526],N,N],[12,"section",E,R[527],5,N],[12,R[345],E,R[346],5,N],[3,R[359],E,R[528],N,N],[12,"section",E,R[529],6,N],[12,R[345],E,R[346],6,N],[3,R[360],E,R[530],N,N],[12,"typ",E,R[531],7,N],[12,"addend",E,R[532],7,N],[12,"offset",E,R[533],7,N],[5,R[534],E,R[535],N,[[[R[168]],[R[354]],["usize"],[R[81]],["bool"]],[[R[1],["str"]],["str"]]]],[3,R[593],E,"A wrapper around a `Directory` reference that offers…",N,N],[3,R[595],E,"An application crate that has been loaded into a…",N,N],[3,R[594],E,"This struct represents a namespace of crates and their…",N,N],[4,R[592],E,"A type that can be converted into a crate object file.",N,N],[13,"File",E,"A direct reference to the crate object file. This will be…",8,N],[13,"AbsolutePath",E,"An absolute path that points to the crate object file. ",8,N],[13,"Prefix",E,"A string prefix that will be used to search for the crate…",8,N],[5,"get_initial_kernel_namespace",E,"Returns a reference to the default kernel namespace, which…",N,[[],[["arc"],[R[31],["arc"]]]]],[5,"get_namespaces_directory",E,"Returns the top-level directory that contains all of the…",N,[[],[[R[31],["dirref"]],["dirref"]]]],[5,"create_application_namespace",E,"Create a new application `CrateNamespace` that uses the…",N,[[[R[31],["arc"]],["arc",[R[536]]]],[["arc",[R[536]]],["str"],[R[1],["arc","str"]]]]],[5,"init",E,"Initializes the module management system based on the…",N,[[[R[735]],[R[113]]],[["arc"],[R[1],["arc","str"]],["str"]]]],[5,"find_symbol_table",E,"Returns a reference to the symbol table in the given…",N,[[["elffile"]],[["str"],[R[1],["str"]]]]],[0,R[537],E,"Routines for parsing the `nano_core`, the fully-linked,…",N,N],[5,R[537],"mod_mgmt::parse_nano_core","Parses the nano_core object file that represents the…",N,[[[R[168]],["arc"],["bool"]],[R[1]]]],[0,R[538],R[539],"Routines for replacing the crates that comprise the…",N,N],[5,R[538],"mod_mgmt::replace_nano_core_crates","See the module-level documentation for how this works. ",N,[[[R[541]],["arc"],["mmiref"]],[[R[1],["str"]],["str"]]]],[6,"SymbolMap",R[539],"A \"symbol map\" from a fully-qualified demangled symbol…",N,N],[6,"SymbolMapIter",E,E,N,N],[17,"NAMESPACES_DIRECTORY_NAME",E,"The name of the directory that contains all of the…",N,N],[11,"new",E,"Creates a new `NamespaceDir` that wraps the given `DirRef`.",9,[[["dirref"]],[R[540]]]],[11,"get_file_starting_with",E,"Finds the single file in this directory whose name starts…",9,[[["str"],["self"]],[[R[337]],[R[31],[R[337]]]]]],[11,"get_files_starting_with",E,"Returns the list of files in this Directory whose name…",9,[[["str"],["self"]],[[R[337]],["vec",[R[337]]]]]],[11,"get_file_and_dir_names_starting_with",E,"Returns the list of file and directory names in this…",9,[[["str"],["self"]],[["string"],["vec",["string"]]]]],[11,"get_crate_object_file",E,"Gets the given object file based on its crate name prefix. ",9,[[["str"],["self"]],[[R[337]],[R[31],[R[337]]]]]],[11,"write_crate_object_file",E,"Insert the given crate object file based on its crate type…",9,[[["str"],["self"]],[[R[337]],["str"],[R[1],[R[337],"str"]]]]],[11,"new",E,"Creates a new `CrateNamespace` that is completely empty…",10,[[["string"],[R[31],["arc"]],[R[540]],["arc",[R[536]]]],[R[536]]]],[11,"name",E,"Returns the name of this `CrateNamespace`, which is just…",10,[[["self"]],["str"]]],[11,"dir",E,"Returns the directory that this `CrateNamespace` is based…",10,[[["self"]],[R[540]]]],[11,"recursive_namespace",E,"Returns the recursive namespace that this `CrateNamespace`…",10,[[["self"]],[["arc"],[R[31],["arc"]]]]],[11,"crate_names",E,"Returns a list of all of the crate names currently loaded…",10,[[["self"],["bool"]],[["string"],["vec",["string"]]]]],[11,"for_each_crate",E,"Iterates over all crates in this namespace and calls the…",10,[[["f"],["self"],["bool"]]]],[11,"get_crate",E,R[542],10,[[["str"],["self"]],[[R[31],[R[541]]],[R[541]]]]],[11,"get_crate_and_namespace",E,R[542],10,[[["arc"],["str"]],[R[31]]]],[11,"get_crates_starting_with",E,"Finds the `LoadedCrate`s whose names start with the given…",10,[[["arc"],["str"]],["vec"]]],[11,"get_crate_starting_with",E,"Finds the `LoadedCrate` whose name starts with the given…",10,[[["arc"],["str"]],[R[31]]]],[11,"get_crate_object_files_starting_with",E,"Like `get_crates_starting_with()`, but for crate object…",10,[[["arc"],["str"]],["vec"]]],[11,"get_crate_object_file_starting_with",E,"Like `get_crate_starting_with()`, but for crate object…",10,[[["arc"],["str"]],[R[31]]]],[11,"load_crate_as_application",E,"Loads the specified application crate into this…",10,[[["bool"],["mmiref"],["arc"],[R[337]]],[[R[1],[R[543],"str"]],[R[543]],["str"]]]],[11,"load_crate",E,"Loads the specified crate into memory, allowing it to be…",10,[[[R[31],[R[536]]],["mmiref"],[R[536]],["bool"],["self"],[R[337]]],[[R[1],["str"]],["str"]]]],[11,"load_crates",E,"This function first loads all of the given crates'…",10,[[["bool"],["mmiref"],[R[536]],["i"],["self"],[R[31],[R[536]]]],[[R[1],["str"]],["str"]]]],[11,"clone_on_write",E,"Duplicates this `CrateNamespace` into a new…",10,[[["self"]],[R[536]]]],[11,"rewrite_section_dependents",E,"Finds all of the weak dependents (sections that depend on…",10,[[[R[348]],["mmiref"]],[[R[1],["str"]],["str"]]]],[11,"add_symbols",E,"Adds only global symbols in the given `sections` iterator…",10,[[["i"],["self"],["bool"]],["usize"]]],[11,"get_crate_containing_address",E,"Finds the crate that contains the given `VirtualAddress`…",10,[[["bool"],["self"],[R[81]]],[[R[31],[R[541]]],[R[541]]]]],[11,"get_section_containing_address",E,"Finds the section that contains the given `VirtualAddress`…",10,[[["bool"],["self"],[R[81]]],[R[31]]]],[11,"get_symbol_and_namespace",E,"Like `get_symbol()`, but also returns the exact…",10,[[["str"],["self"]],[R[31]]]],[11,"get_symbol",E,R[544],10,[[["str"],["self"]],[R[545]]]],[11,"get_symbol_or_load",E,R[544],10,[[["str"],["mmiref"],[R[536]],["bool"],["self"],[R[31],[R[536]]]],[R[545]]]],[11,"find_symbols_starting_with",E,"Returns a copied list of the corresponding…",10,[[["str"],["self"]],["vec"]]],[11,"find_symbols_starting_with_and_namespace",E,"Similar to `find_symbols_starting_with`, but also includes…",10,[[["str"],["self"]],["vec"]]],[11,"get_symbol_starting_with",E,"Returns a weak reference to the `LoadedSection` whose name…",10,[[["str"],["self"]],[R[545]]]],[11,"dump_symbol_map",E,"Simple debugging function that returns the entire symbol…",10,[[["self"]],["string"]]],[11,"dump_symbol_map_recursive",E,"Same as `dump_symbol_map()`, but includes symbols from…",10,[[["self"]],["string"]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[6],E,E,1,[[[U]],[R[1]]]],[11,"into",E,E,1,[[],[U]]],[11,R[7],E,E,1,[[],[R[1]]]],[11,R[8],E,E,1,[[["self"]],[T]]],[11,R[9],E,E,1,[[["self"]],[T]]],[11,R[11],E,E,1,[[["self"]],[R[14]]]],[11,"from",E,E,2,[[[T]],[T]]],[11,R[6],E,E,2,[[[U]],[R[1]]]],[11,"into",E,E,2,[[],[U]]],[11,R[7],E,E,2,[[],[R[1]]]],[11,R[8],E,E,2,[[["self"]],[T]]],[11,R[9],E,E,2,[[["self"]],[T]]],[11,R[11],E,E,2,[[["self"]],[R[14]]]],[11,R[64],E,E,2,[[["self"]],[T]]],[11,R[65],E,E,2,[[["self"],[T]]]],[11,"from",E,E,3,[[[T]],[T]]],[11,R[6],E,E,3,[[[U]],[R[1]]]],[11,"into",E,E,3,[[],[U]]],[11,R[7],E,E,3,[[],[R[1]]]],[11,R[8],E,E,3,[[["self"]],[T]]],[11,R[9],E,E,3,[[["self"]],[T]]],[11,R[11],E,E,3,[[["self"]],[R[14]]]],[11,"from",E,E,4,[[[T]],[T]]],[11,R[6],E,E,4,[[[U]],[R[1]]]],[11,"into",E,E,4,[[],[U]]],[11,R[7],E,E,4,[[],[R[1]]]],[11,R[8],E,E,4,[[["self"]],[T]]],[11,R[9],E,E,4,[[["self"]],[T]]],[11,R[11],E,E,4,[[["self"]],[R[14]]]],[11,"from",E,E,5,[[[T]],[T]]],[11,R[6],E,E,5,[[[U]],[R[1]]]],[11,"into",E,E,5,[[],[U]]],[11,R[7],E,E,5,[[],[R[1]]]],[11,R[8],E,E,5,[[["self"]],[T]]],[11,R[9],E,E,5,[[["self"]],[T]]],[11,R[11],E,E,5,[[["self"]],[R[14]]]],[11,R[64],E,E,5,[[["self"]],[T]]],[11,R[65],E,E,5,[[["self"],[T]]]],[11,"from",E,E,6,[[[T]],[T]]],[11,R[6],E,E,6,[[[U]],[R[1]]]],[11,"into",E,E,6,[[],[U]]],[11,R[7],E,E,6,[[],[R[1]]]],[11,R[8],E,E,6,[[["self"]],[T]]],[11,R[9],E,E,6,[[["self"]],[T]]],[11,R[11],E,E,6,[[["self"]],[R[14]]]],[11,R[64],E,E,6,[[["self"]],[T]]],[11,R[65],E,E,6,[[["self"],[T]]]],[11,"from",E,E,7,[[[T]],[T]]],[11,R[6],E,E,7,[[[U]],[R[1]]]],[11,"into",E,E,7,[[],[U]]],[11,R[7],E,E,7,[[],[R[1]]]],[11,R[8],E,E,7,[[["self"]],[T]]],[11,R[9],E,E,7,[[["self"]],[T]]],[11,R[11],E,E,7,[[["self"]],[R[14]]]],[11,R[64],E,E,7,[[["self"]],[T]]],[11,R[65],E,E,7,[[["self"],[T]]]],[11,"from",E,E,9,[[[T]],[T]]],[11,R[6],E,E,9,[[[U]],[R[1]]]],[11,"into",E,E,9,[[],[U]]],[11,R[7],E,E,9,[[],[R[1]]]],[11,R[8],E,E,9,[[["self"]],[T]]],[11,R[9],E,E,9,[[["self"]],[T]]],[11,R[11],E,E,9,[[["self"]],[R[14]]]],[11,R[64],E,E,9,[[["self"]],[T]]],[11,R[65],E,E,9,[[["self"],[T]]]],[11,"from",E,E,11,[[[T]],[T]]],[11,R[6],E,E,11,[[[U]],[R[1]]]],[11,"into",E,E,11,[[],[U]]],[11,R[7],E,E,11,[[],[R[1]]]],[11,R[8],E,E,11,[[["self"]],[T]]],[11,R[9],E,E,11,[[["self"]],[T]]],[11,R[11],E,E,11,[[["self"]],[R[14]]]],[11,"from",E,E,10,[[[T]],[T]]],[11,R[6],E,E,10,[[[U]],[R[1]]]],[11,"into",E,E,10,[[],[U]]],[11,R[7],E,E,10,[[],[R[1]]]],[11,R[8],E,E,10,[[["self"]],[T]]],[11,R[9],E,E,10,[[["self"]],[T]]],[11,R[11],E,E,10,[[["self"]],[R[14]]]],[11,"from",E,E,8,[[[T]],[T]]],[11,R[6],E,E,8,[[[U]],[R[1]]]],[11,"into",E,E,8,[[],[U]]],[11,R[7],E,E,8,[[],[R[1]]]],[11,R[8],E,E,8,[[["self"]],[T]]],[11,R[9],E,E,8,[[["self"]],[T]]],[11,R[11],E,E,8,[[["self"]],[R[14]]]],[11,"fmt",E,E,7,[[[R[12]],["self"]],[[R[1],["error"]],["error"]]]],[11,"fmt",E,E,6,[[[R[12]],["self"]],[[R[1],["error"]],["error"]]]],[11,"fmt",E,E,1,[[[R[12]],["self"]],[[R[1],["error"]],["error"]]]],[11,"fmt",E,E,4,[[[R[12]],["self"]],[[R[1],["error"]],["error"]]]],[11,"fmt",E,E,0,[[[R[12]],["self"]],[[R[1],["error"]],["error"]]]],[11,"fmt",E,E,2,[[[R[12]],["self"]],[[R[1],["error"]],["error"]]]],[11,"fmt",E,E,5,[[[R[12]],["self"]],[[R[1],["error"]],["error"]]]],[11,"eq",E,E,2,[[[R[351]],["self"]],["bool"]]],[11,"eq",E,E,0,[[[R[546]],["self"]],["bool"]]],[11,"eq",E,E,7,[[[R[354]],["self"]],["bool"]]],[11,"ne",E,E,7,[[[R[354]],["self"]],["bool"]]],[11,"drop",E,E,1,[[["self"]]]],[11,"clone",E,E,6,[[["self"]],[R[350]]]],[11,"clone",E,E,5,[[["self"]],[R[352]]]],[11,"clone",E,E,7,[[["self"]],[R[354]]]],[11,"clone",E,E,2,[[["self"]],[R[351]]]],[11,R[38],E,E,3,[[],[R[547]]]],[11,"fmt",E,E,9,[[["self"],[R[12]]],[R[1]]]],[11,"fmt",E,E,8,[[["self"],[R[12]]],[R[1]]]],[11,"deref",E,E,9,[[["self"]],["dirref"]]],[11,"deref",E,E,11,[[["self"]],[R[541]]]],[11,"drop",E,E,11,[[["self"]]]],[11,"clone",E,E,9,[[["self"]],[R[540]]]],[11,R[548],E,R[549],0,[[["self"]],["str"]]],[11,R[550],E,R[551],0,[[["str"]],[["str"],[R[1],["str"]]]]],[11,R[552],E,R[553],0,[[["str"]],["bool"]]],[11,R[554],E,R[347],0,[[["str"]],["bool"]]],[11,R[555],E,R[347],0,[[["str"]],["bool"]]],[11,R[556],E,R[557],1,[[["str"],["self"]],[["arc"],[R[31],["arc"]]]]],[11,R[558],E,R[559],1,[[["self"]]]],[11,R[560],E,R[561],1,[[["self"]]]],[11,R[562],E,R[563],1,[[["self"],["f"]],[["arc"],[R[31],["arc"]]]]],[11,R[564],E,R[565],1,[[["self"]],["str"]]],[11,R[566],E,R[567],1,[[["self"]],["string"]]],[11,R[568],E,R[569],1,[[["self"]],[["vec",[R[578]]],[R[578],[R[572]]]]]],[11,R[570],E,R[571],1,[[["self"]],[["vec",[R[578]]],[R[578],[R[572]]]]]],[11,R[573],E,R[574],2,[[["self"]],["bool"]]],[11,"new",E,R[575],4,[[[R[351]],["string"],[R[578],[R[572]]],[R[572]],["mutex",[R[168]]],["bool"],["arc",["mutex"]],["usize"],[R[81]]],[R[353]]]],[11,R[576],E,R[577],4,[[["vec",[R[350]]],[R[351]],["string"],[R[578],[R[572]]],[R[572]],["mutex",[R[168]]],["bool"],["arc",["mutex"]],["usize"],[R[352]],[R[81]],["vec",[R[352]]],[R[350]]],[R[353]]]],[11,R[86],E,R[579],4,[[["self"]],[R[81]]]],[11,"size",E,R[580],4,[[["self"]],["usize"]]],[11,"get_type",E,R[581],4,[[["self"]],[R[351]]]],[11,R[582],E,R[583],4,[[["self"]],["str"]]],[11,R[584],E,R[585],4,[[["str"]],["str"]]],[11,R[586],E,R[587],4,[[["arc"],["self"]],[[R[31],["usize"]],["usize"]]]],[11,R[588],E,R[589],4,[[["self"],[R[353]]],[[R[1],["str"]],["str"]]]],[11,R[590],E,E,7,[[["rela"]],[R[354]]]],[11,R[394],E,R[591],7,[[["self"]],["bool"]]]],"p":[[4,R[361]],[3,R[355]],[4,R[362]],[3,R[356]],[3,R[357]],[3,R[358]],[3,R[359]],[3,R[360]],[4,R[592]],[3,R[593]],[3,R[594]],[3,R[595]]]};
searchIndex["mouse"]={"doc":E,"i":[[5,"init","mouse","Initialize the mouse driver.",N,[[["queue",["event"]],["event"]]]],[5,"mouse_to_print",E,"print the mouse actions",N,[[["mouseevent"]]]],[5,"handle_mouse_input",E,"return a Mouse Event according to the data",N,[[["u32"]],[[R[1],["str"]],["str"]]]]],"p":[]};
searchIndex["multicore_bringup"]={"doc":"Functions for initializing and bringing up other CPU cores. ","i":[[3,R[762],"multicore_bringup","A structure to access framebuffer information that was…",N,N],[12,"width",E,E,0,N],[12,"height",E,E,0,N],[12,R[761],E,E,0,N],[5,"handle_ap_cores",E,"Starts up and sets up AP cores based on system information…",N,[[[R[81]],["arc",[R[682]]],[R[682],[R[735]]]],[["str"],["usize"],[R[1],["usize","str"]]]]],[7,"GRAPHIC_INFO",E,E,N,N],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]]],"p":[[3,R[762]]]};
searchIndex["multiple_heaps"]={"doc":"An implementation of an allocator that uses multiple…","i":[[3,R[391],"multiple_heaps","An allocator that contains multiple heaps. The heap that…",N,N],[5,"switch_to_multiple_heaps",E,"The setup routine for multiple heaps. It creates and…",N,[[],[[R[1],["str"]],["str"]]]],[5,"init_individual_heap",E,"Initializes the heap given by `key`. There are 11 size…",N,[[[R[390]],["usize"]],[[R[1],["str"]],["str"]]]],[17,"PER_CORE_HEAP_INITIAL_SIZE_PAGES",E,"Starting size of each per-core heap. ",N,N],[11,"empty",E,E,0,[[],[R[390]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,"alloc",E,"Allocates the given `layout` from the heap of the core the…",0,[[[R[0]],["self"]]]],[11,"dealloc",E,"Deallocates the memory at the address given by `ptr`.…",0,[[["self"],[R[0]]]]]],"p":[[3,R[391]]]};
searchIndex["mutex_sleep"]={"doc":"A mutex that puts tasks to sleep while they wait for the…","i":[[3,R[715],"mutex_sleep","A mutual exclusion wrapper that puts a `Task` to sleep…",N,N],[3,R[716],E,"A guard that allows the locked data to be accessed, during…",N,N],[6,"MutexSleepGuardRef",E,"Typedef of a owning reference that uses a…",N,N],[6,"MutexSleepGuardRefMut",E,"Typedef of a mutable owning reference that uses a…",N,N],[11,"new",E,"Creates a new lock wrapping the supplied data.",0,[[[T]],[R[714]]]],[11,"into_inner",E,"Consumes this `MutexSleep`, returning the underlying data.",0,[[],[T]]],[11,"lock",E,"Blocks until the lock is acquired by putting this `Task`…",0,[[["self"]],[[R[1],[R[713],"str"]],["str"],[R[713]]]]],[11,"try_lock",E,"Tries to lock the MutexSleep. If it is already locked, it…",0,[[["self"]],[[R[31],[R[713]]],[R[713]]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[6],E,E,1,[[[U]],[R[1]]]],[11,"into",E,E,1,[[],[U]]],[11,R[7],E,E,1,[[],[R[1]]]],[11,R[8],E,E,1,[[["self"]],[T]]],[11,R[9],E,E,1,[[["self"]],[T]]],[11,R[11],E,E,1,[[["self"]],[R[14]]]],[11,"fmt",E,E,0,[[["self"],[R[12]]],[R[1]]]],[11,"deref",E,E,1,[[["self"]],[T]]],[11,R[99],E,E,1,[[["self"]],[T]]],[11,"drop",E,E,1,[[["self"]]]],[11,R[38],E,E,0,[[],[R[714]]]]],"p":[[3,R[715]],[3,R[716]]]};
searchIndex["nano_core"]={"doc":"The aptly-named tiny crate containing the first OS code to…","i":[[5,"nano_core_start","nano_core","The main entry point into Theseus, that is, the first Rust…",N,[[["usize"]]]]],"p":[]};
searchIndex["network_interface_card"]={"doc":E,"i":[[8,R[373],"network_interface_card","A trait that defines the necessary minimum functions that…",N,N],[10,R[688],E,"Sends a packet contained in the given `transmit_buffer`…",0,[[["self"],[R[288]]],[[R[1],["str"]],["str"]]]],[10,R[689],E,"Returns the earliest `ReceivedFrame`, which is essentially…",0,[[["self"]],[[R[31],[R[372]]],[R[372]]]]],[10,R[690],E,"Poll the NIC for received frames. Can be used as an…",0,[[["self"]],[[R[1],["str"]],["str"]]]],[10,R[691],E,"Returns the MAC address that this NIC is configured with.…",0,[[["self"]]]]],"p":[[8,R[373]]]};
searchIndex["network_manager"]={"doc":E,"i":[[3,R[719],"network_manager","A list of all of the available and initialized network…",N,N],[5,"add_to_network_interfaces",E,"Add a Nic to the global list of network interfaces. The…",N,[[["send"],["networkinterface"]]]],[6,"NetworkInterfaceRef",E,R[374],N,N],[8,R[718],E,"A trait that represents a Network Interface within…",N,N],[10,R[730],E,"Get the Ethernet address of the interface.",0,[[["self"]],[R[717]]]],[10,R[731],E,"Set the Ethernet address of the interface.",0,[[["self"],[R[717]]]]],[10,"poll",E,"Polls (or flushes) the network interface, which should be…",0,[[["self"],[R[724]],["instant"]],[[R[1],["bool"]],["bool"]]]],[10,"ip_addrs",E,"Get the IP addresses of the interface.",0,[[["self"]]]],[10,R[732],E,"Check whether the interface has the given IP address…",0,[[["self"],[R[725]]],["bool"]]],[10,"routes",E,E,0,[[["self"]],["routes"]]],[10,R[733],E,E,0,[[["self"]],["routes"]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[6],E,E,1,[[[U]],[R[1]]]],[11,"into",E,E,1,[[],[U]]],[11,R[7],E,E,1,[[],[R[1]]]],[11,R[8],E,E,1,[[["self"]],[T]]],[11,R[9],E,E,1,[[["self"]],[T]]],[11,R[11],E,E,1,[[["self"]],[R[14]]]],[11,"deref",E,E,1,[[["self"]],["mutex"]]],[11,R[442],E,E,1,[[["self"]]]]],"p":[[8,R[718]],[3,R[719]]]};
searchIndex["nic_buffers"]={"doc":"Defines buffers that are used to send and receive packets.","i":[[3,R[289],"nic_buffers","A buffer that stores a packet to be transmitted through…",N,N],[12,"mp",E,E,0,N],[12,R[287],E,E,0,N],[12,"length",E,E,0,N],[3,R[290],E,"A buffer that stores a packet (a piece of an Ethernet…",N,N],[12,"mp",E,E,1,N],[12,R[287],E,E,1,N],[12,"length",E,E,1,N],[3,R[291],E,"A network (e.g., Ethernet) frame that has been received by…",N,N],[12,"0",E,E,2,N],[11,"new",E,"Creates a new TransmitBuffer with the specified size in…",0,[[["u16"]],[["str"],[R[1],[R[288],"str"]],[R[288]]]]],[11,"new",E,"Creates a new ReceiveBuffer with the given `MappedPages`,…",1,[[["queue"],[R[82]],["u16"],[R[168]]],["receivebuffer"]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[6],E,E,1,[[[U]],[R[1]]]],[11,"into",E,E,1,[[],[U]]],[11,R[7],E,E,1,[[],[R[1]]]],[11,R[8],E,E,1,[[["self"]],[T]]],[11,R[9],E,E,1,[[["self"]],[T]]],[11,R[11],E,E,1,[[["self"]],[R[14]]]],[11,"from",E,E,2,[[[T]],[T]]],[11,R[6],E,E,2,[[[U]],[R[1]]]],[11,"into",E,E,2,[[],[U]]],[11,R[7],E,E,2,[[],[R[1]]]],[11,R[8],E,E,2,[[["self"]],[T]]],[11,R[9],E,E,2,[[["self"]],[T]]],[11,R[11],E,E,2,[[["self"]],[R[14]]]],[11,"deref",E,E,0,[[["self"]],[R[168]]]],[11,"deref",E,E,1,[[["self"]],[R[168]]]],[11,R[99],E,E,0,[[["self"]],[R[168]]]],[11,R[99],E,E,1,[[["self"]],[R[168]]]],[11,"drop",E,E,1,[[["self"]]]]],"p":[[3,R[289]],[3,R[290]],[3,R[291]]]};
searchIndex["nic_initialization"]={"doc":"Functions that are used in a NIC initialization procedure.","i":[[5,"allocate_device_register_memory","nic_initialization","Allocates memory for the NIC registers",N,[[[R[82]],[R[281]]],[["str"],[R[1],[R[168],"str"]],[R[168]]]]],[5,"allocate_memory",E,"Helper function to allocate memory at required address",N,[[[R[82]],["usize"]],[["str"],[R[1],[R[168],"str"]],[R[168]]]]],[5,"init_rx_buf_pool",E,"Initialize the receive buffer pool from where receive…",N,[[["u16"],["usize"],["queue"]],[[R[1],["str"]],["str"]]]],[5,"init_rx_queue",E,"Steps to create and initialize a receive descriptor queue",N,[[[R[387]],["usize"],["queue"],[R[387]],[R[387]],[R[387]],[R[387]]],[[R[1],["str"]],["str"]]]],[5,"init_tx_queue",E,"Steps to create and initialize a transmit descriptor queue",N,[[[R[387]],[R[387]],["usize"],[R[387]],[R[387]],[R[387]]],[[R[1],[R[366],"str"]],[R[366],[R[168]]],["str"]]]],[17,"NIC_MAPPING_FLAGS",E,"The mapping flags used for pages that the NIC will map.",N,N]],"p":[]};
searchIndex["nic_queues"]={"doc":"Defines the receive and transmit queues that store a ring…","i":[[3,"RxQueue","nic_queues","A struct that holds all information for one receive queue.…",N,N],[12,"id",E,R[388],0,N],[12,"rx_descs",E,"Receive descriptors",0,N],[12,"rx_cur",E,"Current receive descriptor index",0,N],[12,"rx_bufs_in_use",E,"The list of rx buffers, in which the index in the vector…",0,N],[12,"received_frames",E,"The queue of received Ethernet frames, ready for…",0,N],[12,"cpu_id",E,R[389],0,N],[3,"TxQueue",E,"A struct that holds all information for a transmit queue.…",N,N],[12,"id",E,R[388],1,N],[12,"tx_descs",E,"Transmit descriptors ",1,N],[12,"tx_cur",E,"Current transmit descriptor index",1,N],[12,"cpu_id",E,R[389],1,N],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[6],E,E,1,[[[U]],[R[1]]]],[11,"into",E,E,1,[[],[U]]],[11,R[7],E,E,1,[[],[R[1]]]],[11,R[8],E,E,1,[[["self"]],[T]]],[11,R[9],E,E,1,[[["self"]],[T]]],[11,R[11],E,E,1,[[["self"]],[R[14]]]]],"p":[[3,"RxQueue"],[3,"TxQueue"]]};
searchIndex["ota_update_client"]={"doc":"Functions to communicate with a network server that…","i":[[3,R[760],"ota_update_client","A file that has been downloaded over the network,…",N,N],[12,"name",E,E,0,N],[12,"content",E,E,0,N],[3,"Diff",E,"A representation of an diff file used to define an…",N,N],[12,"pairs",E,"A list of tuples in which the first element is the old…",1,N],[12,"state_transfer_functions",E,"The list of state transfer functions which should be…",1,N],[4,"CrateSet",E,"An enum used for specifying which crate files to download…",N,N],[13,"Include",E,"The set of crates to include, i.e., only these crates will…",2,N],[13,"Exclude",E,"The set of crates to exclude, i.e., all crates except for…",2,N],[5,"default_remote_endpoint",E,"The default remote endpoint, server IP and port, of the…",N,[[],[R[758]]]],[5,"download_available_update_builds",E,R[759],N,[[[R[723]],[R[758]]],[[R[1],["vec","str"]],["vec",["string"]],["str"]]]],[5,"download_listing",E,R[759],N,[[["str"],[R[723]],[R[758]]],[[R[1],["vec","str"]],["vec",["string"]],["str"]]]],[5,"download_diff",E,R[759],N,[[["str"],[R[723]],[R[758]]],[[R[1],["vec","str"]],["vec",["string"]],["str"]]]],[5,"as_lines",E,"Convenience function for converting a byte stream that is…",N,[[],[[R[1],["vec","str"]],["vec",["string"]],["str"]]]],[5,"parse_diff_lines",E,"Parses a series of diff lines into a representation of an…",N,[[["vec"]],[[R[1],["diff","str"]],["diff"],["str"]]]],[5,"download_crates",E,R[759],N,[[["str"],["string"],[R[723]],[R[758]],["btreeset",["string"]]],[["vec",["downloadedfile"]],[R[1],["vec","str"]],["str"]]]],[17,"DIFF_FILE_NAME",E,"The name (and relative path) of the diff file inside each…",N,N],[11,"includes",E,"Returns true if this `CrateSet` specifies that the given…",2,[[["str"],["self"]],["bool"]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[6],E,E,1,[[[U]],[R[1]]]],[11,"into",E,E,1,[[],[U]]],[11,R[7],E,E,1,[[],[R[1]]]],[11,R[8],E,E,1,[[["self"]],[T]]],[11,R[9],E,E,1,[[["self"]],[T]]],[11,R[11],E,E,1,[[["self"]],[R[14]]]],[11,"from",E,E,2,[[[T]],[T]]],[11,R[6],E,E,2,[[[U]],[R[1]]]],[11,"into",E,E,2,[[],[U]]],[11,R[7],E,E,2,[[],[R[1]]]],[11,R[8],E,E,2,[[["self"]],[T]]],[11,R[9],E,E,2,[[["self"]],[T]]],[11,R[11],E,E,2,[[["self"]],[R[14]]]]],"p":[[3,R[760]],[3,"Diff"],[4,"CrateSet"]]};
searchIndex["panic_entry"]={"doc":"Provides the default entry points and lang items for…","i":[],"p":[]};
searchIndex["panic_wrapper"]={"doc":"Provides types and simple routines for handling panics.…","i":[[5,R[740],R[740],"Performs the standard panic handling routine, which…",N,[[[R[627]]],[[R[1],["str"]],["str"]]]]],"p":[]};
searchIndex["path"]={"doc":E,"i":[[3,"Path","path","A structure that represents a file  ",N,N],[4,R[395],E,E,N,N],[13,"RootDir",E,E,0,N],[13,"ParentDir",E,E,0,N],[13,"CurrentDir",E,E,0,N],[17,"PATH_DELIMITER",E,E,N,N],[17,"EXTENSION_DELIMITER",E,E,N,N],[11,"new",E,"Creates a new `Path` from the given String.",1,[[["string"]],["self"]]],[11,"components",E,"Returns an iterator over the components of this `Path`,…",1,[[["self"]]]],[11,"rcomponents",E,"Returns a reverse iterator over the components of this…",1,[[["self"]]]],[11,"basename",E,"Returns just the file name, i.e., the trailling component…",1,[[["self"]],["str"]]],[11,"file_stem",E,"Like `basename()`, but excludes the file extension, if…",1,[[["self"]],["str"]]],[11,"extension",E,"Returns the file extension, if present. If there are…",1,[[["self"]],[["str"],[R[31],["str"]]]]],[11,"relative",E,"Expresses the current Path, self, relative to another…",1,[[["self"],["path"]],[[R[31],["path"]],["path"]]]],[11,R[394],E,"Returns a boolean indicating whether this Path is…",1,[[["self"]],["bool"]]],[11,"get",E,"Returns the file or directory specified by the given path,…",1,[[["self"],["dirref"]],[[R[328]],[R[31],[R[328]]]]]],[11,"get_absolute",E,"Returns the file or directory specified by the given…",1,[[["path"]],[[R[328]],[R[31],[R[328]]]]]],[11,"as_string",E,E,0,[[],["string"]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[6],E,E,1,[[[U]],[R[1]]]],[11,"into",E,E,1,[[],[U]]],[11,R[7],E,E,1,[[],[R[1]]]],[11,R[8],E,E,1,[[["self"]],[T]]],[11,R[9],E,E,1,[[["self"]],[T]]],[11,R[11],E,E,1,[[["self"]],[R[14]]]],[11,R[64],E,E,1,[[["self"]],[T]]],[11,R[65],E,E,1,[[["self"],[T]]]],[11,R[176],E,E,1,[[["self"]],["string"]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,"from",E,E,1,[[["string"]],["self"]]],[11,"fmt",E,E,1,[[["self"],[R[12]]],[[R[1],["error"]],["error"]]]],[11,"fmt",E,E,1,[[[R[12]],["self"]],[R[1]]]],[11,"eq",E,E,1,[[["self"],["path"]],["bool"]]],[11,"ne",E,E,1,[[["self"],["path"]],["bool"]]],[11,"deref",E,E,1,[[["self"]],["string"]]],[11,R[99],E,E,1,[[["self"]],["string"]]],[11,"hash",E,E,1,[[["self"],["__h"]]]],[11,"clone",E,E,1,[[["self"]],["path"]]]],"p":[[4,R[395]],[3,"Path"]]};
searchIndex["pause"]={"doc":"Offers the 'pause' instruction, which rustc used to use…","i":[[5,"spin_loop_hint","pause","A wrapper around the `pause` x86 ASM function. On non-x86…",N,[[]]]],"p":[]};
searchIndex["pci"]={"doc":E,"i":[[3,"PciBus","pci","A PCI bus, which contains a list of PCI devices on that bus.",N,N],[12,"bus_number",E,"The number identifier of this PCI bus.",0,N],[12,"devices",E,"The list of devices attached to this PCI bus.",0,N],[3,R[285],E,"The bus, slot, and function number of a given PCI device.…",N,N],[3,R[283],E,"Contains information common to every type of PCI Device,…",N,N],[12,"location",E,"the bus, slot, and function number that locates this PCI…",1,N],[12,"class",E,"The class code, used to determine device type:…",1,N],[12,"subclass",E,"The subclass code, used to determine device type:…",1,N],[12,"prog_if",E,"The programming interface of this PCI device",1,N],[12,"bars",E,"The six Base Address Registers (BARs)",1,N],[12,R[371],E,E,1,N],[12,"device_id",E,E,1,N],[12,"command",E,E,1,N],[12,"status",E,E,1,N],[12,"revision_id",E,E,1,N],[12,"cache_line_size",E,E,1,N],[12,"latency_timer",E,E,1,N],[12,"header_type",E,E,1,N],[12,"bist",E,E,1,N],[12,"int_pin",E,E,1,N],[12,"int_line",E,E,1,N],[4,R[284],E,"Lists the 2 possible PCI configuration space access…",N,N],[13,"MemoryMapped",E,E,2,N],[13,"IoPort",E,E,2,N],[5,"get_pci_buses",E,"Returns a list of all PCI buses in this system. If the PCI…",N,[[],["vec"]]],[5,"get_pci_device_bsf",E,"Returns a reference to the `PciDevice` with the given bus,…",N,[[["u16"]],[[R[281]],[R[31],[R[281]]]]]],[5,"pci_device_iter",E,"Returns an iterator that iterates over all `PciDevice`s,…",N,[[]]],[17,"PCI_VENDOR_ID",E,E,N,N],[17,"PCI_DEVICE_ID",E,E,N,N],[17,"PCI_COMMAND",E,E,N,N],[17,"PCI_STATUS",E,E,N,N],[17,"PCI_REVISION_ID",E,E,N,N],[17,"PCI_PROG_IF",E,E,N,N],[17,"PCI_SUBCLASS",E,E,N,N],[17,"PCI_CLASS",E,E,N,N],[17,"PCI_CACHE_LINE_SIZE",E,E,N,N],[17,"PCI_LATENCY_TIMER",E,E,N,N],[17,"PCI_HEADER_TYPE",E,E,N,N],[17,"PCI_BIST",E,E,N,N],[17,"PCI_BAR0",E,E,N,N],[17,"PCI_BAR1",E,E,N,N],[17,"PCI_BAR2",E,E,N,N],[17,"PCI_BAR3",E,E,N,N],[17,"PCI_BAR4",E,E,N,N],[17,"PCI_BAR5",E,E,N,N],[17,"PCI_CARDBUS_CIS",E,E,N,N],[17,"PCI_SUBSYSTEM_VENDOR_ID",E,E,N,N],[17,"PCI_SUBSYSTEM_ID",E,E,N,N],[17,"PCI_EXPANSION_ROM_BASE",E,E,N,N],[17,"PCI_CAPABILITIES",E,E,N,N],[17,"PCI_INTERRUPT_LINE",E,E,N,N],[17,"PCI_INTERRUPT_PIN",E,E,N,N],[17,"PCI_MIN_GRANT",E,E,N,N],[17,"PCI_MAX_LATENCY",E,E,N,N],[17,"MSI_CAPABILITY",E,E,N,N],[17,"MSIX_CAPABILITY",E,E,N,N],[11,"bus",E,E,3,[[["self"]],["u16"]]],[11,"slot",E,E,3,[[["self"]],["u16"]]],[11,"function",E,E,3,[[["self"]],["u16"]]],[11,"pci_read_32",E,"read 32-bit data at the specified `offset` from the PCI…",3,[[["u16"],["self"]],["u32"]]],[11,"pci_read_16",E,"Read 16-bit data at the specified `offset` from this PCI…",3,[[["u16"],["self"]],["u16"]]],[11,"pci_read_8",E,"Read 8-bit data at the specified `offset` from the PCI…",3,[[["u16"],["self"]],["u8"]]],[11,"pci_write",E,"Write 32-bit data to the specified `offset` for the PCI…",3,[[["u16"],["u32"],["self"]]]],[11,"pci_set_command_bus_master_bit",E,"Sets the PCI device's bit 3 in the command portion, which…",3,[[["self"]]]],[11,"pci_set_interrupt_disable_bit",E,"Sets the PCI device's command bit 10 to disable legacy…",3,[[["self"]]]],[11,"find_pci_capability",E,"Explores the PCI config space and returns address of…",3,[[["u16"],["self"]],[[R[31],["u16"]],["u16"]]]],[11,"determine_mem_base",E,"Returns the base address of the memory mapped registers of…",1,[[["self"]],[[R[1],[R[82],"str"]],[R[82]],["str"]]]],[11,"determine_mem_size",E,"Returns the amount of space needed for a PCI device's…",1,[[["self"]],["u32"]]],[11,"pci_enable_msi",E,"Enable MSI interrupts for a PCI device. We assume the…",1,[[["self"],["u8"]],[[R[1],["str"]],["str"]]]],[11,"pci_enable_msix",E,"Enable MSI-X interrupts for a PCI device. Only the enable…",1,[[["self"]],[[R[1],["str"]],["str"]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,"from",E,E,3,[[[T]],[T]]],[11,R[6],E,E,3,[[[U]],[R[1]]]],[11,"into",E,E,3,[[],[U]]],[11,R[7],E,E,3,[[],[R[1]]]],[11,R[8],E,E,3,[[["self"]],[T]]],[11,R[9],E,E,3,[[["self"]],[T]]],[11,R[11],E,E,3,[[["self"]],[R[14]]]],[11,R[64],E,E,3,[[["self"]],[T]]],[11,R[65],E,E,3,[[["self"],[T]]]],[11,R[176],E,E,3,[[["self"]],["string"]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[6],E,E,1,[[[U]],[R[1]]]],[11,"into",E,E,1,[[],[U]]],[11,R[7],E,E,1,[[],[R[1]]]],[11,R[8],E,E,1,[[["self"]],[T]]],[11,R[9],E,E,1,[[["self"]],[T]]],[11,R[11],E,E,1,[[["self"]],[R[14]]]],[11,"from",E,E,2,[[[T]],[T]]],[11,R[6],E,E,2,[[[U]],[R[1]]]],[11,"into",E,E,2,[[],[U]]],[11,R[7],E,E,2,[[],[R[1]]]],[11,R[8],E,E,2,[[["self"]],[T]]],[11,R[9],E,E,2,[[["self"]],[T]]],[11,R[11],E,E,2,[[["self"]],[R[14]]]],[11,"fmt",E,E,3,[[["self"],[R[12]]],[[R[1],["error"]],["error"]]]],[11,"fmt",E,E,0,[[[R[12]],["self"]],[R[1]]]],[11,"fmt",E,E,3,[[["self"],[R[12]]],[[R[1],["error"]],["error"]]]],[11,"fmt",E,E,1,[[[R[12]],["self"]],[R[1]]]],[11,"deref",E,E,1,[[["self"]],[R[282]]]],[11,R[99],E,E,1,[[["self"]],[R[282]]]],[11,"clone",E,E,3,[[["self"]],[R[282]]]]],"p":[[3,"PciBus"],[3,R[283]],[4,R[284]],[3,R[285]]]};
searchIndex["pic"]={"doc":"Support for the x86 PIC (8259 Programmable Interrupt…","i":[[3,R[335],"pic","Each PIC chip has two interrupt status registers: the…",N,N],[12,"master_isr",E,E,0,N],[12,"master_irr",E,E,0,N],[12,"slave_isr",E,E,0,N],[12,"slave_irr",E,E,0,N],[3,R[336],E,"A pair of chained PIC controllers. This is the standard…",N,N],[17,"PIC_MASTER_OFFSET",E,E,N,N],[11,"init",E,"Create a new interface for the standard PIC1 and PIC2…",1,[[["u8"]],["chainedpics"]]],[11,"mask_irqs",E,"Each mask is a bitwise mask for each IRQ line, with the…",1,[[["self"],["u8"]]]],[11,"notify_end_of_interrupt",E,"Figure out which (if any) PICs in our chain need to know…",1,[[["self"],["u8"]]]],[11,"read_isr_irr",E,"Reads the ISR and IRR registers of both the master and…",1,[[["self"]],["irqstatusregisters"]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,R[176],E,E,0,[[["self"]],["string"]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[6],E,E,1,[[[U]],[R[1]]]],[11,"into",E,E,1,[[],[U]]],[11,R[7],E,E,1,[[],[R[1]]]],[11,R[8],E,E,1,[[["self"]],[T]]],[11,R[9],E,E,1,[[["self"]],[T]]],[11,R[11],E,E,1,[[["self"]],[R[14]]]],[11,"fmt",E,E,0,[[["self"],[R[12]]],[R[1]]]],[11,"fmt",E,E,0,[[["self"],[R[12]]],[R[1]]]]],"p":[[3,R[335]],[3,R[336]]]};
searchIndex["pit_clock"]={"doc":"Support for the Programmable Interval Timer (PIT) system…","i":[[5,"init","pit_clock",E,N,[[["u32"]]]],[5,"pit_wait",E,"Wait a certain number of microseconds, max 55555…",N,[[["u32"]],[[R[1],["str"]],["str"]]]],[5,"handle_timer_interrupt",E,"this occurs on every PIT timer tick. Called by the PIT's…",N,[[]]]],"p":[]};
searchIndex["pmu_x86"]={"doc":"Support for the Performance Monitoring Unit ","i":[[3,"Counter","pmu_x86","A logical counter object to correspond to a physical PMC",N,N],[3,R[638],E,"Stores the instruction pointers and corresponding task IDs…",N,N],[12,"instruction_pointers",E,E,0,N],[12,"task_ids",E,E,0,N],[4,R[639],E,"Used to select the event type to count. Event types are…",N,N],[13,"InstructionsRetired",E,"This event counts the number of instructions at…",1,N],[13,"UnhaltedCoreCycles",E,"This event counts core clock cycles when the clock signal…",1,N],[13,"UnhaltedReferenceCycles",E,"This event counts reference clock cycles at a fixed…",1,N],[13,"LastLevelCacheReferences",E,"This event counts requests originating from the core that…",1,N],[13,"LastLevelCacheMisses",E,"This event counts each cache miss condition for references…",1,N],[13,"BranchInstructionsRetired",E,"This event counts branch instructions at retirement. It…",1,N],[13,"BranchMissesRetired",E,"This event counts mispredicted branch instructions at…",1,N],[5,"init",E,"Initialization function that enables the PMU if one is…",N,[[],[[R[1],["str"]],["str"]]]],[5,"reset_pmu",E,"Frees all counters and make them available to be used.…",N,[[],[[R[1],["str"]],["str"]]]],[5,"start_samples",E,"Start interrupt process in order to take samples using the…",N,[[["u32"],[R[31],["usize"]],[R[636]],["usize"]],[[R[1],["str"]],["str"]]]],[5,"retrieve_samples",E,"Returns the samples that were stored during sampling in…",N,[[],[[R[1],[R[633],"str"]],["str"],[R[633]]]]],[5,"print_samples",E,"Simple function to print values from SampleResults in a…",N,[[[R[633]]]]],[5,"find_function_names_from_samples",E,"Finds the corresponding function for each instruction…",N,[[[R[633]]],[[R[1],["str"]],["str"]]]],[5,"handle_sample",E,"Function called in the interrupt handler to store the…",N,[[[R[596]]],[[R[1],["str"]],["str"]]]],[0,"stat",E,"This module implements the equivalent of \"perf stat\".…",N,N],[3,R[640],R[637],E,N,N],[3,R[641],E,E,N,N],[11,"new",E,"Initialize seven performance monitoring counters. They…",2,[[],[[R[1],[R[634],"str"]],[R[634]],["str"]]]],[11,"start",E,"Start running all the counters ",2,[[["self"]],[[R[1],["str"]],["str"]]]],[11,"end",E,"Stop the counters and return the counter values. The…",2,[[],[[R[635]],["str"],[R[1],[R[635],"str"]]]]],[11,"new","pmu_x86","Creates a Counter object and assigns a physical counter…",3,[[[R[636]]],[["str"],[R[1],["counter","str"]],["counter"]]]],[11,"start",E,"Starts the count.",3,[[["self"]],[[R[1],["str"]],["str"]]]],[11,"get_count_since_start",E,"Allows user to get count since start without…",3,[[["self"]],[["str"],["u64"],[R[1],["u64","str"]]]]],[11,"end",E,"Stops counting, releases the counter, and returns the…",3,[[],[["str"],["u64"],[R[1],["u64","str"]]]]],[11,"diff",E,"lightweight function with no checks to get the counter…",3,[[["self"]],["u64"]]],[11,"from",E,E,3,[[[T]],[T]]],[11,R[6],E,E,3,[[[U]],[R[1]]]],[11,"into",E,E,3,[[],[U]]],[11,R[7],E,E,3,[[],[R[1]]]],[11,R[8],E,E,3,[[["self"]],[T]]],[11,R[9],E,E,3,[[["self"]],[T]]],[11,R[11],E,E,3,[[["self"]],[R[14]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[6],E,E,1,[[[U]],[R[1]]]],[11,"into",E,E,1,[[],[U]]],[11,R[7],E,E,1,[[],[R[1]]]],[11,R[8],E,E,1,[[["self"]],[T]]],[11,R[9],E,E,1,[[["self"]],[T]]],[11,R[11],E,E,1,[[["self"]],[R[14]]]],[11,"from",R[637],E,2,[[[T]],[T]]],[11,R[6],E,E,2,[[[U]],[R[1]]]],[11,"into",E,E,2,[[],[U]]],[11,R[7],E,E,2,[[],[R[1]]]],[11,R[8],E,E,2,[[["self"]],[T]]],[11,R[9],E,E,2,[[["self"]],[T]]],[11,R[11],E,E,2,[[["self"]],[R[14]]]],[11,"from",E,E,4,[[[T]],[T]]],[11,R[6],E,E,4,[[[U]],[R[1]]]],[11,"into",E,E,4,[[],[U]]],[11,R[7],E,E,4,[[],[R[1]]]],[11,R[8],E,E,4,[[["self"]],[T]]],[11,R[9],E,E,4,[[["self"]],[T]]],[11,R[11],E,E,4,[[["self"]],[R[14]]]],[11,"fmt",E,E,4,[[["self"],[R[12]]],[R[1]]]],[11,"drop","pmu_x86",E,3,[[["self"]]]]],"p":[[3,R[638]],[4,R[639]],[3,R[640]],[3,"Counter"],[3,R[641]]]};
searchIndex["print"]={"doc":"Allows crates in the kernel to log messages to the default…","i":[[5,"set_default_print_output","print","Gives the kernel an endpoint (queue producer) to which it…",N,[[[R[628],["event"]],["event"]]]],[5,"print_to_default_output",E,"Enqueues the given `fmt_args` as a String onto the default…",N,[[[R[72]]]]],[14,"println",E,"Calls `print!()` with an extra newilne `\\n` appended to…",N,N],[14,"print",E,R[629],N,N]],"p":[]};
searchIndex["ps2"]={"doc":E,"i":[[4,R[56],"ps2",E,N,N],[13,"MF2Keyboard",E,E,0,N],[13,"MF2KeyboardWithPSControllerTranslator",E,E,0,N],[13,"AncientATKeyboard",E,E,0,N],[5,"ps2_clean_buffer",E,"clean the PS2 data port (0x60) output buffer also return…",N,[[],[["vec",["u8"]],["u8"]]]],[5,"ps2_write_command",E,"write command to the command ps2 port (0x64)",N,[[["u8"]]]],[5,"ps2_status_register",E,"read the ps2 status register",N,[[],["u8"]]],[5,"ps2_read_data",E,"read dat from ps2 data port (0x60)",N,[[],["u8"]]],[5,"ps2_read_config",E,"read the config of the ps2 port",N,[[],["u8"]]],[5,"ps2_write_config",E,"write the new config to the ps2 command port (0x64)",N,[[["u8"]]]],[5,"init_ps2_port1",E,"initialize the first ps2 data port",N,[[]]],[5,"test_ps2_port1",E,"test the first ps2 data port",N,[[]]],[5,"init_ps2_port2",E,"initialize the second ps2 data port",N,[[]]],[5,"test_ps2_port2",E,"test the second ps2 data port",N,[[]]],[5,"data_to_port1",E,"write data to the first ps2 data port and return the…",N,[[["u8"]],["u8"]]],[5,"data_to_port2",E,"write data to the second ps2 data port and return the…",N,[[["u8"]],["u8"]]],[5,"command_to_keyboard",E,"write command to the keyboard and return the result",N,[[["u8"]],[[R[1],["str"]],["str"]]]],[5,"command_to_mouse",E,"write command to the mouse and return the result",N,[[["u8"]],[[R[1],["str"]],["str"]]]],[5,"write_to_second_output_buffer",E,"write data to the second ps2 output buffer",N,[[["u8"]]]],[5,"handle_mouse_packet",E,"read mouse data packet",N,[[],["u32"]]],[5,"set_sampling_rate",E,"set ps2 mouse's sampling rate",N,[[["u8"]],[[R[1],["str"]],["str"]]]],[5,"set_mouse_id",E,"set the mouse ID (3 or 4 ) by magic sequence 3 means that…",N,[[["u8"]],[[R[1],["str"]],["str"]]]],[5,"check_mouse_id",E,"check the mouse's id",N,[[],[[R[1],["u8","str"]],["str"],["u8"]]]],[5,"reset_mouse",E,"reset the mouse",N,[[],[[R[1],["str"]],["str"]]]],[5,"mouse_resend",E,"resend the most recent packet again",N,[[],[[R[1],["str"]],["str"]]]],[5,"mouse_packet_streaming",E,"enable or disable the packet streaming also return the vec…",N,[[["bool"]],[["str"],[R[1],["vec","str"]],["vec",["u8"]]]]],[5,"mouse_resolution",E,"set the resolution of the mouse parameter : 0x00: 1…",N,[[["u8"]],[[R[1],["str"]],["str"]]]],[5,"keyboard_led",E,"set LED status of the keyboard parameter : 0: ScrollLock;…",N,[[["u8"]]]],[5,"keyboard_scancode_set",E,"set the scancode set of the keyboard 0: get the current…",N,[[["u8"]],[[R[1],["str"]],["str"]]]],[5,"keyboard_detect",E,"detect the keyboard's type",N,[[],[[R[1],[R[55],"str"]],[R[55]],["str"]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]]],"p":[[4,R[56]]]};
searchIndex["rendezvous"]={"doc":"A rendezvous-based channel for synchronous Inter-Task…","i":[[3,"Sender","rendezvous",R[710],N,N],[3,R[54],E,R[711],N,N],[5,R[702],E,"Create a new channel that requires a sender a receiver to…",N,[[]]],[11,"send",E,"Send a message, blocking until a receiver is ready.",0,[[["self"],[T]],[[R[1],["str"]],["str"]]]],[11,R[712],E,"Tries to send the message, only succeeding if a receiver…",0,[[["self"],[T]],[R[1]]]],[11,"receive",E,"Receive a message, blocking until a sender is ready. ",1,[[["self"]],[["str"],[R[1],["str"]]]]],[11,R[703],E,"Tries to receive a message, only succeeding if a sender is…",1,[[["self"]],[["str"],[R[1],["str"]]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,R[64],E,E,0,[[["self"]],[T]]],[11,R[65],E,E,0,[[["self"],[T]]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[6],E,E,1,[[[U]],[R[1]]]],[11,"into",E,E,1,[[],[U]]],[11,R[7],E,E,1,[[],[R[1]]]],[11,R[8],E,E,1,[[["self"]],[T]]],[11,R[9],E,E,1,[[["self"]],[T]]],[11,R[11],E,E,1,[[["self"]],[R[14]]]],[11,R[64],E,E,1,[[["self"]],[T]]],[11,R[65],E,E,1,[[["self"],[T]]]],[11,"clone",E,E,0,[[["self"]],["sender"]]],[11,"clone",E,E,1,[[["self"]],["receiver"]]]],"p":[[3,"Sender"],[3,R[54]]]};
searchIndex["root"]={"doc":"This crate contains the implementation of the special root…","i":[[3,"ROOT","root","The root directory Returns a tuple for easy access to the…",N,N],[3,R[342],E,R[343],N,N],[5,"get_root",E,"Returns a reference to the root directory.",N,[[],["dirref"]]],[17,"ROOT_DIRECTORY_NAME",E,E,N,N],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[6],E,E,1,[[[U]],[R[1]]]],[11,"into",E,E,1,[[],[U]]],[11,R[7],E,E,1,[[],[R[1]]]],[11,R[8],E,E,1,[[["self"]],[T]]],[11,R[9],E,E,1,[[["self"]],[T]]],[11,R[11],E,E,1,[[["self"]],[R[14]]]],[11,"deref",E,E,0,[[["self"]]]],[11,R[442],E,E,0,[[["self"]]]],[11,R[329],E,R[341],1,[[["self"]],["string"]]],[11,R[338],E,E,1,[[["self"]],["string"]]],[11,R[330],E,"we just return the root itself because it is the top of…",1,[[["self"]],[[R[31],["dirref"]],["dirref"]]]],[11,R[331],E,E,1,[[["self"],[R[332]]]]],[11,"insert",E,E,1,[[[R[328]],["self"]],[["str"],[R[1],[R[31],"str"]],[R[31],[R[328]]]]]],[11,"get",E,E,1,[[["str"],["self"]],[[R[328]],[R[31],[R[328]]]]]],[11,"list",E,E,1,[[["self"]],[["vec",["string"]],["string"]]]],[11,"remove",E,E,1,[[["self"],[R[328]]],[[R[328]],[R[31],[R[328]]]]]]],"p":[[3,"ROOT"],[3,R[342]]]};
searchIndex["rsdp"]={"doc":"Support for ACPI RSDP (Root System Descriptor Pointer).","i":[[3,"Rsdp","rsdp","The Root System Descriptor Pointer, which contains the…",N,N],[11,"get_rsdp",E,"Search for the RSDP in the BIOS memory area from 0xE_0000…",0,[[[R[170]]],[[R[1],["boxref","str"]],["str"],["boxref",[R[168],"rsdp"]]]]],[11,"sdt_address",E,"Returns the `PhysicalAddress` of the RSDT or XSDT.",0,[[["self"]],[R[82]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,R[64],E,E,0,[[["self"]],[T]]],[11,R[65],E,E,0,[[["self"],[T]]]],[11,"fmt",E,E,0,[[[R[12]],["self"]],[R[1]]]],[11,"clone",E,E,0,[[["self"]],["rsdp"]]]],"p":[[3,"Rsdp"]]};
searchIndex["rsdt"]={"doc":R[364],"i":[[3,"RsdtXsdt","rsdt","The Root/Extended System Descriptor Table, which primarily…",N,N],[5,"handle",E,"The handler for parsing RSDT/XSDT tables and adding them…",N,[[["usize"],[R[82]],[R[300]],[R[363]]],[[R[1],["str"]],["str"]]]],[17,"RSDT_SIGNATURE",E,E,N,N],[17,"XSDT_SIGNATURE",E,E,N,N],[11,"get",E,"Finds the RSDT or XSDT in the given `AcpiTables` and…",0,[[[R[363]]],[["rsdtxsdt"],[R[31],["rsdtxsdt"]]]]],[11,"sdt",E,"Returns a reference to the SDT header of this RSDT or XSDT.",0,[[["self"]],["sdt"]]],[11,"addresses",E,"Returns an iterator over the `PhysicalAddress`es of the…",0,[[["self"]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]]],"p":[[3,"RsdtXsdt"]]};
searchIndex["rtc"]={"doc":E,"i":[[3,"RtcTime","rtc","A timestamp obtained from the real-time clock.",N,N],[12,"seconds",E,E,0,N],[12,"minutes",E,E,0,N],[12,"hours",E,E,0,N],[12,"days",E,E,0,N],[12,"months",E,E,0,N],[12,"years",E,E,0,N],[5,"read_rtc",E,E,N,[[],["rtctime"]]],[5,"get_rtc_ticks",E,E,N,[[],[[R[1],["usize"]],["usize"]]]],[5,"enable_rtc_interrupt",E,"turn on IRQ 8 (mapped to 0x28), rtc begins sending…",N,[[]]],[5,"set_rtc_frequency",E,"sets the period of the RTC interrupt. `rate` must be a…",N,[[["usize"]],[R[1]]]],[6,"RtcInterruptFunction",E,E,N,N],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,R[176],E,E,0,[[["self"]],["string"]]],[11,"fmt",E,E,0,[[["self"],[R[12]]],[[R[1],["error"]],["error"]]]],[11,"fmt",E,E,0,[[[R[12]],["self"]],[R[1]]]]],"p":[[3,"RtcTime"]]};
searchIndex["runqueue"]={"doc":"This crate contains the API of the `RunQueue` structure,…","i":[[5,"init","runqueue",R[650],N,[[["u8"]],[[R[1],["str"]],["str"]]]],[5,R[651],E,"Returns the `RunQueue` of the given core, which is an…",N,[[["u8"]],[[R[31],[R[304]]],[R[304]]]]],[5,R[652],E,"Returns the \"least busy\" core",N,[[],[[R[31],["u8"]],["u8"]]]],[5,R[654],E,"Chooses the \"least busy\" core's runqueue and adds the…",N,[[[R[597]]],[[R[1],["str"]],["str"]]]],[5,R[656],E,"Adds the given `Task` reference to given core's runqueue.",N,[[[R[597]],["u8"]],[[R[1],["str"]],["str"]]]],[5,R[660],E,R[661],N,[[[R[597]]],[[R[1],["str"]],["str"]]]]],"p":[]};
searchIndex["runqueue_priority"]={"doc":"This crate contains the `RunQueue` structure, for priority…","i":[[3,R[643],"runqueue_priority",R[646],N,N],[12,"priority",E,"Priority assigned for the task. Max priority = 40, Min…",0,N],[12,"tokens_remaining",E,"Remaining tokens in this epoch. A task will be scheduled…",0,N],[3,R[647],E,"A list of references to `Task`s (`PriorityTaskRef`s) that…",N,N],[17,"MAX_PRIORITY",E,E,N,N],[17,"DEFAULT_PRIORITY",E,E,N,N],[17,"INITIAL_TOKENS",E,E,N,N],[11,"new",E,"Creates a new `PriorityTaskRef` that wraps the given…",0,[[[R[597]]],[R[642]]]],[11,"lock",E,R[644],0,[[["self"]],[[R[645],["task"]],["task"]]]],[11,R[648],E,R[649],0,[[["self"]]]],[11,"update_and_move_to_end",E,"Moves the `TaskRef` at the given index in this `RunQueue`…",1,[[["self"],["usize"]],[[R[597]],[R[31],[R[597]]]]]],[11,"init",E,R[650],1,[[["u8"]],[[R[1],["str"]],["str"]]]],[11,R[651],E,"Returns `RunQueue` for the given core, which is an…",1,[[["u8"]],[[R[304]],[R[31],[R[304]]]]]],[11,R[652],E,R[653],1,[[],[[R[31],["u8"]],["u8"]]]],[11,R[654],E,R[655],1,[[[R[597]]],[[R[1],["str"]],["str"]]]],[11,R[656],E,R[657],1,[[[R[597]],["u8"]],[[R[1],["str"]],["str"]]]],[11,R[658],E,R[659],1,[[["self"],[R[597]]],[[R[1],["str"]],["str"]]]],[11,R[660],E,R[661],1,[[[R[597]]],[[R[1],["str"]],["str"]]]],[11,R[668],E,"Sets the priority of the given `Task` in all the…",1,[[[R[597]],["u8"]],[[R[1],["str"]],["str"]]]],[11,R[669],E,"Output the priority of the given task. Outputs None if the…",1,[[[R[597]]],[[R[31],["u8"]],["u8"]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,R[64],E,E,0,[[["self"]],[T]]],[11,R[65],E,E,0,[[["self"],[T]]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[6],E,E,1,[[[U]],[R[1]]]],[11,"into",E,E,1,[[],[U]]],[11,R[7],E,E,1,[[],[R[1]]]],[11,R[8],E,E,1,[[["self"]],[T]]],[11,R[9],E,E,1,[[["self"]],[T]]],[11,R[11],E,E,1,[[["self"]],[R[14]]]],[11,"fmt",E,E,0,[[[R[12]],["self"]],[R[1]]]],[11,"fmt",E,E,1,[[[R[12]],["self"]],[R[1]]]],[11,"deref",E,E,0,[[["self"]],[R[597]]]],[11,"deref",E,E,1,[[["self"]],[R[662]]]],[11,R[99],E,E,0,[[["self"]],[R[597]]]],[11,R[99],E,E,1,[[["self"]],[R[662]]]],[11,"clone",E,E,0,[[["self"]],[R[642]]]]],"p":[[3,R[643]],[3,R[647]]]};
searchIndex["runqueue_round_robin"]={"doc":"This crate contains the `RunQueue` structure, for round…","i":[[3,R[664],"runqueue_round_robin",R[646],N,N],[3,R[665],E,"There is one runqueue per core, each core only accesses…",N,N],[3,R[647],E,"A list of references to `Task`s (`RoundRobinTaskRef`s).…",N,N],[11,"new",E,"Creates a new `RoundRobinTaskRef` that wraps the given…",0,[[[R[597]]],[R[663]]]],[11,R[648],E,R[649],0,[[["self"]]]],[11,"move_to_end",E,"Moves the `TaskRef` at the given index into this…",1,[[["self"],["usize"]],[[R[597]],[R[31],[R[597]]]]]],[11,"init",E,R[650],1,[[["u8"]],[[R[1],["str"]],["str"]]]],[11,R[651],E,"Returns the `RunQueue` for the given core, which is an…",1,[[["u8"]],[[R[31],[R[304]]],[R[304]]]]],[11,R[652],E,R[653],1,[[],[[R[31],["u8"]],["u8"]]]],[11,R[654],E,R[655],1,[[[R[597]]],[[R[1],["str"]],["str"]]]],[11,R[656],E,R[657],1,[[[R[597]],["u8"]],[[R[1],["str"]],["str"]]]],[11,R[658],E,R[659],1,[[["self"],[R[597]]],[[R[1],["str"]],["str"]]]],[11,R[660],E,R[661],1,[[[R[597]]],[[R[1],["str"]],["str"]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,R[64],E,E,0,[[["self"]],[T]]],[11,R[65],E,E,0,[[["self"],[T]]]],[11,"from",E,E,2,[[[T]],[T]]],[11,R[6],E,E,2,[[[U]],[R[1]]]],[11,"into",E,E,2,[[],[U]]],[11,R[7],E,E,2,[[],[R[1]]]],[11,R[8],E,E,2,[[["self"]],[T]]],[11,R[9],E,E,2,[[["self"]],[T]]],[11,R[11],E,E,2,[[["self"]],[R[14]]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[6],E,E,1,[[[U]],[R[1]]]],[11,"into",E,E,1,[[],[U]]],[11,R[7],E,E,1,[[],[R[1]]]],[11,R[8],E,E,1,[[["self"]],[T]]],[11,R[9],E,E,1,[[["self"]],[T]]],[11,R[11],E,E,1,[[["self"]],[R[14]]]],[11,"fmt",E,E,0,[[[R[12]],["self"]],[R[1]]]],[11,"fmt",E,E,1,[[[R[12]],["self"]],[R[1]]]],[11,"deref",E,E,0,[[["self"]],[R[597]]]],[11,"deref",E,E,2,[[["self"]],[R[313]]]],[11,"deref",E,E,1,[[["self"]],[R[662]]]],[11,R[99],E,E,0,[[["self"]],[R[597]]]],[11,R[99],E,E,1,[[["self"]],[R[662]]]],[11,"clone",E,E,0,[[["self"]],[R[663]]]],[11,R[442],E,E,2,[[["self"]]]]],"p":[[3,R[664]],[3,R[647]],[3,R[665]]]};
searchIndex["scheduler"]={"doc":E,"i":[[5,"schedule","scheduler","Yields the current CPU by selecting a new `Task` to run…",N,[[],["bool"]]],[5,R[668],E,R[671],N,[[["u8"],[R[597]]],[[R[1],["str"]],["str"]]]],[5,R[669],E,"Returns the priority of a given task. This function…",N,[[[R[597]]],[[R[31],["u8"]],["u8"]]]]],"p":[]};
searchIndex["scheduler_priority"]={"doc":"This crate picks the next task on token based scheduling…","i":[[5,R[668],"scheduler_priority",R[671],N,[[[R[597]],["u8"]],[[R[1],["str"]],["str"]]]],[5,R[669],E,"Returns the priority of the given task.",N,[[[R[597]]],[[R[31],["u8"]],["u8"]]]],[5,R[670],E,"This defines the priority scheduler policy. Returns None…",N,[[["u8"]],[[R[31],[R[597]]],[R[597]]]]]],"p":[]};
searchIndex["scheduler_round_robin"]={"doc":"This crate picks the next task in round robin fashion.…","i":[[5,R[670],"scheduler_round_robin","This defines the round robin scheduler policy. Returns…",N,[[["u8"]],[[R[31],[R[597]]],[R[597]]]]]],"p":[]};
searchIndex["sdt"]={"doc":"ACPI table definitions and basic SDT structures.","i":[[3,"Sdt","sdt","An ACPI System Descriptor Table. This is the header (the…",N,N],[12,R[417],E,E,0,N],[12,"length",E,E,0,N],[12,"revision",E,E,0,N],[12,R[418],E,E,0,N],[12,"oem_id",E,E,0,N],[12,"oem_table_id",E,E,0,N],[12,"oem_revision",E,E,0,N],[12,"creator_id",E,E,0,N],[12,"creator_revision",E,E,0,N],[3,R[13],E,"A struct used to describe the position and layout of…",N,N],[12,"address_space",E,E,1,N],[12,"bit_width",E,E,1,N],[12,"bit_offset",E,E,1,N],[12,"access_size",E,E,1,N],[12,R[287],E,E,1,N],[17,"SDT_SIZE_IN_BYTES",E,"The size in bytes of the ACPI SDT Header (`Sdt` struct).",N,N],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[6],E,E,1,[[[U]],[R[1]]]],[11,"into",E,E,1,[[],[U]]],[11,R[7],E,E,1,[[],[R[1]]]],[11,R[8],E,E,1,[[["self"]],[T]]],[11,R[9],E,E,1,[[["self"]],[T]]],[11,R[11],E,E,1,[[["self"]],[R[14]]]],[11,"fmt",E,E,0,[[[R[12]],["self"]],[R[1]]]],[11,"fmt",E,E,1,[[[R[12]],["self"]],[R[1]]]],[11,"clone",E,E,0,[[["self"]],["sdt"]]],[11,"clone",E,E,1,[[["self"]],["genericaddressstructure"]]]],"p":[[3,"Sdt"],[3,R[13]]]};
searchIndex["serial_port"]={"doc":E,"i":[[5,"write_fmt","serial_port","Write formatted arguments to the COM1 serial port.",N,[[[R[72]]],[R[1]]]],[5,"write_str",E,"Write the given string to the COM1 serial port.",N,[[["str"]],[R[1]]]]],"p":[]};
searchIndex["shapes"]={"doc":"This crate defines the basic shapes used for display.","i":[[3,"Coord","shapes","A 2-D integer coordinate.",N,N],[12,"x",E,"The x coordinate",0,N],[12,"y",E,"The y coordinate",0,N],[3,R[17],E,"A rectangle given by its top-left coordinate and…",N,N],[12,"top_left",E,"The top-left point",1,N],[12,"bottom_right",E,"The bottom-right point",1,N],[11,"new",E,"Creates a new coordinate.",0,[[["isize"]],["coord"]]],[11,"width",E,"Returns the width of this Rectangle.",1,[[["self"]],["usize"]]],[11,"height",E,"Returns the height of this Rectangle.",1,[[["self"]],["usize"]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[6],E,E,1,[[[U]],[R[1]]]],[11,"into",E,E,1,[[],[U]]],[11,R[7],E,E,1,[[],[R[1]]]],[11,R[8],E,E,1,[[["self"]],[T]]],[11,R[9],E,E,1,[[["self"]],[T]]],[11,R[11],E,E,1,[[["self"]],[R[14]]]],[11,"fmt",E,E,0,[[[R[12]],["self"]],[R[1]]]],[11,"fmt",E,E,1,[[[R[12]],["self"]],[R[1]]]],[11,"sub",E,E,0,[[],["coord"]]],[11,"sub",E,E,0,[[["coord"]],["coord"]]],[11,"sub",E,E,1,[[["coord"]],[R[15]]]],[11,"eq",E,E,0,[[["self"],["coord"]],["bool"]]],[11,"ne",E,E,0,[[["self"],["coord"]],["bool"]]],[11,"eq",E,E,1,[[["self"],[R[15]]],["bool"]]],[11,"ne",E,E,1,[[["self"],[R[15]]],["bool"]]],[11,"cmp",E,E,0,[[["self"]],[R[16]]]],[11,R[61],E,E,0,[[["self"]],[[R[31],[R[16]]],[R[16]]]]],[11,"add",E,E,0,[[],["coord"]]],[11,"add",E,E,0,[[["coord"]],["coord"]]],[11,"add",E,E,1,[[["coord"]],[R[15]]]],[11,"hash",E,E,0,[[["self"],["__h"]]]],[11,"hash",E,E,1,[[["self"],["__h"]]]],[11,"clone",E,E,0,[[["self"]],["coord"]]],[11,"clone",E,E,1,[[["self"]],[R[15]]]]],"p":[[3,"Coord"],[3,R[17]]]};
searchIndex["simd_personality"]={"doc":"Management of two kernel personalities, one for…","i":[],"p":[]};
searchIndex["simd_test"]={"doc":E,"i":[],"p":[]};
searchIndex["simple_ipc"]={"doc":"An implementation of a shared buffer for IPC that can be…","i":[[3,"Sender","simple_ipc","Channel endpoint that only allows sending messages.",N,N],[3,R[54],E,"Channel endpoint that only allows receiving messages.",N,N],[5,R[702],E,"Creates a new channel and returns the endpoints",N,[[]]],[11,R[712],E,"Tries to send a message once. If the buffer is full, then…",0,[[["self"],["u8"]],[[R[1],["str"]],["str"]]]],[11,"send",E,"Tries to send a message until succesful. Task will spin in…",0,[[["self"],["u8"]]]],[11,R[703],E,"Tries to receive a message once. If the buffer is empty,…",1,[[["self"]],[[R[1],["u8","str"]],["str"],["u8"]]]],[11,"receive",E,"Tries to receive a message until succesful. Task will spin…",1,[[["self"]],["u8"]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[6],E,E,1,[[[U]],[R[1]]]],[11,"into",E,E,1,[[],[U]]],[11,R[7],E,E,1,[[],[R[1]]]],[11,R[8],E,E,1,[[["self"]],[T]]],[11,R[9],E,E,1,[[["self"]],[T]]],[11,R[11],E,E,1,[[["self"]],[R[14]]]]],"p":[[3,"Sender"],[3,R[54]]]};
searchIndex["single_simd_task_optimization"]={"doc":"Implements the performance optimization that allows a…","i":[],"p":[]};
searchIndex["slabmalloc"]={"doc":"A slab allocator implementation for objects less than 8KiB.","i":[[3,R[50],"slabmalloc",R[254],N,N],[12,"mp",E,"The MappedPages this memory area belongs to",0,N],[12,R[30],E,E,0,N],[3,R[253],E,R[292],N,N],[3,"Rawlink",E,R[255],N,N],[3,R[52],E,R[256],N,N],[3,R[51],E,R[257],N,N],[12,R[30],E,E,1,N],[18,"SIZE",E,E,2,N],[18,R[293],E,E,2,N],[18,R[41],E,E,2,N],[18,R[42],E,E,2,N],[11,"new",E,R[294],2,[[[R[168]]],[[R[1],[R[251],"str"]],["str"],[R[251]]]]],[11,R[86],E,E,2,[[["self"]],[R[81]]]],[11,"new",E,R[258],3,[[["usize"]],[R[259]]]],[11,"size",E,R[260],3,[[["self"]],["usize"]]],[11,"refill",E,R[261],3,[[["self"],["usize"],[R[251]]]]],[11,R[28],E,"Returns an empty page from the allocator if available. It…",3,[[["self"]],[[R[251]],[R[31],[R[251]]]]]],[11,R[25],E,R[262],3,[[["self"],[R[0]]],[[R[27],["u8"]],["str"],[R[1],[R[27],"str"]]]]],[11,R[26],E,R[263],3,[[[R[27],["u8"]],["self"],[R[0]],["u8"]],[[R[1],["str"]],["str"]]]],[18,R[264],E,R[265],1,N],[18,R[266],E,R[267],1,N],[18,R[268],E,R[269],1,N],[18,R[270],E,R[271],1,N],[11,"new",E,E,1,[[["usize"]],[R[39]]]],[11,R[272],E,R[273],1,[[["usize"]],[[R[31],["usize"]],["usize"]]]],[11,R[28],E,R[295],1,[[["self"],["usize"]],[[R[251]],[R[31],[R[251]]]]]],[11,R[274],E,E,1,[[["self"],[R[0]]],[[R[1],["str"]],["str"]]]],[11,R[275],E,R[276],1,[[["self"]],["usize"]]],[11,R[25],E,R[277],1,[[["self"],[R[0]]],[[R[27],["u8"]],["str"],[R[1],[R[27],"str"]]]]],[11,R[26],E,R[278],1,[[[R[27],["u8"]],["self"],[R[0]],["u8"]],[[R[1],["str"]],["str"]]]],[11,"refill",E,R[296],1,[[["self"],[R[0]],[R[251]]],[[R[1],["str"]],["str"]]]],[8,R[53],E,R[279],N,N],[18,"SIZE",E,R[40],4,N],[18,R[41],E,E,4,N],[18,R[42],E,E,4,N],[10,"new",E,E,4,[[["usize"],[R[251]]],["self"]]],[10,R[252],E,E,4,[[["self"]],[[R[251]],[R[31],[R[251]]]]]],[10,R[32],E,E,4,[[["self"]]]],[10,R[33],E,E,4,[[["self"],["usize"]]]],[10,R[30],E,E,4,[[["self"]],["usize"]]],[10,R[34],E,E,4,[[["self"]]]],[10,R[35],E,E,4,[[["self"]]]],[10,"prev",E,E,4,[[["self"]],[R[36]]]],[10,"next",E,E,4,[[["self"]],[R[36]]]],[10,R[37],E,E,4,[[],["usize"]]],[11,R[43],E,R[44],4,[[[R[0]],["self"]],[R[31]]]],[11,R[25],E,R[45],4,[[["self"],[R[0]]]]],[11,R[299],E,R[46],4,[[["self"]],["bool"]]],[11,R[47],E,R[48],4,[[["self"],["usize"]],["bool"]]],[11,R[26],E,R[49],4,[[[R[27],["u8"]],[R[0]],["self"],["u8"]],[[R[1],["str"]],["str"]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,"from",E,E,2,[[[T]],[T]]],[11,R[6],E,E,2,[[[U]],[R[1]]]],[11,"into",E,E,2,[[],[U]]],[11,R[7],E,E,2,[[],[R[1]]]],[11,R[8],E,E,2,[[["self"]],[T]]],[11,R[9],E,E,2,[[["self"]],[T]]],[11,R[11],E,E,2,[[["self"]],[R[14]]]],[11,"from",E,E,5,[[[T]],[T]]],[11,R[6],E,E,5,[[[U]],[R[1]]]],[11,"into",E,E,5,[[],[U]]],[11,R[7],E,E,5,[[],[R[1]]]],[11,R[8],E,E,5,[[["self"]],[T]]],[11,R[9],E,E,5,[[["self"]],[T]]],[11,R[11],E,E,5,[[["self"]],[R[14]]]],[11,"from",E,E,3,[[[T]],[T]]],[11,R[6],E,E,3,[[[U]],[R[1]]]],[11,"into",E,E,3,[[],[U]]],[11,R[7],E,E,3,[[],[R[1]]]],[11,R[8],E,E,3,[[["self"]],[T]]],[11,R[9],E,E,3,[[["self"]],[T]]],[11,R[11],E,E,3,[[["self"]],[R[14]]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[6],E,E,1,[[[U]],[R[1]]]],[11,"into",E,E,1,[[],[U]]],[11,R[7],E,E,1,[[],[R[1]]]],[11,R[8],E,E,1,[[["self"]],[T]]],[11,R[9],E,E,1,[[["self"]],[T]]],[11,R[11],E,E,1,[[["self"]],[R[14]]]],[11,"new",E,"Creates a new 8KiB allocable page and stores the…",0,[[["usize"],[R[251]]],[R[29]]]],[11,R[252],E,"Returns the MappedPages object that was stored in the…",0,[[["self"]],[[R[251]],[R[31],[R[251]]]]]],[11,R[32],E,R[280],0,[[["self"]]]],[11,R[33],E,E,0,[[["self"],["usize"]]]],[11,R[30],E,E,0,[[["self"]],["usize"]]],[11,R[34],E,E,0,[[["self"]]]],[11,R[35],E,E,0,[[["self"]]]],[11,"prev",E,E,0,[[["self"]],[R[36]]]],[11,"next",E,E,0,[[["self"]],[R[36]]]],[11,R[37],E,E,0,[[],["usize"]]],[11,"fmt",E,E,0,[[["self"],[R[12]]],[R[1]]]],[11,R[38],E,E,0,[[],[R[29]]]],[11,R[38],E,E,5,[[],["self"]]],[11,R[38],E,E,1,[[],[R[39]]]],[18,"SIZE",E,R[40],4,N],[18,R[41],E,E,4,N],[18,R[42],E,E,4,N],[11,R[43],E,R[44],4,[[[R[0]],["self"]],[R[31]]]],[11,R[25],E,R[45],4,[[["self"],[R[0]]]]],[11,R[299],E,R[46],4,[[["self"]],["bool"]]],[11,R[47],E,R[48],4,[[["self"],["usize"]],["bool"]]],[11,R[26],E,R[49],4,[[[R[27],["u8"]],[R[0]],["self"],["u8"]],[[R[1],["str"]],["str"]]]]],"p":[[3,R[50]],[3,R[51]],[3,R[253]],[3,R[52]],[8,R[53]],[3,"Rawlink"]]};
searchIndex["slabmalloc_safe"]={"doc":R[297],"i":[[3,R[50],"slabmalloc_safe",R[254],N,N],[3,R[253],E,R[292],N,N],[3,R[52],E,R[256],N,N],[3,R[51],E,R[257],N,N],[12,R[30],E,E,0,N],[18,"SIZE",E,E,1,N],[18,R[293],E,E,1,N],[18,R[41],E,E,1,N],[18,R[42],E,E,1,N],[11,"new",E,R[294],1,[[[R[168]]],[[R[251]],[R[1],[R[251],"str"]],["str"]]]],[11,R[86],E,E,1,[[["self"]],[R[81]]]],[18,"MAX_PAGE_LIST_SIZE",E,"The maximum number of allocable pages the SCAllocator can…",2,N],[11,"new",E,"Creates a new SCAllocator and initializes the page lists…",2,[[["usize"]],[R[259]]]],[11,"size",E,R[260],2,[[["self"]],["usize"]]],[11,"refill",E,R[261],2,[[["self"],[R[251]],["usize"]],[[R[1],["str"]],["str"]]]],[11,R[28],E,R[298],2,[[["self"]],[[R[31],[R[251]]],[R[251]]]]],[11,R[25],E,"Allocates a block of memory descriped by `layout`.",2,[[["self"],[R[0]]],[[R[27],["u8"]],["str"],[R[1],[R[27],"str"]]]]],[11,R[26],E,R[263],2,[[[R[27],["u8"]],["self"],[R[0]],["u8"]],[[R[1],["str"]],["str"]]]],[18,R[264],E,R[265],0,N],[18,R[266],E,R[267],0,N],[18,R[268],E,R[269],0,N],[18,R[270],E,R[271],0,N],[11,"new",E,E,0,[[["usize"]],[R[39]]]],[11,R[272],E,R[273],0,[[["usize"]],[[R[31],["usize"]],["usize"]]]],[11,R[28],E,R[295],0,[[["self"],["usize"]],[[R[31],[R[251]]],[R[251]]]]],[11,R[274],E,E,0,[[["self"],[R[0]]],[[R[1],["str"]],["str"]]]],[11,R[275],E,R[276],0,[[["self"]],["usize"]]],[11,R[25],E,R[277],0,[[["self"],[R[0]]],[[R[27],["u8"]],["str"],[R[1],[R[27],"str"]]]]],[11,R[26],E,R[278],0,[[[R[27],["u8"]],["self"],[R[0]],["u8"]],[[R[1],["str"]],["str"]]]],[11,"refill",E,R[296],0,[[["self"],[R[0]],[R[251]]],[[R[1],["str"]],["str"]]]],[8,R[53],E,R[279],N,N],[18,"SIZE",E,R[40],3,N],[18,R[41],E,E,3,N],[18,R[42],E,E,3,N],[10,R[32],E,E,3,[[["self"]]]],[10,R[34],E,E,3,[[["self"]]]],[10,R[35],E,E,3,[[["self"]]]],[11,R[43],E,R[44],3,[[[R[0]],["self"]],[R[31]]]],[11,R[25],E,R[45],3,[[["self"],[R[0]]]]],[11,R[299],E,R[46],3,[[["self"]],["bool"]]],[11,R[47],E,R[48],3,[[["self"],["usize"]],["bool"]]],[11,R[26],E,R[49],3,[[[R[27],["u8"]],[R[0]],["self"],["u8"]],[[R[1],["str"]],["str"]]]],[11,"from",E,E,4,[[[T]],[T]]],[11,R[6],E,E,4,[[[U]],[R[1]]]],[11,"into",E,E,4,[[],[U]]],[11,R[7],E,E,4,[[],[R[1]]]],[11,R[8],E,E,4,[[["self"]],[T]]],[11,R[9],E,E,4,[[["self"]],[T]]],[11,R[11],E,E,4,[[["self"]],[R[14]]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[6],E,E,1,[[[U]],[R[1]]]],[11,"into",E,E,1,[[],[U]]],[11,R[7],E,E,1,[[],[R[1]]]],[11,R[8],E,E,1,[[["self"]],[T]]],[11,R[9],E,E,1,[[["self"]],[T]]],[11,R[11],E,E,1,[[["self"]],[R[14]]]],[11,"from",E,E,2,[[[T]],[T]]],[11,R[6],E,E,2,[[[U]],[R[1]]]],[11,"into",E,E,2,[[],[U]]],[11,R[7],E,E,2,[[],[R[1]]]],[11,R[8],E,E,2,[[["self"]],[T]]],[11,R[9],E,E,2,[[["self"]],[T]]],[11,R[11],E,E,2,[[["self"]],[R[14]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,R[32],E,R[280],4,[[["self"]]]],[11,R[34],E,E,4,[[["self"]]]],[11,R[35],E,E,4,[[["self"]]]],[11,R[43],E,R[44],4,[[[R[0]],["self"]],[R[31]]]],[11,R[25],E,R[45],4,[[["self"],[R[0]]]]],[11,R[299],E,R[46],4,[[["self"]],["bool"]]],[11,R[47],E,R[48],4,[[["self"],["usize"]],["bool"]]],[11,R[26],E,R[49],4,[[[R[27],["u8"]],[R[0]],["self"],["u8"]],[[R[1],["str"]],["str"]]]],[11,R[38],E,E,0,[[],[R[39]]]],[18,"SIZE",E,R[40],3,N],[18,R[41],E,E,3,N],[18,R[42],E,E,3,N],[11,R[43],E,R[44],3,[[[R[0]],["self"]],[R[31]]]],[11,R[25],E,R[45],3,[[["self"],[R[0]]]]],[11,R[299],E,R[46],3,[[["self"]],["bool"]]],[11,R[47],E,R[48],3,[[["self"],["usize"]],["bool"]]],[11,R[26],E,R[49],3,[[[R[27],["u8"]],[R[0]],["self"],["u8"]],[[R[1],["str"]],["str"]]]]],"p":[[3,R[51]],[3,R[253]],[3,R[52]],[8,R[53]],[3,R[50]]]};
searchIndex["slabmalloc_unsafe"]={"doc":R[297],"i":[[3,R[50],"slabmalloc_unsafe",R[254],N,N],[12,R[30],E,E,0,N],[3,"Rawlink",E,R[255],N,N],[3,R[52],E,R[256],N,N],[3,R[51],E,R[257],N,N],[12,R[30],E,E,1,N],[11,"new",E,R[258],2,[[["usize"]],[R[259]]]],[11,"size",E,R[260],2,[[["self"]],["usize"]]],[11,"refill",E,R[261],2,[[["self"],["usize"],["p"]]]],[11,R[28],E,R[298],2,[[["self"]],[[R[31]],["p"]]]],[11,R[25],E,R[262],2,[[["self"],[R[0]]],[[R[27],["u8"]],["str"],[R[1],[R[27],"str"]]]]],[11,R[26],E,R[263],2,[[[R[27],["u8"]],["self"],[R[0]],["u8"]],[[R[1],["str"]],["str"]]]],[18,R[264],E,R[265],1,N],[18,R[266],E,R[267],1,N],[18,R[268],E,R[269],1,N],[18,R[270],E,R[271],1,N],[11,"new",E,E,1,[[["usize"]],[R[39]]]],[11,R[272],E,R[273],1,[[["usize"]],[[R[31],["usize"]],["usize"]]]],[11,R[28],E,"Returns an ObjectPage from the SCAllocator with the…",1,[[["self"],["usize"]],[[R[31],[R[29]]],[R[29]]]]],[11,R[274],E,E,1,[[["self"],[R[0]]],[[R[1],["str"]],["str"]]]],[11,R[275],E,R[276],1,[[["self"]],["usize"]]],[11,R[25],E,R[277],1,[[["self"],[R[0]]],[[R[27],["u8"]],["str"],[R[1],[R[27],"str"]]]]],[11,R[26],E,R[278],1,[[[R[27],["u8"]],["self"],[R[0]],["u8"]],[[R[1],["str"]],["str"]]]],[11,"refill",E,"Refills the SCAllocator for a given Layout with an object…",1,[[["self"],[R[0]],[R[29]]],[[R[1],["str"]],["str"]]]],[8,R[53],E,R[279],N,N],[18,"SIZE",E,R[40],3,N],[18,R[41],E,E,3,N],[18,R[42],E,E,3,N],[10,R[32],E,E,3,[[["self"]]]],[10,R[33],E,E,3,[[["self"],["usize"]]]],[10,R[30],E,E,3,[[["self"]],["usize"]]],[10,R[34],E,E,3,[[["self"]]]],[10,R[35],E,E,3,[[["self"]]]],[10,"prev",E,E,3,[[["self"]],[R[36]]]],[10,"next",E,E,3,[[["self"]],[R[36]]]],[10,R[37],E,E,3,[[],["usize"]]],[11,R[43],E,R[44],3,[[[R[0]],["self"]],[R[31]]]],[11,R[25],E,R[45],3,[[["self"],[R[0]]]]],[11,R[299],E,R[46],3,[[["self"]],["bool"]]],[11,R[47],E,R[48],3,[[["self"],["usize"]],["bool"]]],[11,R[26],E,R[49],3,[[[R[27],["u8"]],[R[0]],["self"],["u8"]],[[R[1],["str"]],["str"]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,"from",E,E,4,[[[T]],[T]]],[11,R[6],E,E,4,[[[U]],[R[1]]]],[11,"into",E,E,4,[[],[U]]],[11,R[7],E,E,4,[[],[R[1]]]],[11,R[8],E,E,4,[[["self"]],[T]]],[11,R[9],E,E,4,[[["self"]],[T]]],[11,R[11],E,E,4,[[["self"]],[R[14]]]],[11,"from",E,E,2,[[[T]],[T]]],[11,R[6],E,E,2,[[[U]],[R[1]]]],[11,"into",E,E,2,[[],[U]]],[11,R[7],E,E,2,[[],[R[1]]]],[11,R[8],E,E,2,[[["self"]],[T]]],[11,R[9],E,E,2,[[["self"]],[T]]],[11,R[11],E,E,2,[[["self"]],[R[14]]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[6],E,E,1,[[[U]],[R[1]]]],[11,"into",E,E,1,[[],[U]]],[11,R[7],E,E,1,[[],[R[1]]]],[11,R[8],E,E,1,[[["self"]],[T]]],[11,R[9],E,E,1,[[["self"]],[T]]],[11,R[11],E,E,1,[[["self"]],[R[14]]]],[11,R[32],E,R[280],0,[[["self"]]]],[11,R[33],E,E,0,[[["self"],["usize"]]]],[11,R[30],E,E,0,[[["self"]],["usize"]]],[11,R[34],E,E,0,[[["self"]]]],[11,R[35],E,E,0,[[["self"]]]],[11,"prev",E,E,0,[[["self"]],[R[36]]]],[11,"next",E,E,0,[[["self"]],[R[36]]]],[11,R[37],E,E,0,[[],["usize"]]],[11,"fmt",E,E,0,[[["self"],[R[12]]],[R[1]]]],[11,R[38],E,E,0,[[],[R[29]]]],[11,R[38],E,E,4,[[],["self"]]],[11,R[38],E,E,1,[[],[R[39]]]],[18,"SIZE",E,R[40],3,N],[18,R[41],E,E,3,N],[18,R[42],E,E,3,N],[11,R[43],E,R[44],3,[[[R[0]],["self"]],[R[31]]]],[11,R[25],E,R[45],3,[[["self"],[R[0]]]]],[11,R[299],E,R[46],3,[[["self"]],["bool"]]],[11,R[47],E,R[48],3,[[["self"],["usize"]],["bool"]]],[11,R[26],E,R[49],3,[[[R[27],["u8"]],[R[0]],["self"],["u8"]],[[R[1],["str"]],["str"]]]]],"p":[[3,R[50]],[3,R[51]],[3,R[52]],[8,R[53]],[3,"Rawlink"]]};
searchIndex["smoltcp_helper"]={"doc":"Collection of functions to set up a TCP connection using a…","i":[[5,"millis_since","smoltcp_helper","Function to calculate the currently elapsed time (in…",N,[[["u64"]],[["str"],["u64"],[R[1],["u64","str"]]]]],[5,"get_default_iface",E,"Returns the first network interface available in the system.",N,[[],[["str"],[R[1],[R[723],"str"]],[R[723]]]]],[5,"connect",E,"A convenience function for connecting a socket. If the…",N,[[[R[757]],[R[724]],["u16"],[R[723]],[R[758]],["u64"]],[[R[1],["str"]],["str"]]]],[5,"poll_iface",E,"A convenience function to poll the given network interface…",N,[[[R[723]],["u64"],[R[724]]],[["bool"],["str"],[R[1],["bool","str"]]]]],[17,"STARTING_FREE_PORT",E,"The starting number for freely-available (non-reserved)…",N,N],[14,"hpet_ticks",E,"A simple macro to get the current HPET clock ticks.",N,N]],"p":[]};
searchIndex["spawn"]={"doc":"This crate offers routines for spawning new tasks and…","i":[[3,R[739],"spawn","A wrapper around a `TaskRef` that is for bootstrapped…",N,N],[3,R[738],E,"A struct that offers a builder pattern to create and…",N,N],[5,"init",E,"Initializes tasking for the given AP core, including…",N,[[["arc",[R[682]]],[R[81]],[R[682],[R[735]]],["u8"]],[[R[736]],[R[1],[R[736],"str"]],["str"]]]],[5,"new_task_builder",E,"Creates a builder for a new `Task` that starts at the…",N,[[["a"],["f"]],[R[737]]]],[5,"new_application_task_builder",E,"Creates a builder for a new application `Task`. ",N,[[["arc",[R[536]]],[R[31],["arc"]],["path"]],[[R[737],["vec","isize"]],[R[1],[R[737],"str"]],["str"]]]],[5,"create_idle_task",E,"Spawns an idle task on the given `core` if specified,…",N,[[[R[31],["u8"]],["u8"]],[[R[597]],["str"],[R[1],[R[597],"str"]]]]],[11,"name",E,"Set the String name for the new Task.",0,[[["string"]],[R[737]]]],[11,"argument",E,"Set the argument that will be passed to the new Task's…",0,[[["a"]],[R[737]]]],[11,"pin_on_core",E,"Pin the new Task to a specific core.",0,[[["u8"]],[R[737]]]],[11,"block",E,"Set the new Task's `RunState` to be `Blocked` instead of…",0,[[],[R[737]]]],[11,"spawn",E,"Finishes this `TaskBuilder` and spawns the new task as…",0,[[],[[R[597]],["str"],[R[1],[R[597],"str"]]]]],[11,"idle",E,"Sets this new Task to be the idle task for the given core. ",0,[[["u8"]],[R[737]]]],[11,"spawn_restartable",E,"Like `spawn()`, this finishes this `TaskBuilder` and…",0,[[],[[R[597]],["str"],[R[1],[R[597],"str"]]]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[6],E,E,1,[[[U]],[R[1]]]],[11,"into",E,E,1,[[],[U]]],[11,R[7],E,E,1,[[],[R[1]]]],[11,R[8],E,E,1,[[["self"]],[T]]],[11,R[9],E,E,1,[[["self"]],[T]]],[11,R[11],E,E,1,[[["self"]],[R[14]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,"deref",E,E,1,[[["self"]],[R[597]]]],[11,"drop",E,E,1,[[["self"]]]]],"p":[[3,R[738]],[3,R[739]]]};
searchIndex["stack_trace"]={"doc":"Stack trace (backtrace) functionality using DWARF…","i":[[5,R[734],R[734],"Get a stack trace using the default stack tracer based on…",N,[[["fn"],[R[31],["usize"]],["usize"]],[[R[1],["str"]],["str"]]]]],"p":[]};
searchIndex["stack_trace_frame_pointers"]={"doc":"Stack trace (backtrace) functionality using frame pointers.","i":[],"p":[]};
searchIndex["state_store"]={"doc":E,"i":[[3,R[18],"state_store","A thread-safe cached reference to a system-wide state.…",N,N],[5,"init",E,E,N,[[]]],[5,"insert_state",E,"Inserts a new SystemState-implementing type into the map. ",N,[[["any"]],[[R[31]],["any"]]]],[5,"get_state",E,"Returns a Weak reference to the SystemState of the…",N,[[],[["any"],["sscached"]]]],[11,"get",E,"Tries to upgrade the internal Weak pointer to a Strong…",0,[[["self"]],[[R[31],["arc"]],["arc"]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]]],"p":[[3,R[18]]]};
searchIndex["state_transfer"]={"doc":E,"i":[[5,"prio_sched","state_transfer","This function is used for live evolution from a round…",N,[[[R[536]],["arc"]],[[R[1],["str"]],["str"]]]]],"p":[]};
searchIndex["storage_device"]={"doc":"Trait definitions for storage devices and storage…","i":[[3,R[376],"storage_device",R[436],N,N],[12,"range",E,R[437],0,N],[12,R[438],E,R[439],0,N],[12,R[440],E,R[441],0,N],[6,R[427],E,R[374],N,N],[6,R[435],E,R[374],N,N],[8,R[377],E,R[425],N,N],[10,"devices",E,R[426],1,[[["self"]],[[R[419]],["box",[R[419]]]]]],[8,R[378],E,R[428],N,N],[10,R[420],E,R[429],2,[[["self"],["usize"]],[["str"],["usize"],[R[1],["usize","str"]]]]],[10,R[421],E,R[430],2,[[["self"],["usize"]],[["str"],["usize"],[R[1],["usize","str"]]]]],[10,R[422],E,R[431],2,[[["self"]],["usize"]]],[10,R[423],E,R[424],2,[[["self"]],["usize"]]],[11,R[90],E,R[432],2,[[["self"]],["usize"]]],[11,R[433],E,R[434],2,[[["self"],["usize"]],[["str"],[R[1],[R[375],"str"]],[R[375]]]]],[11,"is",E,R[443],2,[[["self"]],["bool"]]],[11,"downcast",E,R[444],2,[[["box"]],[["box"],["box"],[R[1],["box","box"]]]]],[11,R[446],E,R[447],2,[[["self"]],[[R[31]],["__t"]]]],[11,R[448],E,R[449],2,[[["self"]],[[R[31]],["__t"]]]],[11,R[450],E,R[451],0,[[["self"]],["usize"]]],[11,R[452],E,R[453],0,[[["self"]],["bool"]]],[11,R[454],E,R[455],0,[[["self"]],["bool"]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,R[405],E,E,0,[[["box"]],[["box",["any"]],["any"]]]],[11,"as_any",E,E,0,[[["self"]],["any"]]],[11,R[401],E,E,0,[[["self"]],["any"]]]],"p":[[3,R[376]],[8,R[377]],[8,R[378]]]};
searchIndex["storage_manager"]={"doc":"Manages and handles initialization of all storage devices…","i":[[8,R[377],"storage_manager",R[425],N,N],[10,"devices",E,R[426],0,[[["self"]],[[R[419]],["box",[R[419]]]]]],[6,R[427],E,R[374],N,N],[8,R[378],E,R[428],N,N],[10,R[420],E,R[429],1,[[["self"],["usize"]],[[R[1],["usize","str"]],["usize"],["str"]]]],[10,R[421],E,R[430],1,[[["self"],["usize"]],[[R[1],["usize","str"]],["usize"],["str"]]]],[10,R[422],E,R[431],1,[[["self"]],["usize"]]],[10,R[423],E,R[424],1,[[["self"]],["usize"]]],[11,R[90],E,R[432],1,[[["self"]],["usize"]]],[11,R[433],E,R[434],1,[[["self"],["usize"]],[[R[1],[R[375],"str"]],[R[375]],["str"]]]],[6,R[435],E,R[374],N,N],[3,R[376],E,R[436],N,N],[12,"range",E,R[437],2,N],[12,R[438],E,R[439],2,N],[12,R[440],E,R[441],2,N],[3,R[456],E,"A list of all of the available and initialized storage…",N,N],[5,"init_device",E,"Attempts to handle the initialization of the given…",N,[[[R[281]]],[["bool"],["str"],[R[1],["bool","str"]]]]],[11,"from",E,E,2,[[[T]],[T]]],[11,R[6],E,E,2,[[[U]],[R[1]]]],[11,"into",E,E,2,[[],[U]]],[11,R[7],E,E,2,[[],[R[1]]]],[11,R[8],E,E,2,[[["self"]],[T]]],[11,R[9],E,E,2,[[["self"]],[T]]],[11,R[11],E,E,2,[[["self"]],[R[14]]]],[11,R[405],E,E,2,[[["box"]],[["box",["any"]],["any"]]]],[11,"as_any",E,E,2,[[["self"]],["any"]]],[11,R[401],E,E,2,[[["self"]],["any"]]],[11,"from",E,E,3,[[[T]],[T]]],[11,R[6],E,E,3,[[[U]],[R[1]]]],[11,"into",E,E,3,[[],[U]]],[11,R[7],E,E,3,[[],[R[1]]]],[11,R[8],E,E,3,[[["self"]],[T]]],[11,R[9],E,E,3,[[["self"]],[T]]],[11,R[11],E,E,3,[[["self"]],[R[14]]]],[11,R[405],E,E,3,[[["box"]],[["box",["any"]],["any"]]]],[11,"as_any",E,E,3,[[["self"]],["any"]]],[11,R[401],E,E,3,[[["self"]],["any"]]],[11,"deref",E,E,3,[[["self"]],["mutex"]]],[11,R[442],E,E,3,[[["self"]]]],[11,"is",E,R[443],1,[[["self"]],["bool"]]],[11,"downcast",E,R[444],1,[[["box",[R[445]]],[R[445]]],[[R[1],["box","box"]],["box"],["box",[R[445]]]]]],[11,R[446],E,R[447],1,[[["self"]],[[R[31]],["__t"]]]],[11,R[448],E,R[449],1,[[["self"]],[["__t"],[R[31]]]]],[11,R[450],E,R[451],2,[[["self"]],["usize"]]],[11,R[452],E,R[453],2,[[["self"]],["bool"]]],[11,R[454],E,R[455],2,[[["self"]],["bool"]]]],"p":[[8,R[377]],[8,R[378]],[3,R[376]],[3,R[456]]]};
searchIndex["task"]={"doc":"This crate contains the `Task` structure for supporting…","i":[[3,R[607],"task","Just like `core::panic::PanicInfo`, but with owned String…",N,N],[12,"msg",E,E,0,N],[12,"file",E,E,0,N],[12,"line",E,E,0,N],[12,"column",E,E,0,N],[3,"TASKLIST",E,"The list of all Tasks in the system.",N,N],[3,R[608],E,"A data structure to hold data related to restart the…",N,N],[12,"argument",E,"Stores the argument of the task for restartable tasks",1,N],[12,"func",E,"Stores the function of the task for restartable tasks",1,N],[3,"Task",E,"A structure that contains contextual information for a…",N,N],[12,"id",E,"the unique id of this Task.",2,N],[12,"name",E,"the simple name of this Task",2,N],[12,"running_on_cpu",E,"Which cpu core the Task is currently running on. `None` if…",2,N],[12,"runstate",E,"the runnability status of this task, basically whether…",2,N],[12,"saved_sp",E,"the saved stack pointer value, used for task switching.",2,N],[12,"mmi",E,"Memory management details: page tables, mappings,…",2,N],[12,"kstack",E,"The kernel stack, which all `Task`s must have in order to…",2,N],[12,"pinned_core",E,"Whether or not this task is pinned to a certain core. The…",2,N],[12,"is_an_idle_task",E,"Whether this Task is an idle task, the task that runs by…",2,N],[12,"app_crate",E,"For application `Task`s, this is a reference to the…",2,N],[12,R[693],E,"This `Task` is linked into and runs within the context of…",2,N],[12,"kill_handler",E,"The function that will be called when this `Task` panics…",2,N],[12,"env",E,"The environment of the task, Wrapped in an Arc & Mutex…",2,N],[12,"failure_cleanup_function",E,"The function that should be run as a last-ditch attempt to…",2,N],[12,"restart_info",E,"Stores the restartable information of the task.…",2,N],[3,"TaskRef",E,"A shareable, cloneable reference to a `Task` that exposes…",N,N],[4,R[609],E,"The list of possible reasons that a given `Task` was…",N,N],[13,"Requested",E,"The user or another task requested that this `Task` be…",3,N],[13,"Panic",E,"A Rust-level panic occurred while running this `Task`.",3,N],[13,"Exception",E,"A non-language-level problem, such as a Page Fault or some…",3,N],[4,R[610],E,"The list of ways that a Task can exit, including possible…",N,N],[13,"Completed",E,"The Task ran to completion and returned the enclosed `Any`…",4,N],[13,"Killed",E,"The Task did NOT run to completion, and was instead…",4,N],[4,"RunState",E,"The set of possible runstates that a task can be in, e.g.,…",N,N],[13,"Initing",E,"in the midst of setting up the task",5,N],[13,"Runnable",E,"able to be scheduled in, but not necessarily currently…",5,N],[13,"Blocked",E,"blocked on something, like I/O or a wait event",5,N],[13,"Exited",E,"The `Task` has exited and can no longer be run, either by…",5,N],[13,"Reaped",E,"This `Task` had already exited and now its ExitValue has…",5,N],[5,"get_task",E,"returns a shared reference to the `Task` specified by the…",N,[[["usize"]],[[R[31],[R[597]]],[R[597]]]]],[5,"set_my_kill_handler",E,"Sets the kill handler function for the current `Task`",N,[[[R[598]]],[[R[1],["str"]],["str"]]]],[5,"bootstrap_task",E,"Bootstrap a new task from the current thread of execution.",N,[[[R[81]],["mmiref"],["u8"]],[[R[1],[R[597],"str"]],[R[597]],["str"]]]],[5,"get_my_current_task",E,"Returns a reference to the current task by using the…",N,[[],[[R[31],[R[597]]],[R[597]]]]],[5,"get_my_current_task_id",E,"Returns the current Task's id by using the `TaskLocalData`…",N,[[],[[R[31],["usize"]],["usize"]]]],[6,"KillHandler",E,"The function signature of the callback that will be…",N,N],[6,"FailureCleanupFunction",E,"The signature of a Task's failure cleanup function.",N,N],[11,"new",E,"Creates a new Task structure and initializes it to be…",2,[[[R[31],["stack"]],["stack"],["failurecleanupfunction"]],[[R[1],["task","str"]],["task"],["str"]]]],[11,"is_running",E,"returns true if this Task is currently running on any cpu.",2,[[["self"]],["bool"]]],[11,"is_runnable",E,"Returns true if this `Task` is Runnable, i.e., able to be…",2,[[["self"]],["bool"]]],[11,"has_exited",E,"Returns true if this `Task` has been exited, i.e., if its…",2,[[["self"]],["bool"]]],[11,R[552],E,"Returns `true` if this is an application `Task`. This will…",2,[[["self"]],["bool"]]],[11,R[555],E,"Returns true if this is a userspace`Task`. Currently…",2,[[["self"]],["bool"]]],[11,R[600],E,R[601],2,[[["self"],[R[598]]]]],[11,R[602],E,R[603],2,[[["self"]],[[R[598]],[R[31],[R[598]]]]]],[11,"get_exit_value",E,"Returns a reference to the exit value of this `Task`, if…",2,[[["self"]],[[R[31],[R[599]]],[R[599]]]]],[11,R[604],E,R[605],2,[[["self"]],[[R[31],[R[599]]],[R[599]]]]],[11,"task_switch",E,"Switches from the current (`self`) to the given `next`…",2,[[["u8"],["self"],["task"]]]],[11,"new",E,"Creates a new `TaskRef` that wraps the given `Task`.",6,[[["task"]],[R[597]]]],[11,"join",E,"Waits until the given `task` has finished executing, i.e.,…",6,[[["self"]],[[R[1],["str"]],["str"]]]],[11,"kill",E,"Kills this `Task` (not a clean exit) without allowing it…",6,[[["self"],[R[720]]],[[R[1],["str"]],["str"]]]],[11,"lock",E,R[644],6,[[["self"]],[[R[645],["task"]],["task"]]]],[11,"block",E,"Blocks this `Task` by setting its `RunState` to blocked.",6,[[["self"]]]],[11,"unblock",E,"Unblocks this `Task` by setting its `RunState` to runnable.",6,[[["self"]]]],[11,R[600],E,R[601],6,[[["self"],[R[598]]]]],[11,R[602],E,R[603],6,[[["self"]],[[R[598]],[R[31],[R[598]]]]]],[11,R[604],E,R[605],6,[[["self"]],[[R[31],[R[599]]],[R[599]]]]],[11,"set_env",E,"Sets the `Environment` of this Task.",6,[[["arc",["mutex"]],["self"],["mutex",[R[392]]]]]],[11,"get_env",E,"Gets a reference to this task's `Environment`.",6,[[["self"]],[["arc",["mutex"]],["mutex",[R[392]]]]]],[11,"get_namespace",E,"Gets a reference to this task's `CrateNamespace`.",6,[[["self"]],[[R[536]],["arc",[R[536]]]]]],[11,"is_restartable",E,E,6,[[["self"]],["bool"]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,R[64],E,E,0,[[["self"]],[T]]],[11,R[65],E,E,0,[[["self"],[T]]]],[11,R[176],E,E,0,[[["self"]],["string"]]],[11,"from",E,E,7,[[[T]],[T]]],[11,R[6],E,E,7,[[[U]],[R[1]]]],[11,"into",E,E,7,[[],[U]]],[11,R[7],E,E,7,[[],[R[1]]]],[11,R[8],E,E,7,[[["self"]],[T]]],[11,R[9],E,E,7,[[["self"]],[T]]],[11,R[11],E,E,7,[[["self"]],[R[14]]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[6],E,E,1,[[[U]],[R[1]]]],[11,"into",E,E,1,[[],[U]]],[11,R[7],E,E,1,[[],[R[1]]]],[11,R[8],E,E,1,[[["self"]],[T]]],[11,R[9],E,E,1,[[["self"]],[T]]],[11,R[11],E,E,1,[[["self"]],[R[14]]]],[11,"from",E,E,2,[[[T]],[T]]],[11,R[6],E,E,2,[[[U]],[R[1]]]],[11,"into",E,E,2,[[],[U]]],[11,R[7],E,E,2,[[],[R[1]]]],[11,R[8],E,E,2,[[["self"]],[T]]],[11,R[9],E,E,2,[[["self"]],[T]]],[11,R[11],E,E,2,[[["self"]],[R[14]]]],[11,R[176],E,E,2,[[["self"]],["string"]]],[11,"from",E,E,6,[[[T]],[T]]],[11,R[6],E,E,6,[[[U]],[R[1]]]],[11,"into",E,E,6,[[],[U]]],[11,R[7],E,E,6,[[],[R[1]]]],[11,R[8],E,E,6,[[["self"]],[T]]],[11,R[9],E,E,6,[[["self"]],[T]]],[11,R[11],E,E,6,[[["self"]],[R[14]]]],[11,R[64],E,E,6,[[["self"]],[T]]],[11,R[65],E,E,6,[[["self"],[T]]]],[11,"from",E,E,3,[[[T]],[T]]],[11,R[6],E,E,3,[[[U]],[R[1]]]],[11,"into",E,E,3,[[],[U]]],[11,R[7],E,E,3,[[],[R[1]]]],[11,R[8],E,E,3,[[["self"]],[T]]],[11,R[9],E,E,3,[[["self"]],[T]]],[11,R[11],E,E,3,[[["self"]],[R[14]]]],[11,R[176],E,E,3,[[["self"]],["string"]]],[11,"from",E,E,4,[[[T]],[T]]],[11,R[6],E,E,4,[[[U]],[R[1]]]],[11,"into",E,E,4,[[],[U]]],[11,R[7],E,E,4,[[],[R[1]]]],[11,R[8],E,E,4,[[["self"]],[T]]],[11,R[9],E,E,4,[[["self"]],[T]]],[11,R[11],E,E,4,[[["self"]],[R[14]]]],[11,"from",E,E,5,[[[T]],[T]]],[11,R[6],E,E,5,[[[U]],[R[1]]]],[11,"into",E,E,5,[[],[U]]],[11,R[7],E,E,5,[[],[R[1]]]],[11,R[8],E,E,5,[[["self"]],[T]]],[11,R[9],E,E,5,[[["self"]],[T]]],[11,R[11],E,E,5,[[["self"]],[R[14]]]],[11,"from",E,E,0,[[[R[627]]],[R[606]]]],[11,"fmt",E,E,0,[[["self"],[R[12]]],[[R[1],["error"]],["error"]]]],[11,"fmt",E,E,3,[[["self"],[R[12]]],[[R[1],["error"]],["error"]]]],[11,"fmt",E,E,2,[[["self"],[R[12]]],[R[1]]]],[11,"fmt",E,E,0,[[[R[12]],["self"]],[R[1]]]],[11,"fmt",E,E,3,[[[R[12]],["self"]],[R[1]]]],[11,"fmt",E,E,4,[[[R[12]],["self"]],[R[1]]]],[11,"fmt",E,E,5,[[[R[12]],["self"]],[R[1]]]],[11,"fmt",E,E,2,[[["self"],[R[12]]],[R[1]]]],[11,"fmt",E,E,6,[[[R[12]],["self"]],[R[1]]]],[11,"eq",E,E,6,[[["self"],[R[597]]],["bool"]]],[11,"deref",E,E,7,[[["self"]],[R[682]]]],[11,"drop",E,E,2,[[["self"]]]],[11,"clone",E,E,0,[[["self"]],[R[606]]]],[11,"clone",E,E,6,[[["self"]],[R[597]]]],[11,R[442],E,E,7,[[["self"]]]]],"p":[[3,R[607]],[3,R[608]],[3,"Task"],[4,R[609]],[4,R[610]],[4,"RunState"],[3,"TaskRef"],[3,"TASKLIST"]]};
searchIndex["task_fs"]={"doc":"This crate contains the direcotires and files that…","i":[[3,"TaskFs","task_fs","The top level directory that includes a…",N,N],[3,"TaskDir",E,"A lazily computed directory that holds files and…",N,N],[12,"name",E,R[632],0,N],[3,"TaskFile",E,"Lazily computed file that holds information about this…",N,N],[3,"MmiDir",E,"Lazily computed directory that contains subfiles and…",N,N],[3,"MmiFile",E,"Lazily computed file that contains information about a…",N,N],[5,"init",E,"Initializes the tasks virtual filesystem directory within…",N,[[],[[R[1],["str"]],["str"]]]],[17,"TASKS_DIRECTORY_NAME",E,"The name of the VFS directory that exposes task info in…",N,N],[17,"TASKS_DIRECTORY_PATH",E,"The absolute path of the tasks directory, which is…",N,N],[11,"new",E,R[630],0,[[["dirref"],["string"],[R[597]]],[["str"],[R[1],["taskdir","str"]],["taskdir"]]]],[11,"new",E,E,1,[[[R[597]]],["taskfile"]]],[11,"new",E,R[630],2,[[[R[597]]],["mmidir"]]],[11,"new",E,E,3,[[[R[597]]],["mmifile"]]],[11,"from",E,E,4,[[[T]],[T]]],[11,R[6],E,E,4,[[[U]],[R[1]]]],[11,"into",E,E,4,[[],[U]]],[11,R[7],E,E,4,[[],[R[1]]]],[11,R[8],E,E,4,[[["self"]],[T]]],[11,R[9],E,E,4,[[["self"]],[T]]],[11,R[11],E,E,4,[[["self"]],[R[14]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[6],E,E,1,[[[U]],[R[1]]]],[11,"into",E,E,1,[[],[U]]],[11,R[7],E,E,1,[[],[R[1]]]],[11,R[8],E,E,1,[[["self"]],[T]]],[11,R[9],E,E,1,[[["self"]],[T]]],[11,R[11],E,E,1,[[["self"]],[R[14]]]],[11,"from",E,E,2,[[[T]],[T]]],[11,R[6],E,E,2,[[[U]],[R[1]]]],[11,"into",E,E,2,[[],[U]]],[11,R[7],E,E,2,[[],[R[1]]]],[11,R[8],E,E,2,[[["self"]],[T]]],[11,R[9],E,E,2,[[["self"]],[T]]],[11,R[11],E,E,2,[[["self"]],[R[14]]]],[11,"from",E,E,3,[[[T]],[T]]],[11,R[6],E,E,3,[[[U]],[R[1]]]],[11,"into",E,E,3,[[],[U]]],[11,R[7],E,E,3,[[],[R[1]]]],[11,R[8],E,E,3,[[["self"]],[T]]],[11,R[9],E,E,3,[[["self"]],[T]]],[11,R[11],E,E,3,[[["self"]],[R[14]]]],[11,R[329],E,E,4,[[["self"]],["string"]]],[11,R[338],E,E,4,[[["self"]],["string"]]],[11,R[330],E,E,4,[[["self"]],[[R[31],["dirref"]],["dirref"]]]],[11,R[331],E,E,4,[[["self"],[R[332]]]]],[11,R[329],E,E,0,[[["self"]],["string"]]],[11,R[338],E,E,0,[[["self"]],["string"]]],[11,R[330],E,E,0,[[["self"]],[[R[31],["dirref"]],["dirref"]]]],[11,R[331],E,E,0,[[["self"],[R[332]]]]],[11,R[329],E,E,1,[[["self"]],["string"]]],[11,R[338],E,E,1,[[["self"]],["string"]]],[11,R[330],E,E,1,[[["self"]],[[R[31],["dirref"]],["dirref"]]]],[11,R[331],E,E,1,[[["self"],[R[332]]]]],[11,R[329],E,E,2,[[["self"]],["string"]]],[11,R[338],E,E,2,[[["self"]],["string"]]],[11,R[330],E,E,2,[[["self"]],[[R[31],["dirref"]],["dirref"]]]],[11,R[331],E,E,2,[[["self"],[R[332]]]]],[11,R[329],E,E,3,[[["self"]],["string"]]],[11,R[338],E,E,3,[[["self"]],["string"]]],[11,R[330],E,E,3,[[["self"]],[[R[31],["dirref"]],["dirref"]]]],[11,R[331],E,E,3,[[["self"],[R[332]]]]],[11,"read",E,E,1,[[["usize"],["self"]],[["str"],["usize"],[R[1],["usize","str"]]]]],[11,"write",E,E,1,[[["self"],["usize"]],[["str"],["usize"],[R[1],["usize","str"]]]]],[11,"size",E,E,1,[[["self"]],["usize"]]],[11,R[339],E,E,1,[[["self"]],[[R[1],[R[168],"str"]],["str"],[R[168]]]]],[11,"read",E,E,3,[[["usize"],["self"]],[["str"],["usize"],[R[1],["usize","str"]]]]],[11,"write",E,E,3,[[["self"],["usize"]],[["str"],["usize"],[R[1],["usize","str"]]]]],[11,"size",E,E,3,[[["self"]],["usize"]]],[11,R[339],E,E,3,[[["self"]],[[R[1],[R[168],"str"]],["str"],[R[168]]]]],[11,"insert",E,"This function adds a newly created fs node (the argument)…",4,[[["self"],[R[328]]],[[R[1],[R[31],"str"]],["str"],[R[31],[R[328]]]]]],[11,"get",E,E,4,[[["str"],["self"]],[[R[328]],[R[31],[R[328]]]]]],[11,"list",E,R[631],4,[[["self"]],[["string"],["vec",["string"]]]]],[11,"remove",E,E,4,[[["self"],[R[328]]],[[R[328]],[R[31],[R[328]]]]]],[11,"insert",E,E,0,[[["self"],[R[328]]],[[R[1],[R[31],"str"]],["str"],[R[31],[R[328]]]]]],[11,"get",E,E,0,[[["str"],["self"]],[[R[328]],[R[31],[R[328]]]]]],[11,"list",E,R[631],0,[[["self"]],[["string"],["vec",["string"]]]]],[11,"remove",E,E,0,[[["self"],[R[328]]],[[R[328]],[R[31],[R[328]]]]]],[11,"insert",E,E,2,[[["self"],[R[328]]],[[R[1],[R[31],"str"]],["str"],[R[31],[R[328]]]]]],[11,"get",E,E,2,[[["str"],["self"]],[[R[328]],[R[31],[R[328]]]]]],[11,"list",E,R[631],2,[[["self"]],[["string"],["vec",["string"]]]]],[11,"remove",E,E,2,[[["self"],[R[328]]],[[R[328]],[R[31],[R[328]]]]]]],"p":[[3,"TaskDir"],[3,"TaskFile"],[3,"MmiDir"],[3,"MmiFile"],[3,"TaskFs"]]};
searchIndex["terminal_print"]={"doc":"Applications that want to print to their parent terminal…","i":[[5,"add_child","terminal_print","Adds the (child application's task ID, parent terminal…",N,[[["event"],["usize"],[R[628],["event"]]],[[R[1],["str"]],["str"]]]],[5,"remove_child",E,"Removes the (child application's task ID, parent terminal…",N,[[["usize"]],[[R[1],["str"]],["str"]]]],[5,"print_to_stdout_args",E,"Converts the given `core::fmt::Arguments` to a `String`…",N,[[[R[72]]]]],[14,"println",E,"Calls `print!()` with an extra newline ('\\n') appended to…",N,N],[14,"print",E,R[629],N,N]],"p":[]};
searchIndex["text_display"]={"doc":"This crate defines a text displayable. A text displayable…","i":[[3,R[784],"text_display","A text displayable profiles the size and color of a block…",N,N],[11,"new",E,"Creates a new text displayable. # Arguments * `width`,…",0,[[["usize"],["color"]],[[R[783]],["str"],[R[1],[R[783],"str"]]]]],[11,"get_bg_color",E,"Gets the background color of the text area",0,[[["self"]],["color"]]],[11,"reset_cache",E,"Clear the cache of the text displayable.",0,[[["self"]]]],[11,"get_location",E,"Translate the index of a character in the text to the…",0,[[["self"],["usize"]]]],[11,"get_index",E,"Translate the location of a character to its index in the…",0,[[["self"],["usize"]],["usize"]]],[11,"get_dimensions",E,"Gets the size of a text displayable in number of characters.",0,[[["self"]]]],[11,"get_next_index",E,"Gets the index of next character to be displayabled. It is…",0,[[["self"]],["usize"]]],[11,"set_text",E,"Sets the text of the text displayable",0,[[["str"],["self"]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,"fmt",E,E,0,[[[R[12]],["self"]],[R[1]]]],[11,"display",E,E,0,[[[R[763]],["self"],["coord"]],[[R[15]],[R[1],[R[15],"str"]],["str"]]]],[11,"set_size",E,E,0,[[["self"],["usize"]]]],[11,R[774],E,E,0,[[["self"]]]]],"p":[[3,R[784]]]};
searchIndex["tlb_shootdown"]={"doc":"Support for broadcasting and handling TLB shootdown IPIs. ","i":[[5,"init","tlb_shootdown","Initializes data, functions, and structures for the TLB…",N,[[]]],[5,"handle_tlb_shootdown_ipi",E,"Handles a TLB shootdown ipi by flushing the…",N,[[[R[89]]]]],[5,"send_tlb_shootdown_ipi",E,"Sends an IPI to all other cores (except me) to trigger a…",N,[[[R[305]],[R[89]]]]],[7,"TLB_SHOOTDOWN_IPI_COUNT",E,"The number of remaining cores that still need to handle…",N,N],[7,"TLB_SHOOTDOWN_IPI_LOCK",E,"The lock that makes sure only one set of TLB shootdown…",N,N],[7,"TLB_SHOOTDOWN_IPI_PAGES",E,"The range of pages for a TLB shootdown IPI.",N,N],[17,"TLB_SHOOTDOWN_IPI_IRQ",E,"The IRQ number used for IPIs",N,N]],"p":[]};
searchIndex["tsc"]={"doc":E,"i":[[3,R[80],"tsc",E,N,N],[5,"tsc_ticks",E,"Returns the current number of ticks from the TSC, i.e.,…",N,[[],[R[79]]]],[5,"get_tsc_frequency",E,"Returns the frequency of the TSC for the system, currently…",N,[[],[["str"],["u64"],[R[1],["u64","str"]]]]],[11,"to_ns",E,"Converts ticks to nanoseconds. Returns None if the TSC…",0,[[["self"]],[["u64"],[R[31],["u64"]]]]],[11,"sub",E,"Checked subtraction. Computes `self - other`, returning…",0,[[[R[79]],["self"]],[[R[31],[R[79]]],[R[79]]]]],[11,"add",E,"Checked addition. Computes `self + other`, returning…",0,[[[R[79]],["self"]],[[R[31],[R[79]]],[R[79]]]]],[11,"into",E,"Get the inner value, the number of ticks.",0,[[],["u64"]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,"fmt",E,E,0,[[[R[12]],["self"]],[R[1]]]]],"p":[[3,R[80]]]};
searchIndex["tss"]={"doc":E,"i":[[5,"tss_set_rsp0","tss","Sets the current core's TSS privilege stack 0 (RSP0)…",N,[[[R[81]]],[[R[1],["str"]],["str"]]]],[5,"create_tss",E,"set up TSS entry for the given AP core. Returns a…",N,[[[R[81]],["u8"]],["mutex"]]],[17,"DOUBLE_FAULT_IST_INDEX",E,"The index of the double fault stack in a TaskStateSegment…",N,N]],"p":[]};
searchIndex["unified_channel"]={"doc":"A cfg-based wrapper that unifies rendezvous channels and…","i":[[3,R[721],"unified_channel",E,N,N],[3,R[722],E,E,N,N],[5,"new_string_channel",E,E,N,[[["usize"]]]],[11,"send",E,E,0,[[["string"],["self"]],[[R[1],["str"]],["str"]]]],[11,"receive",E,E,1,[[["self"]],[["string"],["str"],[R[1],["string","str"]]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,R[64],E,E,0,[[["self"]],[T]]],[11,R[65],E,E,0,[[["self"],[T]]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[6],E,E,1,[[[U]],[R[1]]]],[11,"into",E,E,1,[[],[U]]],[11,R[7],E,E,1,[[],[R[1]]]],[11,R[8],E,E,1,[[["self"]],[T]]],[11,R[9],E,E,1,[[["self"]],[T]]],[11,R[11],E,E,1,[[["self"]],[R[14]]]],[11,R[64],E,E,1,[[["self"]],[T]]],[11,R[65],E,E,1,[[["self"],[T]]]],[11,"clone",E,E,0,[[["self"]],["stringsender"]]],[11,"clone",E,E,1,[[["self"]],["stringreceiver"]]]],"p":[[3,R[721]],[3,R[722]]]};
searchIndex["unwind"]={"doc":"Support for unwinding the call stack and cleaning up stack…","i":[[3,R[696],"unwind","This is the context/state that is used during unwinding…",N,N],[3,R[694],E,"A single frame in the stack, which contains…",N,N],[3,R[695],E,"An iterator over the stack frames on the current task's…",N,N],[5,"invoke_with_current_registers",E,"This function saves the current CPU register values onto…",N,[[["f"]],[[R[1],["str"]],["str"]]]],[11,"personality",E,"The address of the personality function that corresponds…",0,[[["self"]],[["u64"],[R[31],["u64"]]]]],[11,"lsda",E,"The address of the Language-Specific Data Area (LSDA) that…",0,[[["self"]],[["u64"],[R[31],["u64"]]]]],[11,"call_site_address",E,"The call site of this stack frame, i.e., the address of…",0,[[["self"]],["u64"]]],[11,"initial_address",E,"The address (starting instruction pointer) of the function…",0,[[["self"]],["u64"]]],[11,R[692],E,"Returns the array of register values as they existed…",1,[[["self"]],[R[692]]]],[11,R[693],E,"Returns a reference to the underlying `CrateNamespace`…",1,[[["self"]],["arc"]]],[25,"FuncWithRegisters",E,E,N,N],[11,"from",E,E,2,[[[T]],[T]]],[11,R[6],E,E,2,[[[U]],[R[1]]]],[11,"into",E,E,2,[[],[U]]],[11,R[7],E,E,2,[[],[R[1]]]],[11,R[8],E,E,2,[[["self"]],[T]]],[11,R[9],E,E,2,[[["self"]],[T]]],[11,R[11],E,E,2,[[["self"]],[R[14]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[6],E,E,1,[[[U]],[R[1]]]],[11,"into",E,E,1,[[],[U]]],[11,R[7],E,E,1,[[],[R[1]]]],[11,R[8],E,E,1,[[["self"]],[T]]],[11,R[9],E,E,1,[[["self"]],[T]]],[11,R[11],E,E,1,[[["self"]],[R[14]]]],[11,"into_fallible_iter",E,E,1,[[],["i"]]],[11,"fmt",E,E,0,[[[R[12]],["self"]],[R[1]]]],[11,"fmt",E,E,1,[[["self"],[R[12]]],[R[1]]]],[11,"into",E,E,2,[[]]],[11,"next",E,E,1,[[["self"]],[[R[31]],[R[1],[R[31]]]]]]],"p":[[3,R[694]],[3,R[695]],[3,R[696]]]};
searchIndex["vfs_node"]={"doc":"This crate contains a very basic, generic concrete…","i":[[3,R[340],"vfs_node",R[343],N,N],[12,"name",E,R[632],0,N],[12,"children",E,"A list of child filesystem nodes",0,N],[12,"parent",E,"A weak reference to the parent directory",0,N],[3,"VFSFile",E,E,N,N],[11,"new",E,R[630],0,[[["string"],["dirref"]],[[R[1],["dirref","str"]],["str"],["dirref"]]]],[11,"new",E,E,1,[[["string"],["usize"],["dirref"]],[[R[337]],[R[1],[R[337],"str"]],["str"]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[6],E,E,1,[[[U]],[R[1]]]],[11,"into",E,E,1,[[],[U]]],[11,R[7],E,E,1,[[],[R[1]]]],[11,R[8],E,E,1,[[["self"]],[T]]],[11,R[9],E,E,1,[[["self"]],[T]]],[11,R[11],E,E,1,[[["self"]],[R[14]]]],[11,R[338],E,E,0,[[["self"]],["string"]]],[11,R[330],E,"Returns a pointer to the parent if it exists",0,[[["self"]],[[R[31],["dirref"]],["dirref"]]]],[11,R[331],E,E,0,[[["self"],[R[332]]]]],[11,R[338],E,E,1,[[["self"]],["string"]]],[11,R[330],E,E,1,[[["self"]],[[R[31],["dirref"]],["dirref"]]]],[11,R[331],E,E,1,[[["self"],[R[332]]]]],[11,"read",E,E,1,[[["usize"],["self"]],[["str"],["usize"],[R[1],["usize","str"]]]]],[11,"write",E,E,1,[[["self"],["usize"]],[["str"],["usize"],[R[1],["usize","str"]]]]],[11,"size",E,E,1,[[["self"]],["usize"]]],[11,R[339],E,E,1,[[["self"]],[[R[1],[R[168],"str"]],[R[168]],["str"]]]],[11,"insert",E,E,0,[[["self"],[R[328]]],[[R[1],[R[31],"str"]],[R[31],[R[328]]],["str"]]]],[11,"get",E,E,0,[[["str"],["self"]],[[R[328]],[R[31],[R[328]]]]]],[11,"list",E,R[631],0,[[["self"]],[["string"],["vec",["string"]]]]],[11,"remove",E,E,0,[[["self"],[R[328]]],[[R[328]],[R[31],[R[328]]]]]]],"p":[[3,R[340]],[3,"VFSFile"]]};
searchIndex["vga_buffer"]={"doc":"Support for basic printing to a simple 80x25 text-mode VGA…","i":[[3,R[75],"vga_buffer",E,N,N],[3,R[76],E,E,N,N],[4,"Color",E,E,N,N],[13,"Black",E,E,0,N],[13,"Blue",E,E,0,N],[13,"Green",E,E,0,N],[13,"Cyan",E,E,0,N],[13,"Red",E,E,0,N],[13,"Magenta",E,E,0,N],[13,"Brown",E,E,0,N],[13,"LightGray",E,E,0,N],[13,"DarkGray",E,E,0,N],[13,"LightBlue",E,E,0,N],[13,"LightGreen",E,E,0,N],[13,"LightCyan",E,E,0,N],[13,"LightRed",E,E,0,N],[13,"Pink",E,E,0,N],[13,"Yellow",E,E,0,N],[13,"White",E,E,0,N],[11,"new",E,E,1,[[["color"]],[R[73]]]],[11,"new",E,E,2,[[[R[73]],["u8"]],[R[74]]]],[14,"print_raw",E,E,N,N],[14,"println_raw",E,E,N,N],[11,"from",E,E,1,[[[T]],[T]]],[11,R[6],E,E,1,[[[U]],[R[1]]]],[11,"into",E,E,1,[[],[U]]],[11,R[7],E,E,1,[[],[R[1]]]],[11,R[8],E,E,1,[[["self"]],[T]]],[11,R[9],E,E,1,[[["self"]],[T]]],[11,R[11],E,E,1,[[["self"]],[R[14]]]],[11,R[64],E,E,1,[[["self"]],[T]]],[11,R[65],E,E,1,[[["self"],[T]]]],[11,"from",E,E,2,[[[T]],[T]]],[11,R[6],E,E,2,[[[U]],[R[1]]]],[11,"into",E,E,2,[[],[U]]],[11,R[7],E,E,2,[[],[R[1]]]],[11,R[8],E,E,2,[[["self"]],[T]]],[11,R[9],E,E,2,[[["self"]],[T]]],[11,R[11],E,E,2,[[["self"]],[R[14]]]],[11,R[64],E,E,2,[[["self"]],[T]]],[11,R[65],E,E,2,[[["self"],[T]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,R[64],E,E,0,[[["self"]],[T]]],[11,R[65],E,E,0,[[["self"],[T]]]],[11,"fmt",E,E,0,[[[R[12]],["self"]],[R[1]]]],[11,"fmt",E,E,1,[[[R[12]],["self"]],[R[1]]]],[11,"fmt",E,E,2,[[[R[12]],["self"]],[R[1]]]],[11,"clone",E,E,0,[[["self"]],["color"]]],[11,"clone",E,E,1,[[["self"]],[R[73]]]],[11,"clone",E,E,2,[[["self"]],[R[74]]]],[11,R[38],E,E,1,[[],[R[73]]]]],"p":[[4,"Color"],[3,R[75]],[3,R[76]]]};
searchIndex["wait_condition"]={"doc":"Simple condition variables that are convenience wrappers…","i":[[3,R[698],"wait_condition","A condition variable that allows multiple `Task`s to wait…",N,N],[3,R[699],E,"A type wrapper that guarantees a given condition has been…",N,N],[11,"new",E,"Create a new `WaitCondition` in which `Task`s can wait for…",0,[[["f"]],["waitcondition"]]],[11,"wait",E,"Waits for the condition to be true in a blocking fashion…",0,[[["self"]],[[R[674]],[R[1],[R[674]]]]]],[11,"condition_satisfied",E,"This function should be invoked after the wait condition…",0,[[["self"]],[[R[31],[R[697]]],[R[697]]]]],[11,R[700],E,"Wake up a random `Task` that is waiting on this condition.…",1,[[["self"]],["bool"]]],[11,R[701],E,"Wake up a specific `Task` that is waiting on this…",1,[[["self"],[R[597]]],["bool"]]],[25,"WaitConditionFn",E,"The closure type that can be used within a…",N,N],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[6],E,E,1,[[[U]],[R[1]]]],[11,"into",E,E,1,[[],[U]]],[11,R[7],E,E,1,[[],[R[1]]]],[11,R[8],E,E,1,[[["self"]],[T]]],[11,R[9],E,E,1,[[["self"]],[T]]],[11,R[11],E,E,1,[[["self"]],[R[14]]]]],"p":[[3,R[698]],[3,R[699]]]};
searchIndex["wait_queue"]={"doc":E,"i":[[3,R[676],"wait_queue","An object that holds a blocked `Task` that will be…",N,N],[3,R[677],E,"A queue in which multiple `Task`s can wait for other…",N,N],[4,R[675],E,"Errors that may occur while waiting on a…",N,N],[13,"NoCurrentTask",E,E,0,N],[13,"Interrupted",E,E,0,N],[13,"Timeout",E,E,0,N],[13,"SpuriousWakeup",E,E,0,N],[11,"new",E,"Blocks the given `Task` and returns a new `WaitGuard`…",1,[[[R[597]]],["waitguard"]]],[11,"block_again",E,"Blocks the task guarded by this waitguard, which is useful…",1,[[["self"]]]],[11,"task",E,"Returns a reference to the `Task` being blocked in this…",1,[[["self"]],[R[597]]]],[11,"new",E,R[672],2,[[],[R[673]]]],[11,"with_capacity",E,R[672],2,[[["usize"]],[R[673]]]],[11,"wait",E,"Puts the current `Task` to sleep where it blocks on this…",2,[[["self"]],[[R[1],[R[674]]],[R[674]]]]],[11,"wait_until",E,"Similar to `wait`, but this function blocks until the…",2,[[["self"],["fn"]],[[R[674]],[R[1],[R[674]]]]]],[11,"wait_until_mut",E,"Similar to `wait_until`, but this function accepts a…",2,[[["fnmut"],["self"]],[[R[674]],[R[1],[R[674]]]]]],[11,R[700],E,"Wake up one random `Task` that is waiting on this queue. #…",2,[[["self"]],["bool"]]],[11,R[701],E,"Wake up a specific `Task` that is waiting on this queue. #…",2,[[["self"],[R[597]]],["bool"]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[6],E,E,1,[[[U]],[R[1]]]],[11,"into",E,E,1,[[],[U]]],[11,R[7],E,E,1,[[],[R[1]]]],[11,R[8],E,E,1,[[["self"]],[T]]],[11,R[9],E,E,1,[[["self"]],[T]]],[11,R[11],E,E,1,[[["self"]],[R[14]]]],[11,"from",E,E,2,[[[T]],[T]]],[11,R[6],E,E,2,[[[U]],[R[1]]]],[11,"into",E,E,2,[[],[U]]],[11,R[7],E,E,2,[[],[R[1]]]],[11,R[8],E,E,2,[[["self"]],[T]]],[11,R[9],E,E,2,[[["self"]],[T]]],[11,R[11],E,E,2,[[["self"]],[R[14]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,"fmt",E,E,0,[[[R[12]],["self"]],[R[1]]]],[11,"eq",E,E,0,[[[R[674]],["self"]],["bool"]]],[11,"drop",E,E,1,[[["self"]]]]],"p":[[4,R[675]],[3,R[676]],[3,R[677]]]};
searchIndex["window"]={"doc":"A `Window` object should be owned by an application. It…","i":[[3,"Window","window","This struct is the application-facing representation of a…",N,N],[11,"new",E,"Creates a new window to be displayed on screen. ",0,[[["coord"],["usize"],["color"]],[[R[1],["window","str"]],["window"],["str"]]]],[11,"handle_event",E,"Tries to receive an `Event` that has been sent to this…",0,[[["self"]],[[R[31],["event"]],["str"],[R[1],[R[31],"str"]]]]],[11,"render",E,"Renders the area of this `Window` specified by the given…",0,[[["self"],[R[15]],[R[31],[R[15]]]],[[R[1],["str"]],["str"]]]],[11,"area",E,"Returns a `Rectangle` describing the position and…",0,[[["self"]],[R[15]]]],[11,R[763],E,R[787],0,[[["self"]],[[R[763],[R[773]]],[R[786]],["mutexguardref",[R[786],R[763]]]]]],[11,R[788],E,R[789],0,[[["self"]],[["mutexguardrefmut",[R[786],R[763]]],[R[786]],[R[763],[R[773]]]]]],[11,R[790],E,"Returns `true` if this window is the currently active…",0,[[["self"]],["bool"]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,"drop",E,E,0,[[["self"]]]]],"p":[[3,"Window"]]};
searchIndex["window_inner"]={"doc":"The `WindowInner` struct is the internal representation of…","i":[[3,R[776],"window_inner","The `WindowInner` struct is the internal system-facing…",N,N],[12,"border_size",E,"The width of the border in pixels. By default, there is a…",0,N],[12,"title_bar_height",E,"The height of title bar in pixels. By default, there is…",0,N],[12,"moving",E,"Whether a window is moving or stationary.",0,N],[4,R[777],E,"Whether a window is moving (being dragged by the mouse).",N,N],[13,"Stationary",E,"The window is not in motion.",1,N],[13,"Moving",E,"The window is currently in motion. The enclosed `Coord`…",1,N],[17,"DEFAULT_TITLE_BAR_HEIGHT",E,E,N,N],[17,"DEFAULT_BORDER_SIZE",E,E,N,N],[11,"new",E,"Creates a new `WindowInner` object backed by the given…",0,[[[R[763],[R[773]]],["coord"],["event"],["queue",["event"]],[R[773]]],[R[786]]]],[11,R[249],E,"Returns `true` if the given `coordinate` (relative to the…",0,[[["coord"],["self"]],["bool"]]],[11,R[774],E,"Gets the size of a window in pixels",0,[[["self"]]]],[11,"get_position",E,"Gets the top-left position of the window relative to the…",0,[[["self"]],["coord"]]],[11,"set_position",E,"Sets the top-left position of the window relative to the…",0,[[["self"],["coord"]]]],[11,R[763],E,R[787],0,[[["self"]],[R[763]]]],[11,R[788],E,R[789],0,[[["self"]],[R[763]]]],[11,R[775],E,"Returns the pixel value at the given `coordinate`, if the…",0,[[["coord"],["self"]],[[R[31],[R[773]]],[R[773]]]]],[11,"get_border_size",E,"Returns the size of the Window border in pixels. There is…",0,[[["self"]],["usize"]]],[11,"get_title_bar_height",E,"Returns the size of the Window title bar in pixels. There…",0,[[["self"]],["usize"]]],[11,"content_area",E,"Returns the position and dimensions of the Window's…",0,[[["self"]],[R[15]]]],[11,"resize",E,"Resizes and moves this window to fit the given `Rectangle`…",0,[[["self"],[R[15]]],[[R[1],["str"]],["str"]]]],[11,"send_event",E,"Sends the given `event` to this window.",0,[[["self"],["event"]],[[R[1],["event"]],["event"]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[6],E,E,1,[[[U]],[R[1]]]],[11,"into",E,E,1,[[],[U]]],[11,R[7],E,E,1,[[],[R[1]]]],[11,R[8],E,E,1,[[["self"]],[T]]],[11,R[9],E,E,1,[[["self"]],[T]]],[11,R[11],E,E,1,[[["self"]],[R[14]]]]],"p":[[3,R[776]],[4,R[777]]]};
searchIndex["window_manager"]={"doc":"This crate acts as a manager of a list of windows. It…","i":[[3,R[785],"window_manager","Window manager structure which maintains a list of windows…",N,N],[12,"final_fb",E,"The final framebuffer which is mapped to the screen (the…",0,N],[5,"init",E,"Initialize the window manager. It returns…",N,[[],[[R[1],["str"]],["str"]]]],[7,"WINDOW_MANAGER",E,"The instance of the default window manager",N,N],[11,"set_active",E,"Sets one window as active, push last active (if exists) to…",0,[[["self"],["arc"],["bool"]],[["bool"],["str"],[R[1],["bool","str"]]]]],[11,"delete_window",E,"delete a window and refresh its region",0,[[["self"],["arc"]],[[R[1],["str"]],["str"]]]],[11,"refresh_bottom_windows",E,"Refresh the region in `bounding_box`. Only render the…",0,[[["self"],["bool"]],[[R[1],["str"]],["str"]]]],[11,"refresh_top",E,"Refresh the region of `bounding_box` in the top framebuffer",0,[[["self"]],[[R[1],["str"]],["str"]]]],[11,"refresh_windows",E,"Refresh the part in `bounding_box` of every window.…",0,[[["self"]],[[R[1],["str"]],["str"]]]],[11,"refresh_active_window",E,"Refresh the part in `bounding_box` of the active window.…",0,[[["self"],[R[31],[R[15]]],[R[15]]],[[R[1],["str"]],["str"]]]],[11,"move_active_window",E,"take active window's base position and current mouse, move…",0,[[["self"]],[[R[1],["str"]],["str"]]]],[11,"refresh_mouse",E,"Refresh the mouse display",0,[[["self"]],[[R[1],["str"]],["str"]]]],[11,"move_floating_border",E,"Move the floating border when a window is moving.",0,[[["self"]],[[R[1],["str"]],["str"]]]],[11,R[790],E,"Returns true if the given `window` is the currently active…",0,[[["self"],["arc"]],["bool"]]],[11,"get_screen_size",E,"Returns the `(width, height)` in pixels of the screen…",0,[[["self"]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[6],E,E,0,[[[U]],[R[1]]]],[11,"into",E,E,0,[[],[U]]],[11,R[7],E,E,0,[[],[R[1]]]],[11,R[8],E,E,0,[[["self"]],[T]]],[11,R[9],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"]],[R[14]]]]],"p":[[3,R[785]]]};
initSearch(searchIndex);addSearchOptions(searchIndex);